#!/usr/bin/env python3
# coding: utf-8
if '__PHP2PY_LOADED__' not in globals():
    import os
    with open(os.getenv('PHP2PY_COMPAT', 'php_compat.py')) as f:
        exec(compile(f.read(), '<string>', 'exec'))
    # end with
    globals()['__PHP2PY_LOADED__'] = True
# end if
#// --------------------------------------------------------------------------------
#// PhpConcept Library - Zip Module 2.8.2
#// --------------------------------------------------------------------------------
#// License GNU/LGPL - Vincent Blavet - August 2009
#// http://www.phpconcept.net
#// --------------------------------------------------------------------------------
#// 
#// Presentation :
#// PclZip is a PHP library that manage ZIP archives.
#// So far tests show that archives generated by PclZip are readable by
#// WinZip application and other tools.
#// 
#// Description :
#// See readme.txt and http://www.phpconcept.net
#// 
#// Warning :
#// This library and the associated files are non commercial, non professional
#// work.
#// It should not have unexpected results. However if any damage is caused by
#// this software the author can not be responsible.
#// The use of this software is at the risk of the user.
#// 
#// --------------------------------------------------------------------------------
#// $Id: pclzip.lib.php,v 1.60 2009/09/30 21:01:04 vblavet Exp $
#// --------------------------------------------------------------------------------
#// ----- Constants
if (not php_defined("PCLZIP_READ_BLOCK_SIZE")):
    php_define("PCLZIP_READ_BLOCK_SIZE", 2048)
# end if
#// ----- File list separator
#// In version 1.x of PclZip, the separator for file list is a space
#// (which is not a very smart choice, specifically for windows paths !).
#// A better separator should be a comma (,). This constant gives you the
#// ability to change that.
#// However notice that changing this value, may have impact on existing
#// scripts, using space separated filenames.
#// Recommended values for compatibility with older versions :
#// define( 'PCLZIP_SEPARATOR', ' ' );
#// Recommended values for smart separation of filenames.
if (not php_defined("PCLZIP_SEPARATOR")):
    php_define("PCLZIP_SEPARATOR", ",")
# end if
#// ----- Error configuration
#// 0 : PclZip Class integrated error handling
#// 1 : PclError external library error handling. By enabling this
#// you must ensure that you have included PclError library.
#// [2,...] : reserved for futur use
if (not php_defined("PCLZIP_ERROR_EXTERNAL")):
    php_define("PCLZIP_ERROR_EXTERNAL", 0)
# end if
#// ----- Optional static temporary directory
#// By default temporary files are generated in the script current
#// path.
#// If defined :
#// - MUST BE terminated by a '/'.
#// - MUST be a valid, already created directory
#// Samples :
#// define( 'PCLZIP_TEMPORARY_DIR', '/temp/' );
#// define( 'PCLZIP_TEMPORARY_DIR', 'C:/Temp/' );
if (not php_defined("PCLZIP_TEMPORARY_DIR")):
    php_define("PCLZIP_TEMPORARY_DIR", "")
# end if
#// ----- Optional threshold ratio for use of temporary files
#// Pclzip sense the size of the file to add/extract and decide to
#// use or not temporary file. The algorithm is looking for
#// memory_limit of PHP and apply a ratio.
#// threshold = memory_limit * ratio.
#// Recommended values are under 0.5. Default 0.47.
#// Samples :
#// define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.5 );
if (not php_defined("PCLZIP_TEMPORARY_FILE_RATIO")):
    php_define("PCLZIP_TEMPORARY_FILE_RATIO", 0.47)
# end if
#// --------------------------------------------------------------------------------
#// UNDER THIS LINE NOTHING NEEDS TO BE MODIFIED
#// --------------------------------------------------------------------------------
#// ----- Global variables
g_pclzip_version_ = "2.8.2"
#// ----- Error codes
#// -1 : Unable to open file in binary write mode
#// -2 : Unable to open file in binary read mode
#// -3 : Invalid parameters
#// -4 : File does not exist
#// -5 : Filename is too long (max. 255)
#// -6 : Not a valid zip file
#// -7 : Invalid extracted file size
#// -8 : Unable to create directory
#// -9 : Invalid archive extension
#// -10 : Invalid archive format
#// -11 : Unable to delete file (unlink)
#// -12 : Unable to rename file (rename)
#// -13 : Invalid header checksum
#// -14 : Invalid archive size
php_define("PCLZIP_ERR_USER_ABORTED", 2)
php_define("PCLZIP_ERR_NO_ERROR", 0)
php_define("PCLZIP_ERR_WRITE_OPEN_FAIL", -1)
php_define("PCLZIP_ERR_READ_OPEN_FAIL", -2)
php_define("PCLZIP_ERR_INVALID_PARAMETER", -3)
php_define("PCLZIP_ERR_MISSING_FILE", -4)
php_define("PCLZIP_ERR_FILENAME_TOO_LONG", -5)
php_define("PCLZIP_ERR_INVALID_ZIP", -6)
php_define("PCLZIP_ERR_BAD_EXTRACTED_FILE", -7)
php_define("PCLZIP_ERR_DIR_CREATE_FAIL", -8)
php_define("PCLZIP_ERR_BAD_EXTENSION", -9)
php_define("PCLZIP_ERR_BAD_FORMAT", -10)
php_define("PCLZIP_ERR_DELETE_FILE_FAIL", -11)
php_define("PCLZIP_ERR_RENAME_FILE_FAIL", -12)
php_define("PCLZIP_ERR_BAD_CHECKSUM", -13)
php_define("PCLZIP_ERR_INVALID_ARCHIVE_ZIP", -14)
php_define("PCLZIP_ERR_MISSING_OPTION_VALUE", -15)
php_define("PCLZIP_ERR_INVALID_OPTION_VALUE", -16)
php_define("PCLZIP_ERR_ALREADY_A_DIRECTORY", -17)
php_define("PCLZIP_ERR_UNSUPPORTED_COMPRESSION", -18)
php_define("PCLZIP_ERR_UNSUPPORTED_ENCRYPTION", -19)
php_define("PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE", -20)
php_define("PCLZIP_ERR_DIRECTORY_RESTRICTION", -21)
#// ----- Options values
php_define("PCLZIP_OPT_PATH", 77001)
php_define("PCLZIP_OPT_ADD_PATH", 77002)
php_define("PCLZIP_OPT_REMOVE_PATH", 77003)
php_define("PCLZIP_OPT_REMOVE_ALL_PATH", 77004)
php_define("PCLZIP_OPT_SET_CHMOD", 77005)
php_define("PCLZIP_OPT_EXTRACT_AS_STRING", 77006)
php_define("PCLZIP_OPT_NO_COMPRESSION", 77007)
php_define("PCLZIP_OPT_BY_NAME", 77008)
php_define("PCLZIP_OPT_BY_INDEX", 77009)
php_define("PCLZIP_OPT_BY_EREG", 77010)
php_define("PCLZIP_OPT_BY_PREG", 77011)
php_define("PCLZIP_OPT_COMMENT", 77012)
php_define("PCLZIP_OPT_ADD_COMMENT", 77013)
php_define("PCLZIP_OPT_PREPEND_COMMENT", 77014)
php_define("PCLZIP_OPT_EXTRACT_IN_OUTPUT", 77015)
php_define("PCLZIP_OPT_REPLACE_NEWER", 77016)
php_define("PCLZIP_OPT_STOP_ON_ERROR", 77017)
#// Having big trouble with crypt. Need to multiply 2 long int
#// which is not correctly supported by PHP ...
#// define( 'PCLZIP_OPT_CRYPT', 77018 );
php_define("PCLZIP_OPT_EXTRACT_DIR_RESTRICTION", 77019)
php_define("PCLZIP_OPT_TEMP_FILE_THRESHOLD", 77020)
php_define("PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD", 77020)
#// alias
php_define("PCLZIP_OPT_TEMP_FILE_ON", 77021)
php_define("PCLZIP_OPT_ADD_TEMP_FILE_ON", 77021)
#// alias
php_define("PCLZIP_OPT_TEMP_FILE_OFF", 77022)
php_define("PCLZIP_OPT_ADD_TEMP_FILE_OFF", 77022)
#// alias
#// ----- File description attributes
php_define("PCLZIP_ATT_FILE_NAME", 79001)
php_define("PCLZIP_ATT_FILE_NEW_SHORT_NAME", 79002)
php_define("PCLZIP_ATT_FILE_NEW_FULL_NAME", 79003)
php_define("PCLZIP_ATT_FILE_MTIME", 79004)
php_define("PCLZIP_ATT_FILE_CONTENT", 79005)
php_define("PCLZIP_ATT_FILE_COMMENT", 79006)
#// ----- Call backs values
php_define("PCLZIP_CB_PRE_EXTRACT", 78001)
php_define("PCLZIP_CB_POST_EXTRACT", 78002)
php_define("PCLZIP_CB_PRE_ADD", 78003)
php_define("PCLZIP_CB_POST_ADD", 78004)
#// For futur use
#// define( 'PCLZIP_CB_PRE_LIST', 78005 );
#// define( 'PCLZIP_CB_POST_LIST', 78006 );
#// define( 'PCLZIP_CB_PRE_DELETE', 78007 );
#// define( 'PCLZIP_CB_POST_DELETE', 78008 );
#// 
#// --------------------------------------------------------------------------------
#// Class : PclZip
#// Description :
#// PclZip is the class that represent a Zip archive.
#// The public methods allow the manipulation of the archive.
#// Attributes :
#// Attributes must not be accessed directly.
#// Methods :
#// PclZip() : Object creator
#// create() : Creates the Zip archive
#// listContent() : List the content of the Zip archive
#// extract() : Extract the content of the archive
#// properties() : List the properties of the archive
#// --------------------------------------------------------------------------------
class PclZip():
    #// ----- Filename of the zip file
    zipname = ""
    #// ----- File descriptor of the zip file
    zip_fd = 0
    #// ----- Internal error handling
    error_code = 1
    error_string = ""
    #// ----- Current status of the magic_quotes_runtime
    #// This value store the php configuration for magic_quotes
    #// The class can then disable the magic_quotes and reset it after
    magic_quotes_status = Array()
    #// --------------------------------------------------------------------------------
    #// Function : PclZip()
    #// Description :
    #// Creates a PclZip object and set the name of the associated Zip archive
    #// filename.
    #// Note that no real action is taken, if the archive does not exist it is not
    #// created. Use create() for that.
    #// --------------------------------------------------------------------------------
    def __init__(self, p_zipname_=None):
        
        
        #// ----- Tests the zlib
        if (not php_function_exists("gzopen")):
            php_print("Abort " + php_basename(__FILE__) + " : Missing zlib extensions")
            php_exit()
        # end if
        #// ----- Set the attributes
        self.zipname = p_zipname_
        self.zip_fd = 0
        self.magic_quotes_status = -1
        #// ----- Return
        return
    # end def __init__
    def pclzip(self, p_zipname_=None):
        
        
        self.__init__(p_zipname_)
    # end def pclzip
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function :
    #// create($p_filelist, $p_add_dir="", $p_remove_dir="")
    #// create($p_filelist, $p_option, $p_option_value, ...)
    #// Description :
    #// This method supports two different synopsis. The first one is historical.
    #// This method creates a Zip Archive. The Zip file is created in the
    #// filesystem. The files and directories indicated in $p_filelist
    #// are added in the archive. See the parameters description for the
    #// supported format of $p_filelist.
    #// When a directory is in the list, the directory and its content is added
    #// in the archive.
    #// In this synopsis, the function takes an optional variable list of
    #// options. See below the supported options.
    #// Parameters :
    #// $p_filelist : An array containing file or directory names, or
    #// a string containing one filename or one directory name, or
    #// a string containing a list of filenames and/or directory
    #// names separated by spaces.
    #// $p_add_dir : A path to add before the real path of the archived file,
    #// in order to have it memorized in the archive.
    #// $p_remove_dir : A path to remove from the real path of the file to archive,
    #// in order to have a shorter path memorized in the archive.
    #// When $p_add_dir and $p_remove_dir are set, $p_remove_dir
    #// is removed first, before $p_add_dir is added.
    #// Options :
    #// PCLZIP_OPT_ADD_PATH :
    #// PCLZIP_OPT_REMOVE_PATH :
    #// PCLZIP_OPT_REMOVE_ALL_PATH :
    #// PCLZIP_OPT_COMMENT :
    #// PCLZIP_CB_PRE_ADD :
    #// PCLZIP_CB_POST_ADD :
    #// Return Values :
    #// 0 on failure,
    #// The list of the added files, with a status of the add action.
    #// (see PclZip::listContent() for list entry format)
    #// --------------------------------------------------------------------------------
    def create(self, p_filelist_=None):
        
        
        v_result_ = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Set default values
        v_options_ = Array()
        v_options_[PCLZIP_OPT_NO_COMPRESSION] = False
        #// ----- Look for variable options arguments
        v_size_ = php_func_num_args()
        #// ----- Look for arguments
        if v_size_ > 1:
            #// ----- Get the arguments
            v_arg_list_ = php_func_get_args()
            #// ----- Remove from the options list the first argument
            php_array_shift(v_arg_list_)
            v_size_ -= 1
            #// ----- Look for first arg
            if is_integer(v_arg_list_[0]) and v_arg_list_[0] > 77000:
                #// ----- Parse the options
                v_result_ = self.privparseoptions(v_arg_list_, v_size_, v_options_, Array({PCLZIP_OPT_REMOVE_PATH: "optional", PCLZIP_OPT_REMOVE_ALL_PATH: "optional", PCLZIP_OPT_ADD_PATH: "optional", PCLZIP_CB_PRE_ADD: "optional", PCLZIP_CB_POST_ADD: "optional", PCLZIP_OPT_NO_COMPRESSION: "optional", PCLZIP_OPT_COMMENT: "optional", PCLZIP_OPT_TEMP_FILE_THRESHOLD: "optional", PCLZIP_OPT_TEMP_FILE_ON: "optional", PCLZIP_OPT_TEMP_FILE_OFF: "optional"}))
                if v_result_ != 1:
                    return 0
                # end if
            else:
                #// ----- Get the first argument
                v_options_[PCLZIP_OPT_ADD_PATH] = v_arg_list_[0]
                #// ----- Look for the optional second argument
                if v_size_ == 2:
                    v_options_[PCLZIP_OPT_REMOVE_PATH] = v_arg_list_[1]
                else:
                    if v_size_ > 2:
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments")
                        return 0
                    # end if
                # end if
            # end if
        # end if
        #// ----- Look for default option values
        self.privoptiondefaultthreshold(v_options_)
        #// ----- Init
        v_string_list_ = Array()
        v_att_list_ = Array()
        v_filedescr_list_ = Array()
        p_result_list_ = Array()
        #// ----- Look if the $p_filelist is really an array
        if php_is_array(p_filelist_):
            #// ----- Look if the first element is also an array
            #// This will mean that this is a file description entry
            if (php_isset(lambda : p_filelist_[0])) and php_is_array(p_filelist_[0]):
                v_att_list_ = p_filelist_
            else:
                v_string_list_ = p_filelist_
            # end if
        else:
            if php_is_string(p_filelist_):
                #// ----- Create a list from the string
                v_string_list_ = php_explode(PCLZIP_SEPARATOR, p_filelist_)
            else:
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_filelist")
                return 0
            # end if
        # end if
        #// ----- Reformat the string list
        if sizeof(v_string_list_) != 0:
            for v_string_ in v_string_list_:
                if v_string_ != "":
                    v_att_list_[-1][PCLZIP_ATT_FILE_NAME] = v_string_
                # end if
            # end for
        # end if
        #// ----- For each file in the list check the attributes
        v_supported_attributes_ = Array({PCLZIP_ATT_FILE_NAME: "mandatory", PCLZIP_ATT_FILE_NEW_SHORT_NAME: "optional", PCLZIP_ATT_FILE_NEW_FULL_NAME: "optional", PCLZIP_ATT_FILE_MTIME: "optional", PCLZIP_ATT_FILE_CONTENT: "optional", PCLZIP_ATT_FILE_COMMENT: "optional"})
        for v_entry_ in v_att_list_:
            v_result_ = self.privfiledescrparseatt(v_entry_, v_filedescr_list_[-1], v_options_, v_supported_attributes_)
            if v_result_ != 1:
                return 0
            # end if
        # end for
        #// ----- Expand the filelist (expand directories)
        v_result_ = self.privfiledescrexpand(v_filedescr_list_, v_options_)
        if v_result_ != 1:
            return 0
        # end if
        #// ----- Call the create fct
        v_result_ = self.privcreate(v_filedescr_list_, p_result_list_, v_options_)
        if v_result_ != 1:
            return 0
        # end if
        #// ----- Return
        return p_result_list_
    # end def create
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function :
    #// add($p_filelist, $p_add_dir="", $p_remove_dir="")
    #// add($p_filelist, $p_option, $p_option_value, ...)
    #// Description :
    #// This method supports two synopsis. The first one is historical.
    #// This methods add the list of files in an existing archive.
    #// If a file with the same name already exists, it is added at the end of the
    #// archive, the first one is still present.
    #// If the archive does not exist, it is created.
    #// Parameters :
    #// $p_filelist : An array containing file or directory names, or
    #// a string containing one filename or one directory name, or
    #// a string containing a list of filenames and/or directory
    #// names separated by spaces.
    #// $p_add_dir : A path to add before the real path of the archived file,
    #// in order to have it memorized in the archive.
    #// $p_remove_dir : A path to remove from the real path of the file to archive,
    #// in order to have a shorter path memorized in the archive.
    #// When $p_add_dir and $p_remove_dir are set, $p_remove_dir
    #// is removed first, before $p_add_dir is added.
    #// Options :
    #// PCLZIP_OPT_ADD_PATH :
    #// PCLZIP_OPT_REMOVE_PATH :
    #// PCLZIP_OPT_REMOVE_ALL_PATH :
    #// PCLZIP_OPT_COMMENT :
    #// PCLZIP_OPT_ADD_COMMENT :
    #// PCLZIP_OPT_PREPEND_COMMENT :
    #// PCLZIP_CB_PRE_ADD :
    #// PCLZIP_CB_POST_ADD :
    #// Return Values :
    #// 0 on failure,
    #// The list of the added files, with a status of the add action.
    #// (see PclZip::listContent() for list entry format)
    #// --------------------------------------------------------------------------------
    def add(self, p_filelist_=None):
        
        
        v_result_ = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Set default values
        v_options_ = Array()
        v_options_[PCLZIP_OPT_NO_COMPRESSION] = False
        #// ----- Look for variable options arguments
        v_size_ = php_func_num_args()
        #// ----- Look for arguments
        if v_size_ > 1:
            #// ----- Get the arguments
            v_arg_list_ = php_func_get_args()
            #// ----- Remove form the options list the first argument
            php_array_shift(v_arg_list_)
            v_size_ -= 1
            #// ----- Look for first arg
            if is_integer(v_arg_list_[0]) and v_arg_list_[0] > 77000:
                #// ----- Parse the options
                v_result_ = self.privparseoptions(v_arg_list_, v_size_, v_options_, Array({PCLZIP_OPT_REMOVE_PATH: "optional", PCLZIP_OPT_REMOVE_ALL_PATH: "optional", PCLZIP_OPT_ADD_PATH: "optional", PCLZIP_CB_PRE_ADD: "optional", PCLZIP_CB_POST_ADD: "optional", PCLZIP_OPT_NO_COMPRESSION: "optional", PCLZIP_OPT_COMMENT: "optional", PCLZIP_OPT_ADD_COMMENT: "optional", PCLZIP_OPT_PREPEND_COMMENT: "optional", PCLZIP_OPT_TEMP_FILE_THRESHOLD: "optional", PCLZIP_OPT_TEMP_FILE_ON: "optional", PCLZIP_OPT_TEMP_FILE_OFF: "optional"}))
                if v_result_ != 1:
                    return 0
                # end if
            else:
                #// ----- Get the first argument
                v_options_[PCLZIP_OPT_ADD_PATH] = v_add_path_
                #// ----- Look for the optional second argument
                if v_size_ == 2:
                    v_options_[PCLZIP_OPT_REMOVE_PATH] = v_arg_list_[1]
                else:
                    if v_size_ > 2:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments")
                        #// ----- Return
                        return 0
                    # end if
                # end if
            # end if
        # end if
        #// ----- Look for default option values
        self.privoptiondefaultthreshold(v_options_)
        #// ----- Init
        v_string_list_ = Array()
        v_att_list_ = Array()
        v_filedescr_list_ = Array()
        p_result_list_ = Array()
        #// ----- Look if the $p_filelist is really an array
        if php_is_array(p_filelist_):
            #// ----- Look if the first element is also an array
            #// This will mean that this is a file description entry
            if (php_isset(lambda : p_filelist_[0])) and php_is_array(p_filelist_[0]):
                v_att_list_ = p_filelist_
            else:
                v_string_list_ = p_filelist_
            # end if
        else:
            if php_is_string(p_filelist_):
                #// ----- Create a list from the string
                v_string_list_ = php_explode(PCLZIP_SEPARATOR, p_filelist_)
            else:
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type '" + gettype(p_filelist_) + "' for p_filelist")
                return 0
            # end if
        # end if
        #// ----- Reformat the string list
        if sizeof(v_string_list_) != 0:
            for v_string_ in v_string_list_:
                v_att_list_[-1][PCLZIP_ATT_FILE_NAME] = v_string_
            # end for
        # end if
        #// ----- For each file in the list check the attributes
        v_supported_attributes_ = Array({PCLZIP_ATT_FILE_NAME: "mandatory", PCLZIP_ATT_FILE_NEW_SHORT_NAME: "optional", PCLZIP_ATT_FILE_NEW_FULL_NAME: "optional", PCLZIP_ATT_FILE_MTIME: "optional", PCLZIP_ATT_FILE_CONTENT: "optional", PCLZIP_ATT_FILE_COMMENT: "optional"})
        for v_entry_ in v_att_list_:
            v_result_ = self.privfiledescrparseatt(v_entry_, v_filedescr_list_[-1], v_options_, v_supported_attributes_)
            if v_result_ != 1:
                return 0
            # end if
        # end for
        #// ----- Expand the filelist (expand directories)
        v_result_ = self.privfiledescrexpand(v_filedescr_list_, v_options_)
        if v_result_ != 1:
            return 0
        # end if
        #// ----- Call the create fct
        v_result_ = self.privadd(v_filedescr_list_, p_result_list_, v_options_)
        if v_result_ != 1:
            return 0
        # end if
        #// ----- Return
        return p_result_list_
    # end def add
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : listContent()
    #// Description :
    #// This public method, gives the list of the files and directories, with their
    #// properties.
    #// The properties of each entries in the list are (used also in other functions) :
    #// filename : Name of the file. For a create or add action it is the filename
    #// given by the user. For an extract function it is the filename
    #// of the extracted file.
    #// stored_filename : Name of the file / directory stored in the archive.
    #// size : Size of the stored file.
    #// compressed_size : Size of the file's data compressed in the archive
    #// (without the headers overhead)
    #// mtime : Last known modification date of the file (UNIX timestamp)
    #// comment : Comment associated with the file
    #// folder : true | false
    #// index : index of the file in the archive
    #// status : status of the action (depending of the action) :
    #// Values are :
    #// ok : OK !
    #// filtered : the file / dir is not extracted (filtered by user)
    #// already_a_directory : the file can not be extracted because a
    #// directory with the same name already exists
    #// write_protected : the file can not be extracted because a file
    #// with the same name already exists and is
    #// write protected
    #// newer_exist : the file was not extracted because a newer file exists
    #// path_creation_fail : the file is not extracted because the folder
    #// does not exist and can not be created
    #// write_error : the file was not extracted because there was a
    #// error while writing the file
    #// read_error : the file was not extracted because there was a error
    #// while reading the file
    #// invalid_header : the file was not extracted because of an archive
    #// format error (bad file header)
    #// Note that each time a method can continue operating when there
    #// is an action error on a file, the error is only logged in the file status.
    #// Return Values :
    #// 0 on an unrecoverable failure,
    #// The list of the files in the archive.
    #// --------------------------------------------------------------------------------
    def listcontent(self):
        
        
        v_result_ = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Check archive
        if (not self.privcheckformat()):
            return 0
        # end if
        #// ----- Call the extracting fct
        p_list_ = Array()
        v_result_ = self.privlist(p_list_)
        if v_result_ != 1:
            p_list_ = None
            return 0
        # end if
        #// ----- Return
        return p_list_
    # end def listcontent
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function :
    #// extract($p_path="./", $p_remove_path="")
    #// extract([$p_option, $p_option_value, ...])
    #// Description :
    #// This method supports two synopsis. The first one is historical.
    #// This method extract all the files / directories from the archive to the
    #// folder indicated in $p_path.
    #// If you want to ignore the 'root' part of path of the memorized files
    #// you can indicate this in the optional $p_remove_path parameter.
    #// By default, if a newer file with the same name already exists, the
    #// file is not extracted.
    #// 
    #// If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH options
    #// are used, the path indicated in PCLZIP_OPT_ADD_PATH is append
    #// at the end of the path value of PCLZIP_OPT_PATH.
    #// Parameters :
    #// $p_path : Path where the files and directories are to be extracted
    #// $p_remove_path : First part ('root' part) of the memorized path
    #// (if any similar) to remove while extracting.
    #// Options :
    #// PCLZIP_OPT_PATH :
    #// PCLZIP_OPT_ADD_PATH :
    #// PCLZIP_OPT_REMOVE_PATH :
    #// PCLZIP_OPT_REMOVE_ALL_PATH :
    #// PCLZIP_CB_PRE_EXTRACT :
    #// PCLZIP_CB_POST_EXTRACT :
    #// Return Values :
    #// 0 or a negative value on failure,
    #// The list of the extracted files, with a status of the action.
    #// (see PclZip::listContent() for list entry format)
    #// --------------------------------------------------------------------------------
    def extract(self):
        
        
        v_result_ = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Check archive
        if (not self.privcheckformat()):
            return 0
        # end if
        #// ----- Set default values
        v_options_ = Array()
        #// $v_path = "./";
        v_path_ = ""
        v_remove_path_ = ""
        v_remove_all_path_ = False
        #// ----- Look for variable options arguments
        v_size_ = php_func_num_args()
        #// ----- Default values for option
        v_options_[PCLZIP_OPT_EXTRACT_AS_STRING] = False
        #// ----- Look for arguments
        if v_size_ > 0:
            #// ----- Get the arguments
            v_arg_list_ = php_func_get_args()
            #// ----- Look for first arg
            if is_integer(v_arg_list_[0]) and v_arg_list_[0] > 77000:
                #// ----- Parse the options
                v_result_ = self.privparseoptions(v_arg_list_, v_size_, v_options_, Array({PCLZIP_OPT_PATH: "optional", PCLZIP_OPT_REMOVE_PATH: "optional", PCLZIP_OPT_REMOVE_ALL_PATH: "optional", PCLZIP_OPT_ADD_PATH: "optional", PCLZIP_CB_PRE_EXTRACT: "optional", PCLZIP_CB_POST_EXTRACT: "optional", PCLZIP_OPT_SET_CHMOD: "optional", PCLZIP_OPT_BY_NAME: "optional", PCLZIP_OPT_BY_EREG: "optional", PCLZIP_OPT_BY_PREG: "optional", PCLZIP_OPT_BY_INDEX: "optional", PCLZIP_OPT_EXTRACT_AS_STRING: "optional", PCLZIP_OPT_EXTRACT_IN_OUTPUT: "optional", PCLZIP_OPT_REPLACE_NEWER: "optional", PCLZIP_OPT_STOP_ON_ERROR: "optional", PCLZIP_OPT_EXTRACT_DIR_RESTRICTION: "optional", PCLZIP_OPT_TEMP_FILE_THRESHOLD: "optional", PCLZIP_OPT_TEMP_FILE_ON: "optional", PCLZIP_OPT_TEMP_FILE_OFF: "optional"}))
                if v_result_ != 1:
                    return 0
                # end if
                #// ----- Set the arguments
                if (php_isset(lambda : v_options_[PCLZIP_OPT_PATH])):
                    v_path_ = v_options_[PCLZIP_OPT_PATH]
                # end if
                if (php_isset(lambda : v_options_[PCLZIP_OPT_REMOVE_PATH])):
                    v_remove_path_ = v_options_[PCLZIP_OPT_REMOVE_PATH]
                # end if
                if (php_isset(lambda : v_options_[PCLZIP_OPT_REMOVE_ALL_PATH])):
                    v_remove_all_path_ = v_options_[PCLZIP_OPT_REMOVE_ALL_PATH]
                # end if
                if (php_isset(lambda : v_options_[PCLZIP_OPT_ADD_PATH])):
                    #// ----- Check for '/' in last path char
                    if php_strlen(v_path_) > 0 and php_substr(v_path_, -1) != "/":
                        v_path_ += "/"
                    # end if
                    v_path_ += v_options_[PCLZIP_OPT_ADD_PATH]
                # end if
            else:
                #// ----- Get the first argument
                v_path_ = v_arg_list_[0]
                #// ----- Look for the optional second argument
                if v_size_ == 2:
                    v_remove_path_ = v_arg_list_[1]
                else:
                    if v_size_ > 2:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments")
                        #// ----- Return
                        return 0
                    # end if
                # end if
            # end if
        # end if
        #// ----- Look for default option values
        self.privoptiondefaultthreshold(v_options_)
        #// ----- Trace
        #// ----- Call the extracting fct
        p_list_ = Array()
        v_result_ = self.privextractbyrule(p_list_, v_path_, v_remove_path_, v_remove_all_path_, v_options_)
        if v_result_ < 1:
            p_list_ = None
            return 0
        # end if
        #// ----- Return
        return p_list_
    # end def extract
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function :
    #// extractByIndex($p_index, $p_path="./", $p_remove_path="")
    #// extractByIndex($p_index, [$p_option, $p_option_value, ...])
    #// Description :
    #// This method supports two synopsis. The first one is historical.
    #// This method is doing a partial extract of the archive.
    #// The extracted files or folders are identified by their index in the
    #// archive (from 0 to n).
    #// Note that if the index identify a folder, only the folder entry is
    #// extracted, not all the files included in the archive.
    #// Parameters :
    #// $p_index : A single index (integer) or a string of indexes of files to
    #// extract. The form of the string is "0,4-6,8-12" with only numbers
    #// and '-' for range or ',' to separate ranges. No spaces or ';'
    #// are allowed.
    #// $p_path : Path where the files and directories are to be extracted
    #// $p_remove_path : First part ('root' part) of the memorized path
    #// (if any similar) to remove while extracting.
    #// Options :
    #// PCLZIP_OPT_PATH :
    #// PCLZIP_OPT_ADD_PATH :
    #// PCLZIP_OPT_REMOVE_PATH :
    #// PCLZIP_OPT_REMOVE_ALL_PATH :
    #// PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and
    #// not as files.
    #// The resulting content is in a new field 'content' in the file
    #// structure.
    #// This option must be used alone (any other options are ignored).
    #// PCLZIP_CB_PRE_EXTRACT :
    #// PCLZIP_CB_POST_EXTRACT :
    #// Return Values :
    #// 0 on failure,
    #// The list of the extracted files, with a status of the action.
    #// (see PclZip::listContent() for list entry format)
    #// --------------------------------------------------------------------------------
    #// function extractByIndex($p_index, options...)
    def extractbyindex(self, p_index_=None):
        
        
        v_result_ = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Check archive
        if (not self.privcheckformat()):
            return 0
        # end if
        #// ----- Set default values
        v_options_ = Array()
        #// $v_path = "./";
        v_path_ = ""
        v_remove_path_ = ""
        v_remove_all_path_ = False
        #// ----- Look for variable options arguments
        v_size_ = php_func_num_args()
        #// ----- Default values for option
        v_options_[PCLZIP_OPT_EXTRACT_AS_STRING] = False
        #// ----- Look for arguments
        if v_size_ > 1:
            #// ----- Get the arguments
            v_arg_list_ = php_func_get_args()
            #// ----- Remove form the options list the first argument
            php_array_shift(v_arg_list_)
            v_size_ -= 1
            #// ----- Look for first arg
            if is_integer(v_arg_list_[0]) and v_arg_list_[0] > 77000:
                #// ----- Parse the options
                v_result_ = self.privparseoptions(v_arg_list_, v_size_, v_options_, Array({PCLZIP_OPT_PATH: "optional", PCLZIP_OPT_REMOVE_PATH: "optional", PCLZIP_OPT_REMOVE_ALL_PATH: "optional", PCLZIP_OPT_EXTRACT_AS_STRING: "optional", PCLZIP_OPT_ADD_PATH: "optional", PCLZIP_CB_PRE_EXTRACT: "optional", PCLZIP_CB_POST_EXTRACT: "optional", PCLZIP_OPT_SET_CHMOD: "optional", PCLZIP_OPT_REPLACE_NEWER: "optional", PCLZIP_OPT_STOP_ON_ERROR: "optional", PCLZIP_OPT_EXTRACT_DIR_RESTRICTION: "optional", PCLZIP_OPT_TEMP_FILE_THRESHOLD: "optional", PCLZIP_OPT_TEMP_FILE_ON: "optional", PCLZIP_OPT_TEMP_FILE_OFF: "optional"}))
                if v_result_ != 1:
                    return 0
                # end if
                #// ----- Set the arguments
                if (php_isset(lambda : v_options_[PCLZIP_OPT_PATH])):
                    v_path_ = v_options_[PCLZIP_OPT_PATH]
                # end if
                if (php_isset(lambda : v_options_[PCLZIP_OPT_REMOVE_PATH])):
                    v_remove_path_ = v_options_[PCLZIP_OPT_REMOVE_PATH]
                # end if
                if (php_isset(lambda : v_options_[PCLZIP_OPT_REMOVE_ALL_PATH])):
                    v_remove_all_path_ = v_options_[PCLZIP_OPT_REMOVE_ALL_PATH]
                # end if
                if (php_isset(lambda : v_options_[PCLZIP_OPT_ADD_PATH])):
                    #// ----- Check for '/' in last path char
                    if php_strlen(v_path_) > 0 and php_substr(v_path_, -1) != "/":
                        v_path_ += "/"
                    # end if
                    v_path_ += v_options_[PCLZIP_OPT_ADD_PATH]
                # end if
                if (not (php_isset(lambda : v_options_[PCLZIP_OPT_EXTRACT_AS_STRING]))):
                    v_options_[PCLZIP_OPT_EXTRACT_AS_STRING] = False
                # end if
            else:
                #// ----- Get the first argument
                v_path_ = v_arg_list_[0]
                #// ----- Look for the optional second argument
                if v_size_ == 2:
                    v_remove_path_ = v_arg_list_[1]
                else:
                    if v_size_ > 2:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments")
                        #// ----- Return
                        return 0
                    # end if
                # end if
            # end if
        # end if
        #// ----- Trace
        #// ----- Trick
        #// Here I want to reuse extractByRule(), so I need to parse the $p_index
        #// with privParseOptions()
        v_arg_trick_ = Array(PCLZIP_OPT_BY_INDEX, p_index_)
        v_options_trick_ = Array()
        v_result_ = self.privparseoptions(v_arg_trick_, sizeof(v_arg_trick_), v_options_trick_, Array({PCLZIP_OPT_BY_INDEX: "optional"}))
        if v_result_ != 1:
            return 0
        # end if
        v_options_[PCLZIP_OPT_BY_INDEX] = v_options_trick_[PCLZIP_OPT_BY_INDEX]
        #// ----- Look for default option values
        self.privoptiondefaultthreshold(v_options_)
        #// ----- Call the extracting fct
        v_result_ = self.privextractbyrule(p_list_, v_path_, v_remove_path_, v_remove_all_path_, v_options_)
        if v_result_ < 1:
            return 0
        # end if
        #// ----- Return
        return p_list_
    # end def extractbyindex
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function :
    #// delete([$p_option, $p_option_value, ...])
    #// Description :
    #// This method removes files from the archive.
    #// If no parameters are given, then all the archive is emptied.
    #// Parameters :
    #// None or optional arguments.
    #// Options :
    #// PCLZIP_OPT_BY_INDEX :
    #// PCLZIP_OPT_BY_NAME :
    #// PCLZIP_OPT_BY_EREG :
    #// PCLZIP_OPT_BY_PREG :
    #// Return Values :
    #// 0 on failure,
    #// The list of the files which are still present in the archive.
    #// (see PclZip::listContent() for list entry format)
    #// --------------------------------------------------------------------------------
    def delete(self):
        
        
        v_result_ = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Check archive
        if (not self.privcheckformat()):
            return 0
        # end if
        #// ----- Set default values
        v_options_ = Array()
        #// ----- Look for variable options arguments
        v_size_ = php_func_num_args()
        #// ----- Look for arguments
        if v_size_ > 0:
            #// ----- Get the arguments
            v_arg_list_ = php_func_get_args()
            #// ----- Parse the options
            v_result_ = self.privparseoptions(v_arg_list_, v_size_, v_options_, Array({PCLZIP_OPT_BY_NAME: "optional", PCLZIP_OPT_BY_EREG: "optional", PCLZIP_OPT_BY_PREG: "optional", PCLZIP_OPT_BY_INDEX: "optional"}))
            if v_result_ != 1:
                return 0
            # end if
        # end if
        #// ----- Magic quotes trick
        self.privdisablemagicquotes()
        #// ----- Call the delete fct
        v_list_ = Array()
        v_result_ = self.privdeletebyrule(v_list_, v_options_)
        if v_result_ != 1:
            self.privswapbackmagicquotes()
            v_list_ = None
            return 0
        # end if
        #// ----- Magic quotes trick
        self.privswapbackmagicquotes()
        #// ----- Return
        return v_list_
    # end def delete
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : deleteByIndex()
    #// Description :
    #// Deprecated
    #// delete(PCLZIP_OPT_BY_INDEX, $p_index) should be preferred.
    #// --------------------------------------------------------------------------------
    def deletebyindex(self, p_index_=None):
        
        
        p_list_ = self.delete(PCLZIP_OPT_BY_INDEX, p_index_)
        #// ----- Return
        return p_list_
    # end def deletebyindex
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : properties()
    #// Description :
    #// This method gives the properties of the archive.
    #// The properties are :
    #// nb : Number of files in the archive
    #// comment : Comment associated with the archive file
    #// status : not_exist, ok
    #// Parameters :
    #// None
    #// Return Values :
    #// 0 on failure,
    #// An array with the archive properties.
    #// --------------------------------------------------------------------------------
    def properties(self):
        
        
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Magic quotes trick
        self.privdisablemagicquotes()
        #// ----- Check archive
        if (not self.privcheckformat()):
            self.privswapbackmagicquotes()
            return 0
        # end if
        #// ----- Default properties
        v_prop_ = Array()
        v_prop_["comment"] = ""
        v_prop_["nb"] = 0
        v_prop_["status"] = "not_exist"
        #// ----- Look if file exists
        if php_no_error(lambda: php_is_file(self.zipname)):
            #// ----- Open the zip file
            self.zip_fd = php_no_error(lambda: fopen(self.zipname, "rb"))
            if self.zip_fd == 0:
                self.privswapbackmagicquotes()
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open archive '" + self.zipname + "' in binary read mode")
                #// ----- Return
                return 0
            # end if
            #// ----- Read the central directory information
            v_central_dir_ = Array()
            v_result_ = self.privreadendcentraldir(v_central_dir_)
            if v_result_ != 1:
                self.privswapbackmagicquotes()
                return 0
            # end if
            #// ----- Close the zip file
            self.privclosefd()
            #// ----- Set the user attributes
            v_prop_["comment"] = v_central_dir_["comment"]
            v_prop_["nb"] = v_central_dir_["entries"]
            v_prop_["status"] = "ok"
        # end if
        #// ----- Magic quotes trick
        self.privswapbackmagicquotes()
        #// ----- Return
        return v_prop_
    # end def properties
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : duplicate()
    #// Description :
    #// This method creates an archive by copying the content of an other one. If
    #// the archive already exist, it is replaced by the new one without any warning.
    #// Parameters :
    #// $p_archive : The filename of a valid archive, or
    #// a valid PclZip object.
    #// Return Values :
    #// 1 on success.
    #// 0 or a negative value on error (error code).
    #// --------------------------------------------------------------------------------
    def duplicate(self, p_archive_=None):
        
        
        v_result_ = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Look if the $p_archive is a PclZip object
        if php_is_object(p_archive_) and get_class(p_archive_) == "pclzip":
            #// ----- Duplicate the archive
            v_result_ = self.privduplicate(p_archive_.zipname)
        else:
            if php_is_string(p_archive_):
                #// ----- Check that $p_archive is a valid zip file
                #// TBC : Should also check the archive format
                if (not php_is_file(p_archive_)):
                    #// ----- Error log
                    PclZip.priverrorlog(PCLZIP_ERR_MISSING_FILE, "No file with filename '" + p_archive_ + "'")
                    v_result_ = PCLZIP_ERR_MISSING_FILE
                else:
                    #// ----- Duplicate the archive
                    v_result_ = self.privduplicate(p_archive_)
                # end if
            else:
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add")
                v_result_ = PCLZIP_ERR_INVALID_PARAMETER
            # end if
        # end if
        #// ----- Return
        return v_result_
    # end def duplicate
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : merge()
    #// Description :
    #// This method merge the $p_archive_to_add archive at the end of the current
    #// one ($this).
    #// If the archive ($this) does not exist, the merge becomes a duplicate.
    #// If the $p_archive_to_add archive does not exist, the merge is a success.
    #// Parameters :
    #// $p_archive_to_add : It can be directly the filename of a valid zip archive,
    #// or a PclZip object archive.
    #// Return Values :
    #// 1 on success,
    #// 0 or negative values on error (see below).
    #// --------------------------------------------------------------------------------
    def merge(self, p_archive_to_add_=None):
        
        
        v_result_ = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Check archive
        if (not self.privcheckformat()):
            return 0
        # end if
        #// ----- Look if the $p_archive_to_add is a PclZip object
        if php_is_object(p_archive_to_add_) and get_class(p_archive_to_add_) == "pclzip":
            #// ----- Merge the archive
            v_result_ = self.privmerge(p_archive_to_add_)
        else:
            if php_is_string(p_archive_to_add_):
                #// ----- Create a temporary archive
                v_object_archive_ = php_new_class("PclZip", lambda : PclZip(p_archive_to_add_))
                #// ----- Merge the archive
                v_result_ = self.privmerge(v_object_archive_)
            else:
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add")
                v_result_ = PCLZIP_ERR_INVALID_PARAMETER
            # end if
        # end if
        #// ----- Return
        return v_result_
    # end def merge
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : errorCode()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def errorcode(self):
        
        
        if PCLZIP_ERROR_EXTERNAL == 1:
            return PclErrorCode()
        else:
            return self.error_code
        # end if
    # end def errorcode
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : errorName()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def errorname(self, p_with_code_=None):
        if p_with_code_ is None:
            p_with_code_ = False
        # end if
        
        v_name_ = Array({PCLZIP_ERR_NO_ERROR: "PCLZIP_ERR_NO_ERROR", PCLZIP_ERR_WRITE_OPEN_FAIL: "PCLZIP_ERR_WRITE_OPEN_FAIL", PCLZIP_ERR_READ_OPEN_FAIL: "PCLZIP_ERR_READ_OPEN_FAIL", PCLZIP_ERR_INVALID_PARAMETER: "PCLZIP_ERR_INVALID_PARAMETER", PCLZIP_ERR_MISSING_FILE: "PCLZIP_ERR_MISSING_FILE", PCLZIP_ERR_FILENAME_TOO_LONG: "PCLZIP_ERR_FILENAME_TOO_LONG", PCLZIP_ERR_INVALID_ZIP: "PCLZIP_ERR_INVALID_ZIP", PCLZIP_ERR_BAD_EXTRACTED_FILE: "PCLZIP_ERR_BAD_EXTRACTED_FILE", PCLZIP_ERR_DIR_CREATE_FAIL: "PCLZIP_ERR_DIR_CREATE_FAIL", PCLZIP_ERR_BAD_EXTENSION: "PCLZIP_ERR_BAD_EXTENSION", PCLZIP_ERR_BAD_FORMAT: "PCLZIP_ERR_BAD_FORMAT", PCLZIP_ERR_DELETE_FILE_FAIL: "PCLZIP_ERR_DELETE_FILE_FAIL", PCLZIP_ERR_RENAME_FILE_FAIL: "PCLZIP_ERR_RENAME_FILE_FAIL", PCLZIP_ERR_BAD_CHECKSUM: "PCLZIP_ERR_BAD_CHECKSUM", PCLZIP_ERR_INVALID_ARCHIVE_ZIP: "PCLZIP_ERR_INVALID_ARCHIVE_ZIP", PCLZIP_ERR_MISSING_OPTION_VALUE: "PCLZIP_ERR_MISSING_OPTION_VALUE", PCLZIP_ERR_INVALID_OPTION_VALUE: "PCLZIP_ERR_INVALID_OPTION_VALUE", PCLZIP_ERR_UNSUPPORTED_COMPRESSION: "PCLZIP_ERR_UNSUPPORTED_COMPRESSION", PCLZIP_ERR_UNSUPPORTED_ENCRYPTION: "PCLZIP_ERR_UNSUPPORTED_ENCRYPTION", PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE: "PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE", PCLZIP_ERR_DIRECTORY_RESTRICTION: "PCLZIP_ERR_DIRECTORY_RESTRICTION"})
        if (php_isset(lambda : v_name_[self.error_code])):
            v_value_ = v_name_[self.error_code]
        else:
            v_value_ = "NoName"
        # end if
        if p_with_code_:
            return v_value_ + " (" + self.error_code + ")"
        else:
            return v_value_
        # end if
    # end def errorname
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : errorInfo()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def errorinfo(self, p_full_=None):
        if p_full_ is None:
            p_full_ = False
        # end if
        
        if PCLZIP_ERROR_EXTERNAL == 1:
            return PclErrorString()
        else:
            if p_full_:
                return self.errorname(True) + " : " + self.error_string
            else:
                return self.error_string + " [code " + self.error_code + "]"
            # end if
        # end if
    # end def errorinfo
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS
    #// 
    #// THESES FUNCTIONS MUST NOT BE USED DIRECTLY
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privCheckFormat()
    #// Description :
    #// This method check that the archive exists and is a valid zip archive.
    #// Several level of check exists. (futur)
    #// Parameters :
    #// $p_level : Level of check. Default 0.
    #// 0 : Check the first bytes (magic codes) (default value))
    #// 1 : 0 + Check the central directory (futur)
    #// 2 : 1 + Check each file header (futur)
    #// Return Values :
    #// true on success,
    #// false on error, the error code is set.
    #// --------------------------------------------------------------------------------
    def privcheckformat(self, p_level_=0):
        
        
        v_result_ = True
        #// ----- Reset the file system cache
        clearstatcache()
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Look if the file exits
        if (not php_is_file(self.zipname)):
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_MISSING_FILE, "Missing archive file '" + self.zipname + "'")
            return False
        # end if
        #// ----- Check that the file is readable
        if (not php_is_readable(self.zipname)):
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to read archive '" + self.zipname + "'")
            return False
        # end if
        #// ----- Check the magic code
        #// TBC
        #// ----- Check the central header
        #// TBC
        #// ----- Check each file header
        #// TBC
        #// ----- Return
        return v_result_
    # end def privcheckformat
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privParseOptions()
    #// Description :
    #// This internal methods reads the variable list of arguments ($p_options_list,
    #// $p_size) and generate an array with the options and values ($v_result_list).
    #// $v_requested_options contains the options that can be present and those that
    #// must be present.
    #// $v_requested_options is an array, with the option value as key, and 'optional',
    #// or 'mandatory' as value.
    #// Parameters :
    #// See above.
    #// Return Values :
    #// 1 on success.
    #// 0 on failure.
    #// --------------------------------------------------------------------------------
    def privparseoptions(self, p_options_list_=None, p_size_=None, v_result_list_=None, v_requested_options_=None):
        if v_requested_options_ is None:
            v_requested_options_ = False
        # end if
        
        v_result_ = 1
        #// ----- Read the options
        i_ = 0
        while True:
            
            if not (i_ < p_size_):
                break
            # end if
            #// ----- Check if the option is supported
            if (not (php_isset(lambda : v_requested_options_[p_options_list_[i_]]))):
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid optional parameter '" + p_options_list_[i_] + "' for this method")
                #// ----- Return
                return PclZip.errorcode()
            # end if
            #// ----- Look for next option
            for case in Switch(p_options_list_[i_]):
                if case(PCLZIP_OPT_PATH):
                    pass
                # end if
                if case(PCLZIP_OPT_REMOVE_PATH):
                    pass
                # end if
                if case(PCLZIP_OPT_ADD_PATH):
                    #// ----- Check the number of parameters
                    if i_ + 1 >= p_size_:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    v_result_list_[p_options_list_[i_]] = PclZipUtilTranslateWinPath(p_options_list_[i_ + 1], False)
                    i_ += 1
                    break
                # end if
                if case(PCLZIP_OPT_TEMP_FILE_THRESHOLD):
                    #// ----- Check the number of parameters
                    if i_ + 1 >= p_size_:
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        return PclZip.errorcode()
                    # end if
                    #// ----- Check for incompatible options
                    if (php_isset(lambda : v_result_list_[PCLZIP_OPT_TEMP_FILE_OFF])):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Option '" + PclZipUtilOptionText(p_options_list_[i_]) + "' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'")
                        return PclZip.errorcode()
                    # end if
                    #// ----- Check the value
                    v_value_ = p_options_list_[i_ + 1]
                    if (not is_integer(v_value_)) or v_value_ < 0:
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Integer expected for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value (and convert it in bytes)
                    v_result_list_[p_options_list_[i_]] = v_value_ * 1048576
                    i_ += 1
                    break
                # end if
                if case(PCLZIP_OPT_TEMP_FILE_ON):
                    #// ----- Check for incompatible options
                    if (php_isset(lambda : v_result_list_[PCLZIP_OPT_TEMP_FILE_OFF])):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Option '" + PclZipUtilOptionText(p_options_list_[i_]) + "' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'")
                        return PclZip.errorcode()
                    # end if
                    v_result_list_[p_options_list_[i_]] = True
                    break
                # end if
                if case(PCLZIP_OPT_TEMP_FILE_OFF):
                    #// ----- Check for incompatible options
                    if (php_isset(lambda : v_result_list_[PCLZIP_OPT_TEMP_FILE_ON])):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Option '" + PclZipUtilOptionText(p_options_list_[i_]) + "' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'")
                        return PclZip.errorcode()
                    # end if
                    #// ----- Check for incompatible options
                    if (php_isset(lambda : v_result_list_[PCLZIP_OPT_TEMP_FILE_THRESHOLD])):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Option '" + PclZipUtilOptionText(p_options_list_[i_]) + "' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'")
                        return PclZip.errorcode()
                    # end if
                    v_result_list_[p_options_list_[i_]] = True
                    break
                # end if
                if case(PCLZIP_OPT_EXTRACT_DIR_RESTRICTION):
                    #// ----- Check the number of parameters
                    if i_ + 1 >= p_size_:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    if php_is_string(p_options_list_[i_ + 1]) and p_options_list_[i_ + 1] != "":
                        v_result_list_[p_options_list_[i_]] = PclZipUtilTranslateWinPath(p_options_list_[i_ + 1], False)
                        i_ += 1
                    # end if
                    break
                # end if
                if case(PCLZIP_OPT_BY_NAME):
                    #// ----- Check the number of parameters
                    if i_ + 1 >= p_size_:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    if php_is_string(p_options_list_[i_ + 1]):
                        v_result_list_[p_options_list_[i_]][0] = p_options_list_[i_ + 1]
                    else:
                        if php_is_array(p_options_list_[i_ + 1]):
                            v_result_list_[p_options_list_[i_]] = p_options_list_[i_ + 1]
                        else:
                            #// ----- Error log
                            PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                            #// ----- Return
                            return PclZip.errorcode()
                        # end if
                    # end if
                    i_ += 1
                    break
                # end if
                if case(PCLZIP_OPT_BY_EREG):
                    #// ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG
                    #// to PCLZIP_OPT_BY_PREG
                    p_options_list_[i_] = PCLZIP_OPT_BY_PREG
                # end if
                if case(PCLZIP_OPT_BY_PREG):
                    #// case PCLZIP_OPT_CRYPT :
                    #// ----- Check the number of parameters
                    if i_ + 1 >= p_size_:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    if php_is_string(p_options_list_[i_ + 1]):
                        v_result_list_[p_options_list_[i_]] = p_options_list_[i_ + 1]
                    else:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    i_ += 1
                    break
                # end if
                if case(PCLZIP_OPT_COMMENT):
                    pass
                # end if
                if case(PCLZIP_OPT_ADD_COMMENT):
                    pass
                # end if
                if case(PCLZIP_OPT_PREPEND_COMMENT):
                    #// ----- Check the number of parameters
                    if i_ + 1 >= p_size_:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    if php_is_string(p_options_list_[i_ + 1]):
                        v_result_list_[p_options_list_[i_]] = p_options_list_[i_ + 1]
                    else:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    i_ += 1
                    break
                # end if
                if case(PCLZIP_OPT_BY_INDEX):
                    #// ----- Check the number of parameters
                    if i_ + 1 >= p_size_:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    v_work_list_ = Array()
                    if php_is_string(p_options_list_[i_ + 1]):
                        #// ----- Remove spaces
                        p_options_list_[i_ + 1] = php_strtr(p_options_list_[i_ + 1], " ", "")
                        #// ----- Parse items
                        v_work_list_ = php_explode(",", p_options_list_[i_ + 1])
                    else:
                        if is_integer(p_options_list_[i_ + 1]):
                            v_work_list_[0] = p_options_list_[i_ + 1] + "-" + p_options_list_[i_ + 1]
                        else:
                            if php_is_array(p_options_list_[i_ + 1]):
                                v_work_list_ = p_options_list_[i_ + 1]
                            else:
                                #// ----- Error log
                                PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Value must be integer, string or array for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                                #// ----- Return
                                return PclZip.errorcode()
                            # end if
                        # end if
                    # end if
                    #// ----- Reduce the index list
                    #// each index item in the list must be a couple with a start and
                    #// an end value : [0,3], [5-5], [8-10], ...
                    #// ----- Check the format of each item
                    v_sort_flag_ = False
                    v_sort_value_ = 0
                    j_ = 0
                    while j_ < sizeof(v_work_list_):
                        
                        #// ----- Explode the item
                        v_item_list_ = php_explode("-", v_work_list_[j_])
                        v_size_item_list_ = sizeof(v_item_list_)
                        #// ----- TBC : Here we might check that each item is a
                        #// real integer ...
                        #// ----- Look for single value
                        if v_size_item_list_ == 1:
                            #// ----- Set the option value
                            v_result_list_[p_options_list_[i_]][j_]["start"] = v_item_list_[0]
                            v_result_list_[p_options_list_[i_]][j_]["end"] = v_item_list_[0]
                        elif v_size_item_list_ == 2:
                            #// ----- Set the option value
                            v_result_list_[p_options_list_[i_]][j_]["start"] = v_item_list_[0]
                            v_result_list_[p_options_list_[i_]][j_]["end"] = v_item_list_[1]
                        else:
                            #// ----- Error log
                            PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Too many values in index range for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                            #// ----- Return
                            return PclZip.errorcode()
                        # end if
                        #// ----- Look for list sort
                        if v_result_list_[p_options_list_[i_]][j_]["start"] < v_sort_value_:
                            v_sort_flag_ = True
                            #// ----- TBC : An automatic sort should be written ...
                            #// ----- Error log
                            PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Invalid order of index range for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                            #// ----- Return
                            return PclZip.errorcode()
                        # end if
                        v_sort_value_ = v_result_list_[p_options_list_[i_]][j_]["start"]
                        j_ += 1
                    # end while
                    #// ----- Sort the items
                    if v_sort_flag_:
                        pass
                    # end if
                    #// ----- Next option
                    i_ += 1
                    break
                # end if
                if case(PCLZIP_OPT_REMOVE_ALL_PATH):
                    pass
                # end if
                if case(PCLZIP_OPT_EXTRACT_AS_STRING):
                    pass
                # end if
                if case(PCLZIP_OPT_NO_COMPRESSION):
                    pass
                # end if
                if case(PCLZIP_OPT_EXTRACT_IN_OUTPUT):
                    pass
                # end if
                if case(PCLZIP_OPT_REPLACE_NEWER):
                    pass
                # end if
                if case(PCLZIP_OPT_STOP_ON_ERROR):
                    v_result_list_[p_options_list_[i_]] = True
                    break
                # end if
                if case(PCLZIP_OPT_SET_CHMOD):
                    #// ----- Check the number of parameters
                    if i_ + 1 >= p_size_:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    v_result_list_[p_options_list_[i_]] = p_options_list_[i_ + 1]
                    i_ += 1
                    break
                # end if
                if case(PCLZIP_CB_PRE_EXTRACT):
                    pass
                # end if
                if case(PCLZIP_CB_POST_EXTRACT):
                    pass
                # end if
                if case(PCLZIP_CB_PRE_ADD):
                    pass
                # end if
                if case(PCLZIP_CB_POST_ADD):
                    #// for futur use
                    #// case PCLZIP_CB_PRE_DELETE :
                    #// case PCLZIP_CB_POST_DELETE :
                    #// case PCLZIP_CB_PRE_LIST :
                    #// case PCLZIP_CB_POST_LIST :
                    #// 
                    #// ----- Check the number of parameters
                    if i_ + 1 >= p_size_:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    v_function_name_ = p_options_list_[i_ + 1]
                    #// ----- Check that the value is a valid existing function
                    if (not php_function_exists(v_function_name_)):
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Function '" + v_function_name_ + "()' is not an existing function for option '" + PclZipUtilOptionText(p_options_list_[i_]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Set the attribute
                    v_result_list_[p_options_list_[i_]] = v_function_name_
                    i_ += 1
                    break
                # end if
                if case():
                    #// ----- Error log
                    PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Unknown parameter '" + p_options_list_[i_] + "'")
                    #// ----- Return
                    return PclZip.errorcode()
                # end if
            # end for
            #// ----- Next options
            i_ += 1
        # end while
        #// ----- Look for mandatory options
        if v_requested_options_ != False:
            key_ = reset(v_requested_options_)
            while key_:
                key_ = key(v_requested_options_)
                #// ----- Look for mandatory option
                if v_requested_options_[key_] == "mandatory":
                    #// ----- Look if present
                    if (not (php_isset(lambda : v_result_list_[key_]))):
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter " + PclZipUtilOptionText(key_) + "(" + key_ + ")")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                # end if
                key_ = next(v_requested_options_)
            # end while
        # end if
        #// ----- Look for default values
        if (not (php_isset(lambda : v_result_list_[PCLZIP_OPT_TEMP_FILE_THRESHOLD]))):
            pass
        # end if
        #// ----- Return
        return v_result_
    # end def privparseoptions
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privOptionDefaultThreshold()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privoptiondefaultthreshold(self, p_options_=None):
        
        
        v_result_ = 1
        if (php_isset(lambda : p_options_[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) or (php_isset(lambda : p_options_[PCLZIP_OPT_TEMP_FILE_OFF])):
            return v_result_
        # end if
        #// ----- Get 'memory_limit' configuration value
        v_memory_limit_ = php_ini_get("memory_limit")
        v_memory_limit_ = php_trim(v_memory_limit_)
        v_memory_limit_int_ = php_int(v_memory_limit_)
        last_ = php_strtolower(php_substr(v_memory_limit_, -1))
        if last_ == "g":
            #// $v_memory_limit_int = $v_memory_limit_int*1024*1024*1024;
            v_memory_limit_int_ = v_memory_limit_int_ * 1073741824
        # end if
        if last_ == "m":
            #// $v_memory_limit_int = $v_memory_limit_int*1024*1024;
            v_memory_limit_int_ = v_memory_limit_int_ * 1048576
        # end if
        if last_ == "k":
            v_memory_limit_int_ = v_memory_limit_int_ * 1024
        # end if
        p_options_[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor(v_memory_limit_int_ * PCLZIP_TEMPORARY_FILE_RATIO)
        #// ----- Sanity check : No threshold if value lower than 1M
        if p_options_[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576:
            p_options_[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = None
        # end if
        #// ----- Return
        return v_result_
    # end def privoptiondefaultthreshold
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privFileDescrParseAtt()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// 1 on success.
    #// 0 on failure.
    #// --------------------------------------------------------------------------------
    def privfiledescrparseatt(self, p_file_list_=None, p_filedescr_=None, v_options_=None, v_requested_options_=None):
        if v_requested_options_ is None:
            v_requested_options_ = False
        # end if
        
        v_result_ = 1
        #// ----- For each file in the list check the attributes
        for v_key_,v_value_ in p_file_list_:
            #// ----- Check if the option is supported
            if (not (php_isset(lambda : v_requested_options_[v_key_]))):
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file attribute '" + v_key_ + "' for this file")
                #// ----- Return
                return PclZip.errorcode()
            # end if
            #// ----- Look for attribute
            for case in Switch(v_key_):
                if case(PCLZIP_ATT_FILE_NAME):
                    if (not php_is_string(v_value_)):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " + gettype(v_value_) + ". String expected for attribute '" + PclZipUtilOptionText(v_key_) + "'")
                        return PclZip.errorcode()
                    # end if
                    p_filedescr_["filename"] = PclZipUtilPathReduction(v_value_)
                    if p_filedescr_["filename"] == "":
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty filename for attribute '" + PclZipUtilOptionText(v_key_) + "'")
                        return PclZip.errorcode()
                    # end if
                    break
                # end if
                if case(PCLZIP_ATT_FILE_NEW_SHORT_NAME):
                    if (not php_is_string(v_value_)):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " + gettype(v_value_) + ". String expected for attribute '" + PclZipUtilOptionText(v_key_) + "'")
                        return PclZip.errorcode()
                    # end if
                    p_filedescr_["new_short_name"] = PclZipUtilPathReduction(v_value_)
                    if p_filedescr_["new_short_name"] == "":
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty short filename for attribute '" + PclZipUtilOptionText(v_key_) + "'")
                        return PclZip.errorcode()
                    # end if
                    break
                # end if
                if case(PCLZIP_ATT_FILE_NEW_FULL_NAME):
                    if (not php_is_string(v_value_)):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " + gettype(v_value_) + ". String expected for attribute '" + PclZipUtilOptionText(v_key_) + "'")
                        return PclZip.errorcode()
                    # end if
                    p_filedescr_["new_full_name"] = PclZipUtilPathReduction(v_value_)
                    if p_filedescr_["new_full_name"] == "":
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty full filename for attribute '" + PclZipUtilOptionText(v_key_) + "'")
                        return PclZip.errorcode()
                    # end if
                    break
                # end if
                if case(PCLZIP_ATT_FILE_COMMENT):
                    if (not php_is_string(v_value_)):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " + gettype(v_value_) + ". String expected for attribute '" + PclZipUtilOptionText(v_key_) + "'")
                        return PclZip.errorcode()
                    # end if
                    p_filedescr_["comment"] = v_value_
                    break
                # end if
                if case(PCLZIP_ATT_FILE_MTIME):
                    if (not is_integer(v_value_)):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " + gettype(v_value_) + ". Integer expected for attribute '" + PclZipUtilOptionText(v_key_) + "'")
                        return PclZip.errorcode()
                    # end if
                    p_filedescr_["mtime"] = v_value_
                    break
                # end if
                if case(PCLZIP_ATT_FILE_CONTENT):
                    p_filedescr_["content"] = v_value_
                    break
                # end if
                if case():
                    #// ----- Error log
                    PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Unknown parameter '" + v_key_ + "'")
                    #// ----- Return
                    return PclZip.errorcode()
                # end if
            # end for
            #// ----- Look for mandatory options
            if v_requested_options_ != False:
                key_ = reset(v_requested_options_)
                while key_:
                    key_ = key(v_requested_options_)
                    #// ----- Look for mandatory option
                    if v_requested_options_[key_] == "mandatory":
                        #// ----- Look if present
                        if (not (php_isset(lambda : p_file_list_[key_]))):
                            PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter " + PclZipUtilOptionText(key_) + "(" + key_ + ")")
                            return PclZip.errorcode()
                        # end if
                    # end if
                    key_ = next(v_requested_options_)
                # end while
            # end if
            pass
        # end for
        #// ----- Return
        return v_result_
    # end def privfiledescrparseatt
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privFileDescrExpand()
    #// Description :
    #// This method look for each item of the list to see if its a file, a folder
    #// or a string to be added as file. For any other type of files (link, other)
    #// just ignore the item.
    #// Then prepare the information that will be stored for that file.
    #// When its a folder, expand the folder with all the files that are in that
    #// folder (recursively).
    #// Parameters :
    #// Return Values :
    #// 1 on success.
    #// 0 on failure.
    #// --------------------------------------------------------------------------------
    def privfiledescrexpand(self, p_filedescr_list_=None, p_options_=None):
        
        
        v_result_ = 1
        #// ----- Create a result list
        v_result_list_ = Array()
        #// ----- Look each entry
        i_ = 0
        while i_ < sizeof(p_filedescr_list_):
            
            #// ----- Get filedescr
            v_descr_ = p_filedescr_list_[i_]
            #// ----- Reduce the filename
            v_descr_["filename"] = PclZipUtilTranslateWinPath(v_descr_["filename"], False)
            v_descr_["filename"] = PclZipUtilPathReduction(v_descr_["filename"])
            #// ----- Look for real file or folder
            if php_file_exists(v_descr_["filename"]):
                if php_no_error(lambda: php_is_file(v_descr_["filename"])):
                    v_descr_["type"] = "file"
                else:
                    if php_no_error(lambda: php_is_dir(v_descr_["filename"])):
                        v_descr_["type"] = "folder"
                    else:
                        if php_no_error(lambda: php_is_link(v_descr_["filename"])):
                            continue
                        else:
                            continue
                        # end if
                    # end if
                # end if
            else:
                if (php_isset(lambda : v_descr_["content"])):
                    v_descr_["type"] = "virtual_file"
                else:
                    #// ----- Error log
                    PclZip.priverrorlog(PCLZIP_ERR_MISSING_FILE, "File '" + v_descr_["filename"] + "' does not exist")
                    #// ----- Return
                    return PclZip.errorcode()
                # end if
            # end if
            #// ----- Calculate the stored filename
            self.privcalculatestoredfilename(v_descr_, p_options_)
            #// ----- Add the descriptor in result list
            v_result_list_[sizeof(v_result_list_)] = v_descr_
            #// ----- Look for folder
            if v_descr_["type"] == "folder":
                #// ----- List of items in folder
                v_dirlist_descr_ = Array()
                v_dirlist_nb_ = 0
                v_folder_handler_ = php_no_error(lambda: php_opendir(v_descr_["filename"]))
                if v_folder_handler_:
                    while True:
                        v_item_handler_ = php_no_error(lambda: php_readdir(v_folder_handler_))
                        if not (v_item_handler_ != False):
                            break
                        # end if
                        #// ----- Skip '.' and '..'
                        if v_item_handler_ == "." or v_item_handler_ == "..":
                            continue
                        # end if
                        #// ----- Compose the full filename
                        v_dirlist_descr_[v_dirlist_nb_]["filename"] = v_descr_["filename"] + "/" + v_item_handler_
                        #// ----- Look for different stored filename
                        #// Because the name of the folder was changed, the name of the
                        #// files/sub-folders also change
                        if v_descr_["stored_filename"] != v_descr_["filename"] and (not (php_isset(lambda : p_options_[PCLZIP_OPT_REMOVE_ALL_PATH]))):
                            if v_descr_["stored_filename"] != "":
                                v_dirlist_descr_[v_dirlist_nb_]["new_full_name"] = v_descr_["stored_filename"] + "/" + v_item_handler_
                            else:
                                v_dirlist_descr_[v_dirlist_nb_]["new_full_name"] = v_item_handler_
                            # end if
                        # end if
                        v_dirlist_nb_ += 1
                    # end while
                    php_no_error(lambda: php_closedir(v_folder_handler_))
                else:
                    pass
                # end if
                #// ----- Expand each element of the list
                if v_dirlist_nb_ != 0:
                    #// ----- Expand
                    v_result_ = self.privfiledescrexpand(v_dirlist_descr_, p_options_)
                    if v_result_ != 1:
                        return v_result_
                    # end if
                    #// ----- Concat the resulting list
                    v_result_list_ = php_array_merge(v_result_list_, v_dirlist_descr_)
                # end if
                v_dirlist_descr_ = None
            # end if
            i_ += 1
        # end while
        #// ----- Get the result list
        p_filedescr_list_ = v_result_list_
        #// ----- Return
        return v_result_
    # end def privfiledescrexpand
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privCreate()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privcreate(self, p_filedescr_list_=None, p_result_list_=None, p_options_=None):
        
        
        v_result_ = 1
        v_list_detail_ = Array()
        #// ----- Magic quotes trick
        self.privdisablemagicquotes()
        #// ----- Open the file in write mode
        v_result_ = self.privopenfd("wb")
        if v_result_ != 1:
            #// ----- Return
            return v_result_
        # end if
        #// ----- Add the list of files
        v_result_ = self.privaddlist(p_filedescr_list_, p_result_list_, p_options_)
        #// ----- Close
        self.privclosefd()
        #// ----- Magic quotes trick
        self.privswapbackmagicquotes()
        #// ----- Return
        return v_result_
    # end def privcreate
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privAdd()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privadd(self, p_filedescr_list_=None, p_result_list_=None, p_options_=None):
        
        
        v_result_ = 1
        v_list_detail_ = Array()
        #// ----- Look if the archive exists or is empty
        if (not php_is_file(self.zipname)) or filesize(self.zipname) == 0:
            #// ----- Do a create
            v_result_ = self.privcreate(p_filedescr_list_, p_result_list_, p_options_)
            #// ----- Return
            return v_result_
        # end if
        #// ----- Magic quotes trick
        self.privdisablemagicquotes()
        #// ----- Open the zip file
        v_result_ = self.privopenfd("rb")
        if v_result_ != 1:
            #// ----- Magic quotes trick
            self.privswapbackmagicquotes()
            #// ----- Return
            return v_result_
        # end if
        #// ----- Read the central directory information
        v_central_dir_ = Array()
        v_result_ = self.privreadendcentraldir(v_central_dir_)
        if v_result_ != 1:
            self.privclosefd()
            self.privswapbackmagicquotes()
            return v_result_
        # end if
        #// ----- Go to beginning of File
        php_no_error(lambda: rewind(self.zip_fd))
        #// ----- Creates a temporary file
        v_zip_temp_name_ = PCLZIP_TEMPORARY_DIR + uniqid("pclzip-") + ".tmp"
        #// ----- Open the temporary file in write mode
        v_zip_temp_fd_ = php_no_error(lambda: fopen(v_zip_temp_name_, "wb"))
        if v_zip_temp_fd_ == 0:
            self.privclosefd()
            self.privswapbackmagicquotes()
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open temporary file '" + v_zip_temp_name_ + "' in binary write mode")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Copy the files from the archive to the temporary file
        #// TBC : Here I should better append the file and go back to erase the central dir
        v_size_ = v_central_dir_["offset"]
        while True:
            
            if not (v_size_ != 0):
                break
            # end if
            v_read_size_ = v_size_ if v_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer_ = fread(self.zip_fd, v_read_size_)
            php_no_error(lambda: fwrite(v_zip_temp_fd_, v_buffer_, v_read_size_))
            v_size_ -= v_read_size_
        # end while
        #// ----- Swap the file descriptor
        #// Here is a trick : I swap the temporary fd with the zip fd, in order to use
        #// the following methods on the temporary fil and not the real archive
        v_swap_ = self.zip_fd
        self.zip_fd = v_zip_temp_fd_
        v_zip_temp_fd_ = v_swap_
        #// ----- Add the files
        v_header_list_ = Array()
        v_result_ = self.privaddfilelist(p_filedescr_list_, v_header_list_, p_options_)
        if v_result_ != 1:
            php_fclose(v_zip_temp_fd_)
            self.privclosefd()
            php_no_error(lambda: unlink(v_zip_temp_name_))
            self.privswapbackmagicquotes()
            #// ----- Return
            return v_result_
        # end if
        #// ----- Store the offset of the central dir
        v_offset_ = php_no_error(lambda: ftell(self.zip_fd))
        #// ----- Copy the block of file headers from the old archive
        v_size_ = v_central_dir_["size"]
        while True:
            
            if not (v_size_ != 0):
                break
            # end if
            v_read_size_ = v_size_ if v_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer_ = php_no_error(lambda: fread(v_zip_temp_fd_, v_read_size_))
            php_no_error(lambda: fwrite(self.zip_fd, v_buffer_, v_read_size_))
            v_size_ -= v_read_size_
        # end while
        #// ----- Create the Central Dir files header
        i_ = 0
        v_count_ = 0
        while i_ < sizeof(v_header_list_):
            
            #// ----- Create the file header
            if v_header_list_[i_]["status"] == "ok":
                v_result_ = self.privwritecentralfileheader(v_header_list_[i_])
                if v_result_ != 1:
                    php_fclose(v_zip_temp_fd_)
                    self.privclosefd()
                    php_no_error(lambda: unlink(v_zip_temp_name_))
                    self.privswapbackmagicquotes()
                    #// ----- Return
                    return v_result_
                # end if
                v_count_ += 1
            # end if
            #// ----- Transform the header to a 'usable' info
            self.privconvertheader2fileinfo(v_header_list_[i_], p_result_list_[i_])
            i_ += 1
        # end while
        #// ----- Zip file comment
        v_comment_ = v_central_dir_["comment"]
        if (php_isset(lambda : p_options_[PCLZIP_OPT_COMMENT])):
            v_comment_ = p_options_[PCLZIP_OPT_COMMENT]
        # end if
        if (php_isset(lambda : p_options_[PCLZIP_OPT_ADD_COMMENT])):
            v_comment_ = v_comment_ + p_options_[PCLZIP_OPT_ADD_COMMENT]
        # end if
        if (php_isset(lambda : p_options_[PCLZIP_OPT_PREPEND_COMMENT])):
            v_comment_ = p_options_[PCLZIP_OPT_PREPEND_COMMENT] + v_comment_
        # end if
        #// ----- Calculate the size of the central header
        v_size_ = php_no_error(lambda: ftell(self.zip_fd)) - v_offset_
        #// ----- Create the central dir footer
        v_result_ = self.privwritecentralheader(v_count_ + v_central_dir_["entries"], v_size_, v_offset_, v_comment_)
        if v_result_ != 1:
            v_header_list_ = None
            self.privswapbackmagicquotes()
            #// ----- Return
            return v_result_
        # end if
        #// ----- Swap back the file descriptor
        v_swap_ = self.zip_fd
        self.zip_fd = v_zip_temp_fd_
        v_zip_temp_fd_ = v_swap_
        #// ----- Close
        self.privclosefd()
        #// ----- Close the temporary file
        php_no_error(lambda: php_fclose(v_zip_temp_fd_))
        #// ----- Magic quotes trick
        self.privswapbackmagicquotes()
        #// ----- Delete the zip file
        #// TBC : I should test the result ...
        php_no_error(lambda: unlink(self.zipname))
        #// ----- Rename the temporary file
        #// TBC : I should test the result ...
        #// @rename($v_zip_temp_name, $this->zipname);
        PclZipUtilRename(v_zip_temp_name_, self.zipname)
        #// ----- Return
        return v_result_
    # end def privadd
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privOpenFd()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def privopenfd(self, p_mode_=None):
        
        
        v_result_ = 1
        #// ----- Look if already open
        if self.zip_fd != 0:
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Zip file '" + self.zipname + "' already open")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Open the zip file
        self.zip_fd = php_no_error(lambda: fopen(self.zipname, p_mode_))
        if self.zip_fd == 0:
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open archive '" + self.zipname + "' in " + p_mode_ + " mode")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Return
        return v_result_
    # end def privopenfd
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privCloseFd()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def privclosefd(self):
        
        
        v_result_ = 1
        if self.zip_fd != 0:
            php_no_error(lambda: php_fclose(self.zip_fd))
        # end if
        self.zip_fd = 0
        #// ----- Return
        return v_result_
    # end def privclosefd
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privAddList()
    #// Description :
    #// $p_add_dir and $p_remove_dir will give the ability to memorize a path which is
    #// different from the real path of the file. This is useful if you want to have PclTar
    #// running in any directory, and memorize relative path from an other directory.
    #// Parameters :
    #// $p_list : An array containing the file or directory names to add in the tar
    #// $p_result_list : list of added files with their properties (specially the status field)
    #// $p_add_dir : Path to add in the filename path archived
    #// $p_remove_dir : Path to remove in the filename path archived
    #// Return Values :
    #// --------------------------------------------------------------------------------
    #// function privAddList($p_list, &$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &$p_options)
    def privaddlist(self, p_filedescr_list_=None, p_result_list_=None, p_options_=None):
        
        
        v_result_ = 1
        #// ----- Add the files
        v_header_list_ = Array()
        v_result_ = self.privaddfilelist(p_filedescr_list_, v_header_list_, p_options_)
        if v_result_ != 1:
            #// ----- Return
            return v_result_
        # end if
        #// ----- Store the offset of the central dir
        v_offset_ = php_no_error(lambda: ftell(self.zip_fd))
        #// ----- Create the Central Dir files header
        i_ = 0
        v_count_ = 0
        while i_ < sizeof(v_header_list_):
            
            #// ----- Create the file header
            if v_header_list_[i_]["status"] == "ok":
                v_result_ = self.privwritecentralfileheader(v_header_list_[i_])
                if v_result_ != 1:
                    #// ----- Return
                    return v_result_
                # end if
                v_count_ += 1
            # end if
            #// ----- Transform the header to a 'usable' info
            self.privconvertheader2fileinfo(v_header_list_[i_], p_result_list_[i_])
            i_ += 1
        # end while
        #// ----- Zip file comment
        v_comment_ = ""
        if (php_isset(lambda : p_options_[PCLZIP_OPT_COMMENT])):
            v_comment_ = p_options_[PCLZIP_OPT_COMMENT]
        # end if
        #// ----- Calculate the size of the central header
        v_size_ = php_no_error(lambda: ftell(self.zip_fd)) - v_offset_
        #// ----- Create the central dir footer
        v_result_ = self.privwritecentralheader(v_count_, v_size_, v_offset_, v_comment_)
        if v_result_ != 1:
            v_header_list_ = None
            #// ----- Return
            return v_result_
        # end if
        #// ----- Return
        return v_result_
    # end def privaddlist
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privAddFileList()
    #// Description :
    #// Parameters :
    #// $p_filedescr_list : An array containing the file description
    #// or directory names to add in the zip
    #// $p_result_list : list of added files with their properties (specially the status field)
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privaddfilelist(self, p_filedescr_list_=None, p_result_list_=None, p_options_=None):
        
        
        v_result_ = 1
        v_header_ = Array()
        #// ----- Recuperate the current number of elt in list
        v_nb_ = sizeof(p_result_list_)
        #// ----- Loop on the files
        j_ = 0
        while j_ < sizeof(p_filedescr_list_) and v_result_ == 1:
            
            #// ----- Format the filename
            p_filedescr_list_[j_]["filename"] = PclZipUtilTranslateWinPath(p_filedescr_list_[j_]["filename"], False)
            #// ----- Skip empty file names
            #// TBC : Can this be possible ? not checked in DescrParseAtt ?
            if p_filedescr_list_[j_]["filename"] == "":
                continue
            # end if
            #// ----- Check the filename
            if p_filedescr_list_[j_]["type"] != "virtual_file" and (not php_file_exists(p_filedescr_list_[j_]["filename"])):
                PclZip.priverrorlog(PCLZIP_ERR_MISSING_FILE, "File '" + p_filedescr_list_[j_]["filename"] + "' does not exist")
                return PclZip.errorcode()
            # end if
            #// ----- Look if it is a file or a dir with no all path remove option
            #// or a dir with all its path removed
            #// if (   (is_file($p_filedescr_list[$j]['filename']))
            #// || (   is_dir($p_filedescr_list[$j]['filename'])
            if p_filedescr_list_[j_]["type"] == "file" or p_filedescr_list_[j_]["type"] == "virtual_file" or p_filedescr_list_[j_]["type"] == "folder" and (not (php_isset(lambda : p_options_[PCLZIP_OPT_REMOVE_ALL_PATH]))) or (not p_options_[PCLZIP_OPT_REMOVE_ALL_PATH]):
                #// ----- Add the file
                v_result_ = self.privaddfile(p_filedescr_list_[j_], v_header_, p_options_)
                if v_result_ != 1:
                    return v_result_
                # end if
                #// ----- Store the file infos
                p_result_list_[v_nb_] = v_header_
                v_nb_ += 1
            # end if
            j_ += 1
        # end while
        #// ----- Return
        return v_result_
    # end def privaddfilelist
    v_nb_ += 1
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privAddFile()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privaddfile(self, p_filedescr_=None, p_header_=None, p_options_=None):
        
        
        v_result_ = 1
        #// ----- Working variable
        p_filename_ = p_filedescr_["filename"]
        #// TBC : Already done in the fileAtt check ... ?
        if p_filename_ == "":
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file list parameter (invalid or empty list)")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Look for a stored different filename
        #// TBC : Removed
        #// if (isset($p_filedescr['stored_filename'])) {
        #// $v_stored_filename = $p_filedescr['stored_filename'];
        #// }
        #// else {
        #// $v_stored_filename = $p_filedescr['stored_filename'];
        #// }
        #// 
        #// ----- Set the file properties
        clearstatcache()
        p_header_["version"] = 20
        p_header_["version_extracted"] = 10
        p_header_["flag"] = 0
        p_header_["compression"] = 0
        p_header_["crc"] = 0
        p_header_["compressed_size"] = 0
        p_header_["filename_len"] = php_strlen(p_filename_)
        p_header_["extra_len"] = 0
        p_header_["disk"] = 0
        p_header_["internal"] = 0
        p_header_["offset"] = 0
        p_header_["filename"] = p_filename_
        #// TBC : Removed    $p_header['stored_filename'] = $v_stored_filename;
        p_header_["stored_filename"] = p_filedescr_["stored_filename"]
        p_header_["extra"] = ""
        p_header_["status"] = "ok"
        p_header_["index"] = -1
        #// ----- Look for regular file
        if p_filedescr_["type"] == "file":
            p_header_["external"] = 0
            p_header_["size"] = filesize(p_filename_)
        else:
            if p_filedescr_["type"] == "folder":
                p_header_["external"] = 16
                p_header_["mtime"] = filemtime(p_filename_)
                p_header_["size"] = filesize(p_filename_)
            else:
                if p_filedescr_["type"] == "virtual_file":
                    p_header_["external"] = 0
                    p_header_["size"] = php_strlen(p_filedescr_["content"])
                # end if
            # end if
        # end if
        #// ----- Look for filetime
        if (php_isset(lambda : p_filedescr_["mtime"])):
            p_header_["mtime"] = p_filedescr_["mtime"]
        else:
            if p_filedescr_["type"] == "virtual_file":
                p_header_["mtime"] = time()
            else:
                p_header_["mtime"] = filemtime(p_filename_)
            # end if
        # end if
        #// ------ Look for file comment
        if (php_isset(lambda : p_filedescr_["comment"])):
            p_header_["comment_len"] = php_strlen(p_filedescr_["comment"])
            p_header_["comment"] = p_filedescr_["comment"]
        else:
            p_header_["comment_len"] = 0
            p_header_["comment"] = ""
        # end if
        #// ----- Look for pre-add callback
        if (php_isset(lambda : p_options_[PCLZIP_CB_PRE_ADD])):
            #// ----- Generate a local information
            v_local_header_ = Array()
            self.privconvertheader2fileinfo(p_header_, v_local_header_)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result_ = p_options_[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, v_local_header_)
            if v_result_ == 0:
                #// ----- Change the file status
                p_header_["status"] = "skipped"
                v_result_ = 1
            # end if
            #// ----- Update the information
            #// Only some fields can be modified
            if p_header_["stored_filename"] != v_local_header_["stored_filename"]:
                p_header_["stored_filename"] = PclZipUtilPathReduction(v_local_header_["stored_filename"])
            # end if
        # end if
        #// ----- Look for empty stored filename
        if p_header_["stored_filename"] == "":
            p_header_["status"] = "filtered"
        # end if
        #// ----- Check the path length
        if php_strlen(p_header_["stored_filename"]) > 255:
            p_header_["status"] = "filename_too_long"
        # end if
        #// ----- Look if no error, or file not skipped
        if p_header_["status"] == "ok":
            #// ----- Look for a file
            if p_filedescr_["type"] == "file":
                #// ----- Look for using temporary file to zip
                if (not (php_isset(lambda : p_options_[PCLZIP_OPT_TEMP_FILE_OFF]))) and (php_isset(lambda : p_options_[PCLZIP_OPT_TEMP_FILE_ON])) or (php_isset(lambda : p_options_[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) and p_options_[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= p_header_["size"]:
                    v_result_ = self.privaddfileusingtempfile(p_filedescr_, p_header_, p_options_)
                    if v_result_ < PCLZIP_ERR_NO_ERROR:
                        return v_result_
                    # end if
                else:
                    #// ----- Open the source file
                    v_file_ = php_no_error(lambda: fopen(p_filename_, "rb"))
                    if v_file_ == 0:
                        PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, str("Unable to open file '") + str(p_filename_) + str("' in binary read mode"))
                        return PclZip.errorcode()
                    # end if
                    #// ----- Read the file content
                    v_content_ = php_no_error(lambda: fread(v_file_, p_header_["size"]))
                    #// ----- Close the file
                    php_no_error(lambda: php_fclose(v_file_))
                    #// ----- Calculate the CRC
                    p_header_["crc"] = php_no_error(lambda: crc32(v_content_))
                    #// ----- Look for no compression
                    if p_options_[PCLZIP_OPT_NO_COMPRESSION]:
                        #// ----- Set header parameters
                        p_header_["compressed_size"] = p_header_["size"]
                        p_header_["compression"] = 0
                    else:
                        #// ----- Compress the content
                        v_content_ = php_no_error(lambda: gzdeflate(v_content_))
                        #// ----- Set header parameters
                        p_header_["compressed_size"] = php_strlen(v_content_)
                        p_header_["compression"] = 8
                    # end if
                    #// ----- Call the header generation
                    v_result_ = self.privwritefileheader(p_header_)
                    if v_result_ != 1:
                        php_no_error(lambda: php_fclose(v_file_))
                        return v_result_
                    # end if
                    #// ----- Write the compressed (or not) content
                    php_no_error(lambda: fwrite(self.zip_fd, v_content_, p_header_["compressed_size"]))
                # end if
            else:
                if p_filedescr_["type"] == "virtual_file":
                    v_content_ = p_filedescr_["content"]
                    #// ----- Calculate the CRC
                    p_header_["crc"] = php_no_error(lambda: crc32(v_content_))
                    #// ----- Look for no compression
                    if p_options_[PCLZIP_OPT_NO_COMPRESSION]:
                        #// ----- Set header parameters
                        p_header_["compressed_size"] = p_header_["size"]
                        p_header_["compression"] = 0
                    else:
                        #// ----- Compress the content
                        v_content_ = php_no_error(lambda: gzdeflate(v_content_))
                        #// ----- Set header parameters
                        p_header_["compressed_size"] = php_strlen(v_content_)
                        p_header_["compression"] = 8
                    # end if
                    #// ----- Call the header generation
                    v_result_ = self.privwritefileheader(p_header_)
                    if v_result_ != 1:
                        php_no_error(lambda: php_fclose(v_file_))
                        return v_result_
                    # end if
                    #// ----- Write the compressed (or not) content
                    php_no_error(lambda: fwrite(self.zip_fd, v_content_, p_header_["compressed_size"]))
                else:
                    if p_filedescr_["type"] == "folder":
                        #// ----- Look for directory last '/'
                        if php_no_error(lambda: php_substr(p_header_["stored_filename"], -1)) != "/":
                            p_header_["stored_filename"] += "/"
                        # end if
                        #// ----- Set the file properties
                        p_header_["size"] = 0
                        #// $p_header['external'] = 0x41FF0010;   // Value for a folder : to be checked
                        p_header_["external"] = 16
                        #// Value for a folder : to be checked
                        #// ----- Call the header generation
                        v_result_ = self.privwritefileheader(p_header_)
                        if v_result_ != 1:
                            return v_result_
                        # end if
                    # end if
                # end if
            # end if
        # end if
        #// ----- Look for post-add callback
        if (php_isset(lambda : p_options_[PCLZIP_CB_POST_ADD])):
            #// ----- Generate a local information
            v_local_header_ = Array()
            self.privconvertheader2fileinfo(p_header_, v_local_header_)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result_ = p_options_[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, v_local_header_)
            if v_result_ == 0:
                #// ----- Ignored
                v_result_ = 1
            # end if
            pass
        # end if
        #// ----- Return
        return v_result_
    # end def privaddfile
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privAddFileUsingTempFile()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privaddfileusingtempfile(self, p_filedescr_=None, p_header_=None, p_options_=None):
        
        
        v_result_ = PCLZIP_ERR_NO_ERROR
        #// ----- Working variable
        p_filename_ = p_filedescr_["filename"]
        #// ----- Open the source file
        v_file_ = php_no_error(lambda: fopen(p_filename_, "rb"))
        if v_file_ == 0:
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, str("Unable to open file '") + str(p_filename_) + str("' in binary read mode"))
            return PclZip.errorcode()
        # end if
        #// ----- Creates a compressed temporary file
        v_gzip_temp_name_ = PCLZIP_TEMPORARY_DIR + uniqid("pclzip-") + ".gz"
        v_file_compressed_ = php_no_error(lambda: gzopen(v_gzip_temp_name_, "wb"))
        if v_file_compressed_ == 0:
            php_fclose(v_file_)
            PclZip.priverrorlog(PCLZIP_ERR_WRITE_OPEN_FAIL, "Unable to open temporary file '" + v_gzip_temp_name_ + "' in binary write mode")
            return PclZip.errorcode()
        # end if
        #// ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
        v_size_ = filesize(p_filename_)
        while True:
            
            if not (v_size_ != 0):
                break
            # end if
            v_read_size_ = v_size_ if v_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer_ = php_no_error(lambda: fread(v_file_, v_read_size_))
            #// $v_binary_data = pack('a'.$v_read_size, $v_buffer);
            php_no_error(lambda: gzputs(v_file_compressed_, v_buffer_, v_read_size_))
            v_size_ -= v_read_size_
        # end while
        #// ----- Close the file
        php_no_error(lambda: php_fclose(v_file_))
        php_no_error(lambda: gzclose(v_file_compressed_))
        #// ----- Check the minimum file size
        if filesize(v_gzip_temp_name_) < 18:
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "gzip temporary file '" + v_gzip_temp_name_ + "' has invalid filesize - should be minimum 18 bytes")
            return PclZip.errorcode()
        # end if
        #// ----- Extract the compressed attributes
        v_file_compressed_ = php_no_error(lambda: fopen(v_gzip_temp_name_, "rb"))
        if v_file_compressed_ == 0:
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open temporary file '" + v_gzip_temp_name_ + "' in binary read mode")
            return PclZip.errorcode()
        # end if
        #// ----- Read the gzip file header
        v_binary_data_ = php_no_error(lambda: fread(v_file_compressed_, 10))
        v_data_header_ = unpack("a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os", v_binary_data_)
        #// ----- Check some parameters
        v_data_header_["os"] = bin2hex(v_data_header_["os"])
        #// ----- Read the gzip file footer
        php_no_error(lambda: fseek(v_file_compressed_, filesize(v_gzip_temp_name_) - 8))
        v_binary_data_ = php_no_error(lambda: fread(v_file_compressed_, 8))
        v_data_footer_ = unpack("Vcrc/Vcompressed_size", v_binary_data_)
        #// ----- Set the attributes
        p_header_["compression"] = php_ord(v_data_header_["cm"])
        #// $p_header['mtime'] = $v_data_header['mtime'];
        p_header_["crc"] = v_data_footer_["crc"]
        p_header_["compressed_size"] = filesize(v_gzip_temp_name_) - 18
        #// ----- Close the file
        php_no_error(lambda: php_fclose(v_file_compressed_))
        #// ----- Call the header generation
        v_result_ = self.privwritefileheader(p_header_)
        if v_result_ != 1:
            return v_result_
        # end if
        #// ----- Add the compressed data
        v_file_compressed_ = php_no_error(lambda: fopen(v_gzip_temp_name_, "rb"))
        if v_file_compressed_ == 0:
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open temporary file '" + v_gzip_temp_name_ + "' in binary read mode")
            return PclZip.errorcode()
        # end if
        #// ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
        fseek(v_file_compressed_, 10)
        v_size_ = p_header_["compressed_size"]
        while True:
            
            if not (v_size_ != 0):
                break
            # end if
            v_read_size_ = v_size_ if v_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer_ = php_no_error(lambda: fread(v_file_compressed_, v_read_size_))
            #// $v_binary_data = pack('a'.$v_read_size, $v_buffer);
            php_no_error(lambda: fwrite(self.zip_fd, v_buffer_, v_read_size_))
            v_size_ -= v_read_size_
        # end while
        #// ----- Close the file
        php_no_error(lambda: php_fclose(v_file_compressed_))
        #// ----- Unlink the temporary file
        php_no_error(lambda: unlink(v_gzip_temp_name_))
        #// ----- Return
        return v_result_
    # end def privaddfileusingtempfile
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privCalculateStoredFilename()
    #// Description :
    #// Based on file descriptor properties and global options, this method
    #// calculate the filename that will be stored in the archive.
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privcalculatestoredfilename(self, p_filedescr_=None, p_options_=None):
        
        
        v_result_ = 1
        #// ----- Working variables
        p_filename_ = p_filedescr_["filename"]
        if (php_isset(lambda : p_options_[PCLZIP_OPT_ADD_PATH])):
            p_add_dir_ = p_options_[PCLZIP_OPT_ADD_PATH]
        else:
            p_add_dir_ = ""
        # end if
        if (php_isset(lambda : p_options_[PCLZIP_OPT_REMOVE_PATH])):
            p_remove_dir_ = p_options_[PCLZIP_OPT_REMOVE_PATH]
        else:
            p_remove_dir_ = ""
        # end if
        if (php_isset(lambda : p_options_[PCLZIP_OPT_REMOVE_ALL_PATH])):
            p_remove_all_dir_ = p_options_[PCLZIP_OPT_REMOVE_ALL_PATH]
        else:
            p_remove_all_dir_ = 0
        # end if
        #// ----- Look for full name change
        if (php_isset(lambda : p_filedescr_["new_full_name"])):
            #// ----- Remove drive letter if any
            v_stored_filename_ = PclZipUtilTranslateWinPath(p_filedescr_["new_full_name"])
        else:
            #// ----- Look for short name change
            #// Its when we change just the filename but not the path
            if (php_isset(lambda : p_filedescr_["new_short_name"])):
                v_path_info_ = pathinfo(p_filename_)
                v_dir_ = ""
                if v_path_info_["dirname"] != "":
                    v_dir_ = v_path_info_["dirname"] + "/"
                # end if
                v_stored_filename_ = v_dir_ + p_filedescr_["new_short_name"]
            else:
                #// ----- Calculate the stored filename
                v_stored_filename_ = p_filename_
            # end if
            #// ----- Look for all path to remove
            if p_remove_all_dir_:
                v_stored_filename_ = php_basename(p_filename_)
            else:
                if p_remove_dir_ != "":
                    if php_substr(p_remove_dir_, -1) != "/":
                        p_remove_dir_ += "/"
                    # end if
                    if php_substr(p_filename_, 0, 2) == "./" or php_substr(p_remove_dir_, 0, 2) == "./":
                        if php_substr(p_filename_, 0, 2) == "./" and php_substr(p_remove_dir_, 0, 2) != "./":
                            p_remove_dir_ = "./" + p_remove_dir_
                        # end if
                        if php_substr(p_filename_, 0, 2) != "./" and php_substr(p_remove_dir_, 0, 2) == "./":
                            p_remove_dir_ = php_substr(p_remove_dir_, 2)
                        # end if
                    # end if
                    v_compare_ = PclZipUtilPathInclusion(p_remove_dir_, v_stored_filename_)
                    if v_compare_ > 0:
                        if v_compare_ == 2:
                            v_stored_filename_ = ""
                        else:
                            v_stored_filename_ = php_substr(v_stored_filename_, php_strlen(p_remove_dir_))
                        # end if
                    # end if
                # end if
            # end if
            #// ----- Remove drive letter if any
            v_stored_filename_ = PclZipUtilTranslateWinPath(v_stored_filename_)
            #// ----- Look for path to add
            if p_add_dir_ != "":
                if php_substr(p_add_dir_, -1) == "/":
                    v_stored_filename_ = p_add_dir_ + v_stored_filename_
                else:
                    v_stored_filename_ = p_add_dir_ + "/" + v_stored_filename_
                # end if
            # end if
        # end if
        #// ----- Filename (reduce the path of stored name)
        v_stored_filename_ = PclZipUtilPathReduction(v_stored_filename_)
        p_filedescr_["stored_filename"] = v_stored_filename_
        #// ----- Return
        return v_result_
    # end def privcalculatestoredfilename
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privWriteFileHeader()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privwritefileheader(self, p_header_=None):
        
        
        v_result_ = 1
        #// ----- Store the offset position of the file
        p_header_["offset"] = ftell(self.zip_fd)
        #// ----- Transform UNIX mtime to DOS format mdate/mtime
        v_date_ = getdate(p_header_["mtime"])
        v_mtime_ = v_date_["hours"] << 11 + v_date_["minutes"] << 5 + v_date_["seconds"] / 2
        v_mdate_ = v_date_["year"] - 1980 << 9 + v_date_["mon"] << 5 + v_date_["mday"]
        #// ----- Packed data
        v_binary_data_ = pack("VvvvvvVVVvv", 67324752, p_header_["version_extracted"], p_header_["flag"], p_header_["compression"], v_mtime_, v_mdate_, p_header_["crc"], p_header_["compressed_size"], p_header_["size"], php_strlen(p_header_["stored_filename"]), p_header_["extra_len"])
        #// ----- Write the first 148 bytes of the header in the archive
        fputs(self.zip_fd, v_binary_data_, 30)
        #// ----- Write the variable fields
        if php_strlen(p_header_["stored_filename"]) != 0:
            fputs(self.zip_fd, p_header_["stored_filename"], php_strlen(p_header_["stored_filename"]))
        # end if
        if p_header_["extra_len"] != 0:
            fputs(self.zip_fd, p_header_["extra"], p_header_["extra_len"])
        # end if
        #// ----- Return
        return v_result_
    # end def privwritefileheader
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privWriteCentralFileHeader()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privwritecentralfileheader(self, p_header_=None):
        
        
        v_result_ = 1
        #// TBC
        #// for(reset($p_header); $key = key($p_header); next($p_header)) {
        #// }
        #// ----- Transform UNIX mtime to DOS format mdate/mtime
        v_date_ = getdate(p_header_["mtime"])
        v_mtime_ = v_date_["hours"] << 11 + v_date_["minutes"] << 5 + v_date_["seconds"] / 2
        v_mdate_ = v_date_["year"] - 1980 << 9 + v_date_["mon"] << 5 + v_date_["mday"]
        #// ----- Packed data
        v_binary_data_ = pack("VvvvvvvVVVvvvvvVV", 33639248, p_header_["version"], p_header_["version_extracted"], p_header_["flag"], p_header_["compression"], v_mtime_, v_mdate_, p_header_["crc"], p_header_["compressed_size"], p_header_["size"], php_strlen(p_header_["stored_filename"]), p_header_["extra_len"], p_header_["comment_len"], p_header_["disk"], p_header_["internal"], p_header_["external"], p_header_["offset"])
        #// ----- Write the 42 bytes of the header in the zip file
        fputs(self.zip_fd, v_binary_data_, 46)
        #// ----- Write the variable fields
        if php_strlen(p_header_["stored_filename"]) != 0:
            fputs(self.zip_fd, p_header_["stored_filename"], php_strlen(p_header_["stored_filename"]))
        # end if
        if p_header_["extra_len"] != 0:
            fputs(self.zip_fd, p_header_["extra"], p_header_["extra_len"])
        # end if
        if p_header_["comment_len"] != 0:
            fputs(self.zip_fd, p_header_["comment"], p_header_["comment_len"])
        # end if
        #// ----- Return
        return v_result_
    # end def privwritecentralfileheader
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privWriteCentralHeader()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privwritecentralheader(self, p_nb_entries_=None, p_size_=None, p_offset_=None, p_comment_=None):
        
        
        v_result_ = 1
        #// ----- Packed data
        v_binary_data_ = pack("VvvvvVVv", 101010256, 0, 0, p_nb_entries_, p_nb_entries_, p_size_, p_offset_, php_strlen(p_comment_))
        #// ----- Write the 22 bytes of the header in the zip file
        fputs(self.zip_fd, v_binary_data_, 22)
        #// ----- Write the variable fields
        if php_strlen(p_comment_) != 0:
            fputs(self.zip_fd, p_comment_, php_strlen(p_comment_))
        # end if
        #// ----- Return
        return v_result_
    # end def privwritecentralheader
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privList()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privlist(self, p_list_=None):
        
        
        v_result_ = 1
        #// ----- Magic quotes trick
        self.privdisablemagicquotes()
        #// ----- Open the zip file
        self.zip_fd = php_no_error(lambda: fopen(self.zipname, "rb"))
        if self.zip_fd == 0:
            #// ----- Magic quotes trick
            self.privswapbackmagicquotes()
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open archive '" + self.zipname + "' in binary read mode")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Read the central directory information
        v_central_dir_ = Array()
        v_result_ = self.privreadendcentraldir(v_central_dir_)
        if v_result_ != 1:
            self.privswapbackmagicquotes()
            return v_result_
        # end if
        #// ----- Go to beginning of Central Dir
        php_no_error(lambda: rewind(self.zip_fd))
        if php_no_error(lambda: fseek(self.zip_fd, v_central_dir_["offset"])):
            self.privswapbackmagicquotes()
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, "Invalid archive size")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Read each entry
        i_ = 0
        while i_ < v_central_dir_["entries"]:
            
            #// ----- Read the file header
            v_result_ = self.privreadcentralfileheader(v_header_)
            if v_result_ != 1:
                self.privswapbackmagicquotes()
                return v_result_
            # end if
            v_header_["index"] = i_
            #// ----- Get the only interesting attributes
            self.privconvertheader2fileinfo(v_header_, p_list_[i_])
            v_header_ = None
            i_ += 1
        # end while
        #// ----- Close the zip file
        self.privclosefd()
        #// ----- Magic quotes trick
        self.privswapbackmagicquotes()
        #// ----- Return
        return v_result_
    # end def privlist
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privConvertHeader2FileInfo()
    #// Description :
    #// This function takes the file information from the central directory
    #// entries and extract the interesting parameters that will be given back.
    #// The resulting file infos are set in the array $p_info
    #// $p_info['filename'] : Filename with full path. Given by user (add),
    #// extracted in the filesystem (extract).
    #// $p_info['stored_filename'] : Stored filename in the archive.
    #// $p_info['size'] = Size of the file.
    #// $p_info['compressed_size'] = Compressed size of the file.
    #// $p_info['mtime'] = Last modification date of the file.
    #// $p_info['comment'] = Comment associated with the file.
    #// $p_info['folder'] = true/false : indicates if the entry is a folder or not.
    #// $p_info['status'] = status of the action on the file.
    #// $p_info['crc'] = CRC of the file content.
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privconvertheader2fileinfo(self, p_header_=None, p_info_=None):
        
        
        v_result_ = 1
        #// ----- Get the interesting attributes
        v_temp_path_ = PclZipUtilPathReduction(p_header_["filename"])
        p_info_["filename"] = v_temp_path_
        v_temp_path_ = PclZipUtilPathReduction(p_header_["stored_filename"])
        p_info_["stored_filename"] = v_temp_path_
        p_info_["size"] = p_header_["size"]
        p_info_["compressed_size"] = p_header_["compressed_size"]
        p_info_["mtime"] = p_header_["mtime"]
        p_info_["comment"] = p_header_["comment"]
        p_info_["folder"] = p_header_["external"] & 16 == 16
        p_info_["index"] = p_header_["index"]
        p_info_["status"] = p_header_["status"]
        p_info_["crc"] = p_header_["crc"]
        #// ----- Return
        return v_result_
    # end def privconvertheader2fileinfo
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privExtractByRule()
    #// Description :
    #// Extract a file or directory depending of rules (by index, by name, ...)
    #// Parameters :
    #// $p_file_list : An array where will be placed the properties of each
    #// extracted file
    #// $p_path : Path to add while writing the extracted files
    #// $p_remove_path : Path to remove (from the file memorized path) while writing the
    #// extracted files. If the path does not match the file path,
    #// the file is extracted with its memorized path.
    #// $p_remove_path does not apply to 'list' mode.
    #// $p_path and $p_remove_path are commulative.
    #// Return Values :
    #// 1 on success,0 or less on error (see error code list)
    #// --------------------------------------------------------------------------------
    def privextractbyrule(self, p_file_list_=None, p_path_=None, p_remove_path_=None, p_remove_all_path_=None, p_options_=None):
        
        
        v_result_ = 1
        #// ----- Magic quotes trick
        self.privdisablemagicquotes()
        #// ----- Check the path
        if p_path_ == "" or php_substr(p_path_, 0, 1) != "/" and php_substr(p_path_, 0, 3) != "../" and php_substr(p_path_, 1, 2) != ":/":
            p_path_ = "./" + p_path_
        # end if
        #// ----- Reduce the path last (and duplicated) '/'
        if p_path_ != "./" and p_path_ != "/":
            #// ----- Look for the path end '/'
            while True:
                
                if not (php_substr(p_path_, -1) == "/"):
                    break
                # end if
                p_path_ = php_substr(p_path_, 0, php_strlen(p_path_) - 1)
            # end while
        # end if
        #// ----- Look for path to remove format (should end by /)
        if p_remove_path_ != "" and php_substr(p_remove_path_, -1) != "/":
            p_remove_path_ += "/"
        # end if
        p_remove_path_size_ = php_strlen(p_remove_path_)
        #// ----- Open the zip file
        v_result_ = self.privopenfd("rb")
        if v_result_ != 1:
            self.privswapbackmagicquotes()
            return v_result_
        # end if
        #// ----- Read the central directory information
        v_central_dir_ = Array()
        v_result_ = self.privreadendcentraldir(v_central_dir_)
        if v_result_ != 1:
            #// ----- Close the zip file
            self.privclosefd()
            self.privswapbackmagicquotes()
            return v_result_
        # end if
        #// ----- Start at beginning of Central Dir
        v_pos_entry_ = v_central_dir_["offset"]
        #// ----- Read each entry
        j_start_ = 0
        i_ = 0
        v_nb_extracted_ = 0
        while i_ < v_central_dir_["entries"]:
            
            #// ----- Read next Central dir entry
            php_no_error(lambda: rewind(self.zip_fd))
            if php_no_error(lambda: fseek(self.zip_fd, v_pos_entry_)):
                #// ----- Close the zip file
                self.privclosefd()
                self.privswapbackmagicquotes()
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, "Invalid archive size")
                #// ----- Return
                return PclZip.errorcode()
            # end if
            #// ----- Read the file header
            v_header_ = Array()
            v_result_ = self.privreadcentralfileheader(v_header_)
            if v_result_ != 1:
                #// ----- Close the zip file
                self.privclosefd()
                self.privswapbackmagicquotes()
                return v_result_
            # end if
            #// ----- Store the index
            v_header_["index"] = i_
            #// ----- Store the file position
            v_pos_entry_ = ftell(self.zip_fd)
            #// ----- Look for the specific extract rules
            v_extract_ = False
            #// ----- Look for extract by name rule
            if (php_isset(lambda : p_options_[PCLZIP_OPT_BY_NAME])) and p_options_[PCLZIP_OPT_BY_NAME] != 0:
                #// ----- Look if the filename is in the list
                j_ = 0
                while j_ < sizeof(p_options_[PCLZIP_OPT_BY_NAME]) and (not v_extract_):
                    
                    #// ----- Look for a directory
                    if php_substr(p_options_[PCLZIP_OPT_BY_NAME][j_], -1) == "/":
                        #// ----- Look if the directory is in the filename path
                        if php_strlen(v_header_["stored_filename"]) > php_strlen(p_options_[PCLZIP_OPT_BY_NAME][j_]) and php_substr(v_header_["stored_filename"], 0, php_strlen(p_options_[PCLZIP_OPT_BY_NAME][j_])) == p_options_[PCLZIP_OPT_BY_NAME][j_]:
                            v_extract_ = True
                        # end if
                        #// ----- Look for a filename
                    elif v_header_["stored_filename"] == p_options_[PCLZIP_OPT_BY_NAME][j_]:
                        v_extract_ = True
                    # end if
                    j_ += 1
                # end while
            else:
                if (php_isset(lambda : p_options_[PCLZIP_OPT_BY_PREG])) and p_options_[PCLZIP_OPT_BY_PREG] != "":
                    if php_preg_match(p_options_[PCLZIP_OPT_BY_PREG], v_header_["stored_filename"]):
                        v_extract_ = True
                    # end if
                else:
                    if (php_isset(lambda : p_options_[PCLZIP_OPT_BY_INDEX])) and p_options_[PCLZIP_OPT_BY_INDEX] != 0:
                        #// ----- Look if the index is in the list
                        j_ = j_start_
                        while j_ < sizeof(p_options_[PCLZIP_OPT_BY_INDEX]) and (not v_extract_):
                            
                            if i_ >= p_options_[PCLZIP_OPT_BY_INDEX][j_]["start"] and i_ <= p_options_[PCLZIP_OPT_BY_INDEX][j_]["end"]:
                                v_extract_ = True
                            # end if
                            if i_ >= p_options_[PCLZIP_OPT_BY_INDEX][j_]["end"]:
                                j_start_ = j_ + 1
                            # end if
                            if p_options_[PCLZIP_OPT_BY_INDEX][j_]["start"] > i_:
                                break
                            # end if
                            j_ += 1
                        # end while
                    else:
                        v_extract_ = True
                    # end if
                # end if
            # end if
            #// ----- Check compression method
            if v_extract_ and v_header_["compression"] != 8 and v_header_["compression"] != 0:
                v_header_["status"] = "unsupported_compression"
                #// ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                if (php_isset(lambda : p_options_[PCLZIP_OPT_STOP_ON_ERROR])) and p_options_[PCLZIP_OPT_STOP_ON_ERROR] == True:
                    self.privswapbackmagicquotes()
                    PclZip.priverrorlog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION, "Filename '" + v_header_["stored_filename"] + "' is " + "compressed by an unsupported compression " + "method (" + v_header_["compression"] + ") ")
                    return PclZip.errorcode()
                # end if
            # end if
            #// ----- Check encrypted files
            if v_extract_ and v_header_["flag"] & 1 == 1:
                v_header_["status"] = "unsupported_encryption"
                #// ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                if (php_isset(lambda : p_options_[PCLZIP_OPT_STOP_ON_ERROR])) and p_options_[PCLZIP_OPT_STOP_ON_ERROR] == True:
                    self.privswapbackmagicquotes()
                    PclZip.priverrorlog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, "Unsupported encryption for " + " filename '" + v_header_["stored_filename"] + "'")
                    return PclZip.errorcode()
                # end if
            # end if
            #// ----- Look for real extraction
            if v_extract_ and v_header_["status"] != "ok":
                v_result_ = self.privconvertheader2fileinfo(v_header_, p_file_list_[v_nb_extracted_])
                v_nb_extracted_ += 1
                v_nb_extracted_ += 1
                if v_result_ != 1:
                    self.privclosefd()
                    self.privswapbackmagicquotes()
                    return v_result_
                # end if
                v_extract_ = False
            # end if
            #// ----- Look for real extraction
            if v_extract_:
                #// ----- Go to the file position
                php_no_error(lambda: rewind(self.zip_fd))
                if php_no_error(lambda: fseek(self.zip_fd, v_header_["offset"])):
                    #// ----- Close the zip file
                    self.privclosefd()
                    self.privswapbackmagicquotes()
                    #// ----- Error log
                    PclZip.priverrorlog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, "Invalid archive size")
                    #// ----- Return
                    return PclZip.errorcode()
                # end if
                #// ----- Look for extraction as string
                if p_options_[PCLZIP_OPT_EXTRACT_AS_STRING]:
                    v_string_ = ""
                    #// ----- Extracting the file
                    v_result1_ = self.privextractfileasstring(v_header_, v_string_, p_options_)
                    if v_result1_ < 1:
                        self.privclosefd()
                        self.privswapbackmagicquotes()
                        return v_result1_
                    # end if
                    #// ----- Get the only interesting attributes
                    v_result_ = self.privconvertheader2fileinfo(v_header_, p_file_list_[v_nb_extracted_])
                    if v_result_ != 1:
                        #// ----- Close the zip file
                        self.privclosefd()
                        self.privswapbackmagicquotes()
                        return v_result_
                    # end if
                    #// ----- Set the file content
                    p_file_list_[v_nb_extracted_]["content"] = v_string_
                    #// ----- Next extracted file
                    v_nb_extracted_ += 1
                    #// ----- Look for user callback abort
                    if v_result1_ == 2:
                        break
                    # end if
                    #// ----- Look for extraction in standard output
                elif (php_isset(lambda : p_options_[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) and p_options_[PCLZIP_OPT_EXTRACT_IN_OUTPUT]:
                    #// ----- Extracting the file in standard output
                    v_result1_ = self.privextractfileinoutput(v_header_, p_options_)
                    if v_result1_ < 1:
                        self.privclosefd()
                        self.privswapbackmagicquotes()
                        return v_result1_
                    # end if
                    #// ----- Get the only interesting attributes
                    v_result_ = self.privconvertheader2fileinfo(v_header_, p_file_list_[v_nb_extracted_])
                    v_nb_extracted_ += 1
                    if v_result_ != 1:
                        self.privclosefd()
                        self.privswapbackmagicquotes()
                        return v_result_
                    # end if
                    v_nb_extracted_ += 1
                    v_nb_extracted_ += 1
                    v_nb_extracted_ += 1
                    v_nb_extracted_ += 1
                    #// ----- Look for user callback abort
                    if v_result1_ == 2:
                        break
                    # end if
                else:
                    #// ----- Extracting the file
                    v_result1_ = self.privextractfile(v_header_, p_path_, p_remove_path_, p_remove_all_path_, p_options_)
                    if v_result1_ < 1:
                        self.privclosefd()
                        self.privswapbackmagicquotes()
                        return v_result1_
                    # end if
                    #// ----- Get the only interesting attributes
                    v_result_ = self.privconvertheader2fileinfo(v_header_, p_file_list_[v_nb_extracted_])
                    v_nb_extracted_ += 1
                    if v_result_ != 1:
                        #// ----- Close the zip file
                        self.privclosefd()
                        self.privswapbackmagicquotes()
                        return v_result_
                    # end if
                    v_nb_extracted_ += 1
                    v_nb_extracted_ += 1
                    v_nb_extracted_ += 1
                    v_nb_extracted_ += 1
                    #// ----- Look for user callback abort
                    if v_result1_ == 2:
                        break
                    # end if
                # end if
            # end if
            i_ += 1
        # end while
        #// ----- Close the zip file
        self.privclosefd()
        self.privswapbackmagicquotes()
        #// ----- Return
        return v_result_
    # end def privextractbyrule
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privExtractFile()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// 
    #// 1 : ... ?
    #// PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback
    #// --------------------------------------------------------------------------------
    def privextractfile(self, p_entry_=None, p_path_=None, p_remove_path_=None, p_remove_all_path_=None, p_options_=None):
        
        
        v_result_ = 1
        #// ----- Read the file header
        v_result_ = self.privreadfileheader(v_header_)
        if v_result_ != 1:
            #// ----- Return
            return v_result_
        # end if
        #// ----- Check that the file header is coherent with $p_entry info
        if self.privcheckfileheaders(v_header_, p_entry_) != 1:
            pass
        # end if
        #// ----- Look for all path to remove
        if p_remove_all_path_ == True:
            #// ----- Look for folder entry that not need to be extracted
            if p_entry_["external"] & 16 == 16:
                p_entry_["status"] = "filtered"
                return v_result_
            # end if
            #// ----- Get the basename of the path
            p_entry_["filename"] = php_basename(p_entry_["filename"])
        else:
            if p_remove_path_ != "":
                if PclZipUtilPathInclusion(p_remove_path_, p_entry_["filename"]) == 2:
                    #// ----- Change the file status
                    p_entry_["status"] = "filtered"
                    #// ----- Return
                    return v_result_
                # end if
                p_remove_path_size_ = php_strlen(p_remove_path_)
                if php_substr(p_entry_["filename"], 0, p_remove_path_size_) == p_remove_path_:
                    #// ----- Remove the path
                    p_entry_["filename"] = php_substr(p_entry_["filename"], p_remove_path_size_)
                # end if
            # end if
        # end if
        #// ----- Add the path
        if p_path_ != "":
            p_entry_["filename"] = p_path_ + "/" + p_entry_["filename"]
        # end if
        #// ----- Check a base_dir_restriction
        if (php_isset(lambda : p_options_[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])):
            v_inclusion_ = PclZipUtilPathInclusion(p_options_[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION], p_entry_["filename"])
            if v_inclusion_ == 0:
                PclZip.priverrorlog(PCLZIP_ERR_DIRECTORY_RESTRICTION, "Filename '" + p_entry_["filename"] + "' is " + "outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION")
                return PclZip.errorcode()
            # end if
        # end if
        #// ----- Look for pre-extract callback
        if (php_isset(lambda : p_options_[PCLZIP_CB_PRE_EXTRACT])):
            #// ----- Generate a local information
            v_local_header_ = Array()
            self.privconvertheader2fileinfo(p_entry_, v_local_header_)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result_ = p_options_[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, v_local_header_)
            if v_result_ == 0:
                #// ----- Change the file status
                p_entry_["status"] = "skipped"
                v_result_ = 1
            # end if
            #// ----- Look for abort result
            if v_result_ == 2:
                #// ----- This status is internal and will be changed in 'skipped'
                p_entry_["status"] = "aborted"
                v_result_ = PCLZIP_ERR_USER_ABORTED
            # end if
            #// ----- Update the information
            #// Only some fields can be modified
            p_entry_["filename"] = v_local_header_["filename"]
        # end if
        #// ----- Look if extraction should be done
        if p_entry_["status"] == "ok":
            #// ----- Look for specific actions while the file exist
            if php_file_exists(p_entry_["filename"]):
                #// ----- Look if file is a directory
                if php_is_dir(p_entry_["filename"]):
                    #// ----- Change the file status
                    p_entry_["status"] = "already_a_directory"
                    #// ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                    #// For historical reason first PclZip implementation does not stop
                    #// when this kind of error occurs.
                    if (php_isset(lambda : p_options_[PCLZIP_OPT_STOP_ON_ERROR])) and p_options_[PCLZIP_OPT_STOP_ON_ERROR] == True:
                        PclZip.priverrorlog(PCLZIP_ERR_ALREADY_A_DIRECTORY, "Filename '" + p_entry_["filename"] + "' is " + "already used by an existing directory")
                        return PclZip.errorcode()
                    # end if
                else:
                    if (not is_writeable(p_entry_["filename"])):
                        #// ----- Change the file status
                        p_entry_["status"] = "write_protected"
                        #// ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                        #// For historical reason first PclZip implementation does not stop
                        #// when this kind of error occurs.
                        if (php_isset(lambda : p_options_[PCLZIP_OPT_STOP_ON_ERROR])) and p_options_[PCLZIP_OPT_STOP_ON_ERROR] == True:
                            PclZip.priverrorlog(PCLZIP_ERR_WRITE_OPEN_FAIL, "Filename '" + p_entry_["filename"] + "' exists " + "and is write protected")
                            return PclZip.errorcode()
                        # end if
                    else:
                        if filemtime(p_entry_["filename"]) > p_entry_["mtime"]:
                            #// ----- Change the file status
                            if (php_isset(lambda : p_options_[PCLZIP_OPT_REPLACE_NEWER])) and p_options_[PCLZIP_OPT_REPLACE_NEWER] == True:
                                pass
                            else:
                                p_entry_["status"] = "newer_exist"
                                #// ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                                #// For historical reason first PclZip implementation does not stop
                                #// when this kind of error occurs.
                                if (php_isset(lambda : p_options_[PCLZIP_OPT_STOP_ON_ERROR])) and p_options_[PCLZIP_OPT_STOP_ON_ERROR] == True:
                                    PclZip.priverrorlog(PCLZIP_ERR_WRITE_OPEN_FAIL, "Newer version of '" + p_entry_["filename"] + "' exists " + "and option PCLZIP_OPT_REPLACE_NEWER is not selected")
                                    return PclZip.errorcode()
                                # end if
                            # end if
                        # end if
                    # end if
                # end if
            else:
                if p_entry_["external"] & 16 == 16 or php_substr(p_entry_["filename"], -1) == "/":
                    v_dir_to_check_ = p_entry_["filename"]
                else:
                    if (not php_strstr(p_entry_["filename"], "/")):
                        v_dir_to_check_ = ""
                    else:
                        v_dir_to_check_ = php_dirname(p_entry_["filename"])
                    # end if
                # end if
                v_result_ = self.privdircheck(v_dir_to_check_, p_entry_["external"] & 16 == 16)
                if v_result_ != 1:
                    #// ----- Change the file status
                    p_entry_["status"] = "path_creation_fail"
                    #// ----- Return
                    #// return $v_result;
                    v_result_ = 1
                # end if
            # end if
        # end if
        #// ----- Look if extraction should be done
        if p_entry_["status"] == "ok":
            #// ----- Do the extraction (if not a folder)
            if (not p_entry_["external"] & 16 == 16):
                #// ----- Look for not compressed file
                if p_entry_["compression"] == 0:
                    #// ----- Opening destination file
                    v_dest_file_ = php_no_error(lambda: fopen(p_entry_["filename"], "wb"))
                    if v_dest_file_ == 0:
                        #// ----- Change the file status
                        p_entry_["status"] = "write_error"
                        #// ----- Return
                        return v_result_
                    # end if
                    #// ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
                    v_size_ = p_entry_["compressed_size"]
                    while True:
                        
                        if not (v_size_ != 0):
                            break
                        # end if
                        v_read_size_ = v_size_ if v_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
                        v_buffer_ = php_no_error(lambda: fread(self.zip_fd, v_read_size_))
                        #// Try to speed up the code
                        #// $v_binary_data = pack('a'.$v_read_size, $v_buffer);
                        #// @fwrite($v_dest_file, $v_binary_data, $v_read_size);
                        #//
                        php_no_error(lambda: fwrite(v_dest_file_, v_buffer_, v_read_size_))
                        v_size_ -= v_read_size_
                    # end while
                    #// ----- Closing the destination file
                    php_fclose(v_dest_file_)
                    #// ----- Change the file mtime
                    touch(p_entry_["filename"], p_entry_["mtime"])
                else:
                    #// ----- TBC
                    #// Need to be finished
                    if p_entry_["flag"] & 1 == 1:
                        PclZip.priverrorlog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, "File '" + p_entry_["filename"] + "' is encrypted. Encrypted files are not supported.")
                        return PclZip.errorcode()
                    # end if
                    #// ----- Look for using temporary file to unzip
                    if (not (php_isset(lambda : p_options_[PCLZIP_OPT_TEMP_FILE_OFF]))) and (php_isset(lambda : p_options_[PCLZIP_OPT_TEMP_FILE_ON])) or (php_isset(lambda : p_options_[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) and p_options_[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= p_entry_["size"]:
                        v_result_ = self.privextractfileusingtempfile(p_entry_, p_options_)
                        if v_result_ < PCLZIP_ERR_NO_ERROR:
                            return v_result_
                        # end if
                    else:
                        #// ----- Read the compressed file in a buffer (one shot)
                        v_buffer_ = php_no_error(lambda: fread(self.zip_fd, p_entry_["compressed_size"]))
                        #// ----- Decompress the file
                        v_file_content_ = php_no_error(lambda: gzinflate(v_buffer_))
                        v_buffer_ = None
                        if v_file_content_ == False:
                            #// ----- Change the file status
                            #// TBC
                            p_entry_["status"] = "error"
                            return v_result_
                        # end if
                        #// ----- Opening destination file
                        v_dest_file_ = php_no_error(lambda: fopen(p_entry_["filename"], "wb"))
                        if v_dest_file_ == 0:
                            #// ----- Change the file status
                            p_entry_["status"] = "write_error"
                            return v_result_
                        # end if
                        #// ----- Write the uncompressed data
                        php_no_error(lambda: fwrite(v_dest_file_, v_file_content_, p_entry_["size"]))
                        v_file_content_ = None
                        #// ----- Closing the destination file
                        php_no_error(lambda: php_fclose(v_dest_file_))
                    # end if
                    #// ----- Change the file mtime
                    php_no_error(lambda: touch(p_entry_["filename"], p_entry_["mtime"]))
                # end if
                #// ----- Look for chmod option
                if (php_isset(lambda : p_options_[PCLZIP_OPT_SET_CHMOD])):
                    #// ----- Change the mode of the file
                    php_no_error(lambda: chmod(p_entry_["filename"], p_options_[PCLZIP_OPT_SET_CHMOD]))
                # end if
            # end if
        # end if
        #// ----- Change abort status
        if p_entry_["status"] == "aborted":
            p_entry_["status"] = "skipped"
            #// ----- Look for post-extract callback
        elif (php_isset(lambda : p_options_[PCLZIP_CB_POST_EXTRACT])):
            #// ----- Generate a local information
            v_local_header_ = Array()
            self.privconvertheader2fileinfo(p_entry_, v_local_header_)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result_ = p_options_[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, v_local_header_)
            #// ----- Look for abort result
            if v_result_ == 2:
                v_result_ = PCLZIP_ERR_USER_ABORTED
            # end if
        # end if
        #// ----- Return
        return v_result_
    # end def privextractfile
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privExtractFileUsingTempFile()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privextractfileusingtempfile(self, p_entry_=None, p_options_=None):
        
        
        v_result_ = 1
        #// ----- Creates a temporary file
        v_gzip_temp_name_ = PCLZIP_TEMPORARY_DIR + uniqid("pclzip-") + ".gz"
        v_dest_file_ = php_no_error(lambda: fopen(v_gzip_temp_name_, "wb"))
        if v_dest_file_ == 0:
            php_fclose(v_file_)
            PclZip.priverrorlog(PCLZIP_ERR_WRITE_OPEN_FAIL, "Unable to open temporary file '" + v_gzip_temp_name_ + "' in binary write mode")
            return PclZip.errorcode()
        # end if
        #// ----- Write gz file format header
        v_binary_data_ = pack("va1a1Va1a1", 35615, Chr(p_entry_["compression"]), Chr(0), time(), Chr(0), Chr(3))
        php_no_error(lambda: fwrite(v_dest_file_, v_binary_data_, 10))
        #// ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
        v_size_ = p_entry_["compressed_size"]
        while True:
            
            if not (v_size_ != 0):
                break
            # end if
            v_read_size_ = v_size_ if v_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer_ = php_no_error(lambda: fread(self.zip_fd, v_read_size_))
            #// $v_binary_data = pack('a'.$v_read_size, $v_buffer);
            php_no_error(lambda: fwrite(v_dest_file_, v_buffer_, v_read_size_))
            v_size_ -= v_read_size_
        # end while
        #// ----- Write gz file format footer
        v_binary_data_ = pack("VV", p_entry_["crc"], p_entry_["size"])
        php_no_error(lambda: fwrite(v_dest_file_, v_binary_data_, 8))
        #// ----- Close the temporary file
        php_no_error(lambda: php_fclose(v_dest_file_))
        #// ----- Opening destination file
        v_dest_file_ = php_no_error(lambda: fopen(p_entry_["filename"], "wb"))
        if v_dest_file_ == 0:
            p_entry_["status"] = "write_error"
            return v_result_
        # end if
        #// ----- Open the temporary gz file
        v_src_file_ = php_no_error(lambda: gzopen(v_gzip_temp_name_, "rb"))
        if v_src_file_ == 0:
            php_no_error(lambda: php_fclose(v_dest_file_))
            p_entry_["status"] = "read_error"
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open temporary file '" + v_gzip_temp_name_ + "' in binary read mode")
            return PclZip.errorcode()
        # end if
        #// ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
        v_size_ = p_entry_["size"]
        while True:
            
            if not (v_size_ != 0):
                break
            # end if
            v_read_size_ = v_size_ if v_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer_ = php_no_error(lambda: gzread(v_src_file_, v_read_size_))
            #// $v_binary_data = pack('a'.$v_read_size, $v_buffer);
            php_no_error(lambda: fwrite(v_dest_file_, v_buffer_, v_read_size_))
            v_size_ -= v_read_size_
        # end while
        php_no_error(lambda: php_fclose(v_dest_file_))
        php_no_error(lambda: gzclose(v_src_file_))
        #// ----- Delete the temporary file
        php_no_error(lambda: unlink(v_gzip_temp_name_))
        #// ----- Return
        return v_result_
    # end def privextractfileusingtempfile
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privExtractFileInOutput()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privextractfileinoutput(self, p_entry_=None, p_options_=None):
        
        
        v_result_ = 1
        #// ----- Read the file header
        v_result_ = self.privreadfileheader(v_header_)
        if v_result_ != 1:
            return v_result_
        # end if
        #// ----- Check that the file header is coherent with $p_entry info
        if self.privcheckfileheaders(v_header_, p_entry_) != 1:
            pass
        # end if
        #// ----- Look for pre-extract callback
        if (php_isset(lambda : p_options_[PCLZIP_CB_PRE_EXTRACT])):
            #// ----- Generate a local information
            v_local_header_ = Array()
            self.privconvertheader2fileinfo(p_entry_, v_local_header_)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            #// eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');
            v_result_ = p_options_[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, v_local_header_)
            if v_result_ == 0:
                #// ----- Change the file status
                p_entry_["status"] = "skipped"
                v_result_ = 1
            # end if
            #// ----- Look for abort result
            if v_result_ == 2:
                #// ----- This status is internal and will be changed in 'skipped'
                p_entry_["status"] = "aborted"
                v_result_ = PCLZIP_ERR_USER_ABORTED
            # end if
            #// ----- Update the information
            #// Only some fields can be modified
            p_entry_["filename"] = v_local_header_["filename"]
        # end if
        #// ----- Trace
        #// ----- Look if extraction should be done
        if p_entry_["status"] == "ok":
            #// ----- Do the extraction (if not a folder)
            if (not p_entry_["external"] & 16 == 16):
                #// ----- Look for not compressed file
                if p_entry_["compressed_size"] == p_entry_["size"]:
                    #// ----- Read the file in a buffer (one shot)
                    v_buffer_ = php_no_error(lambda: fread(self.zip_fd, p_entry_["compressed_size"]))
                    #// ----- Send the file to the output
                    php_print(v_buffer_)
                    v_buffer_ = None
                else:
                    #// ----- Read the compressed file in a buffer (one shot)
                    v_buffer_ = php_no_error(lambda: fread(self.zip_fd, p_entry_["compressed_size"]))
                    #// ----- Decompress the file
                    v_file_content_ = gzinflate(v_buffer_)
                    v_buffer_ = None
                    #// ----- Send the file to the output
                    php_print(v_file_content_)
                    v_file_content_ = None
                # end if
            # end if
        # end if
        #// ----- Change abort status
        if p_entry_["status"] == "aborted":
            p_entry_["status"] = "skipped"
            #// ----- Look for post-extract callback
        elif (php_isset(lambda : p_options_[PCLZIP_CB_POST_EXTRACT])):
            #// ----- Generate a local information
            v_local_header_ = Array()
            self.privconvertheader2fileinfo(p_entry_, v_local_header_)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result_ = p_options_[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, v_local_header_)
            #// ----- Look for abort result
            if v_result_ == 2:
                v_result_ = PCLZIP_ERR_USER_ABORTED
            # end if
        # end if
        return v_result_
    # end def privextractfileinoutput
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privExtractFileAsString()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privextractfileasstring(self, p_entry_=None, p_string_=None, p_options_=None):
        
        
        v_result_ = 1
        #// ----- Read the file header
        v_header_ = Array()
        v_result_ = self.privreadfileheader(v_header_)
        if v_result_ != 1:
            #// ----- Return
            return v_result_
        # end if
        #// ----- Check that the file header is coherent with $p_entry info
        if self.privcheckfileheaders(v_header_, p_entry_) != 1:
            pass
        # end if
        #// ----- Look for pre-extract callback
        if (php_isset(lambda : p_options_[PCLZIP_CB_PRE_EXTRACT])):
            #// ----- Generate a local information
            v_local_header_ = Array()
            self.privconvertheader2fileinfo(p_entry_, v_local_header_)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result_ = p_options_[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, v_local_header_)
            if v_result_ == 0:
                #// ----- Change the file status
                p_entry_["status"] = "skipped"
                v_result_ = 1
            # end if
            #// ----- Look for abort result
            if v_result_ == 2:
                #// ----- This status is internal and will be changed in 'skipped'
                p_entry_["status"] = "aborted"
                v_result_ = PCLZIP_ERR_USER_ABORTED
            # end if
            #// ----- Update the information
            #// Only some fields can be modified
            p_entry_["filename"] = v_local_header_["filename"]
        # end if
        #// ----- Look if extraction should be done
        if p_entry_["status"] == "ok":
            #// ----- Do the extraction (if not a folder)
            if (not p_entry_["external"] & 16 == 16):
                #// ----- Look for not compressed file
                #// if ($p_entry['compressed_size'] == $p_entry['size'])
                if p_entry_["compression"] == 0:
                    #// ----- Reading the file
                    p_string_ = php_no_error(lambda: fread(self.zip_fd, p_entry_["compressed_size"]))
                else:
                    #// ----- Reading the file
                    v_data_ = php_no_error(lambda: fread(self.zip_fd, p_entry_["compressed_size"]))
                    #// ----- Decompress the file
                    p_string_ = php_no_error(lambda: gzinflate(v_data_))
                    if p_string_ == False:
                        pass
                    # end if
                # end if
                pass
            else:
                pass
            # end if
        # end if
        #// ----- Change abort status
        if p_entry_["status"] == "aborted":
            p_entry_["status"] = "skipped"
            #// ----- Look for post-extract callback
        elif (php_isset(lambda : p_options_[PCLZIP_CB_POST_EXTRACT])):
            #// ----- Generate a local information
            v_local_header_ = Array()
            self.privconvertheader2fileinfo(p_entry_, v_local_header_)
            #// ----- Swap the content to header
            v_local_header_["content"] = p_string_
            p_string_ = ""
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result_ = p_options_[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, v_local_header_)
            #// ----- Swap back the content to header
            p_string_ = v_local_header_["content"]
            v_local_header_["content"] = None
            #// ----- Look for abort result
            if v_result_ == 2:
                v_result_ = PCLZIP_ERR_USER_ABORTED
            # end if
        # end if
        #// ----- Return
        return v_result_
    # end def privextractfileasstring
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privReadFileHeader()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privreadfileheader(self, p_header_=None):
        
        
        v_result_ = 1
        #// ----- Read the 4 bytes signature
        v_binary_data_ = php_no_error(lambda: fread(self.zip_fd, 4))
        v_data_ = unpack("Vid", v_binary_data_)
        #// ----- Check signature
        if v_data_["id"] != 67324752:
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Invalid archive structure")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Read the first 42 bytes of the header
        v_binary_data_ = fread(self.zip_fd, 26)
        #// ----- Look for invalid block size
        if php_strlen(v_binary_data_) != 26:
            p_header_["filename"] = ""
            p_header_["status"] = "invalid_header"
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : " + php_strlen(v_binary_data_))
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Extract the values
        v_data_ = unpack("vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len", v_binary_data_)
        #// ----- Get filename
        p_header_["filename"] = fread(self.zip_fd, v_data_["filename_len"])
        #// ----- Get extra_fields
        if v_data_["extra_len"] != 0:
            p_header_["extra"] = fread(self.zip_fd, v_data_["extra_len"])
        else:
            p_header_["extra"] = ""
        # end if
        #// ----- Extract properties
        p_header_["version_extracted"] = v_data_["version"]
        p_header_["compression"] = v_data_["compression"]
        p_header_["size"] = v_data_["size"]
        p_header_["compressed_size"] = v_data_["compressed_size"]
        p_header_["crc"] = v_data_["crc"]
        p_header_["flag"] = v_data_["flag"]
        p_header_["filename_len"] = v_data_["filename_len"]
        #// ----- Recuperate date in UNIX format
        p_header_["mdate"] = v_data_["mdate"]
        p_header_["mtime"] = v_data_["mtime"]
        if p_header_["mdate"] and p_header_["mtime"]:
            #// ----- Extract time
            v_hour_ = p_header_["mtime"] & 63488 >> 11
            v_minute_ = p_header_["mtime"] & 2016 >> 5
            v_seconde_ = p_header_["mtime"] & 31 * 2
            #// ----- Extract date
            v_year_ = p_header_["mdate"] & 65024 >> 9 + 1980
            v_month_ = p_header_["mdate"] & 480 >> 5
            v_day_ = p_header_["mdate"] & 31
            #// ----- Get UNIX date format
            p_header_["mtime"] = php_no_error(lambda: mktime(v_hour_, v_minute_, v_seconde_, v_month_, v_day_, v_year_))
        else:
            p_header_["mtime"] = time()
        # end if
        #// TBC
        #// for(reset($v_data); $key = key($v_data); next($v_data)) {
        #// }
        #// ----- Set the stored filename
        p_header_["stored_filename"] = p_header_["filename"]
        #// ----- Set the status field
        p_header_["status"] = "ok"
        #// ----- Return
        return v_result_
    # end def privreadfileheader
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privReadCentralFileHeader()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privreadcentralfileheader(self, p_header_=None):
        
        
        v_result_ = 1
        #// ----- Read the 4 bytes signature
        v_binary_data_ = php_no_error(lambda: fread(self.zip_fd, 4))
        v_data_ = unpack("Vid", v_binary_data_)
        #// ----- Check signature
        if v_data_["id"] != 33639248:
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Invalid archive structure")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Read the first 42 bytes of the header
        v_binary_data_ = fread(self.zip_fd, 42)
        #// ----- Look for invalid block size
        if php_strlen(v_binary_data_) != 42:
            p_header_["filename"] = ""
            p_header_["status"] = "invalid_header"
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : " + php_strlen(v_binary_data_))
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Extract the values
        p_header_ = unpack("vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset", v_binary_data_)
        #// ----- Get filename
        if p_header_["filename_len"] != 0:
            p_header_["filename"] = fread(self.zip_fd, p_header_["filename_len"])
        else:
            p_header_["filename"] = ""
        # end if
        #// ----- Get extra
        if p_header_["extra_len"] != 0:
            p_header_["extra"] = fread(self.zip_fd, p_header_["extra_len"])
        else:
            p_header_["extra"] = ""
        # end if
        #// ----- Get comment
        if p_header_["comment_len"] != 0:
            p_header_["comment"] = fread(self.zip_fd, p_header_["comment_len"])
        else:
            p_header_["comment"] = ""
        # end if
        #// ----- Extract properties
        #// ----- Recuperate date in UNIX format
        #// if ($p_header['mdate'] && $p_header['mtime'])
        #// TBC : bug : this was ignoring time with 0/0/0
        if 1:
            #// ----- Extract time
            v_hour_ = p_header_["mtime"] & 63488 >> 11
            v_minute_ = p_header_["mtime"] & 2016 >> 5
            v_seconde_ = p_header_["mtime"] & 31 * 2
            #// ----- Extract date
            v_year_ = p_header_["mdate"] & 65024 >> 9 + 1980
            v_month_ = p_header_["mdate"] & 480 >> 5
            v_day_ = p_header_["mdate"] & 31
            #// ----- Get UNIX date format
            p_header_["mtime"] = php_no_error(lambda: mktime(v_hour_, v_minute_, v_seconde_, v_month_, v_day_, v_year_))
        else:
            p_header_["mtime"] = time()
        # end if
        #// ----- Set the stored filename
        p_header_["stored_filename"] = p_header_["filename"]
        #// ----- Set default status to ok
        p_header_["status"] = "ok"
        #// ----- Look if it is a directory
        if php_substr(p_header_["filename"], -1) == "/":
            #// $p_header['external'] = 0x41FF0010;
            p_header_["external"] = 16
        # end if
        #// ----- Return
        return v_result_
    # end def privreadcentralfileheader
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privCheckFileHeaders()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// 1 on success,
    #// 0 on error;
    #// --------------------------------------------------------------------------------
    def privcheckfileheaders(self, p_local_header_=None, p_central_header_=None):
        
        
        v_result_ = 1
        #// ----- Check the static values
        #// TBC
        if p_local_header_["filename"] != p_central_header_["filename"]:
            pass
        # end if
        if p_local_header_["version_extracted"] != p_central_header_["version_extracted"]:
            pass
        # end if
        if p_local_header_["flag"] != p_central_header_["flag"]:
            pass
        # end if
        if p_local_header_["compression"] != p_central_header_["compression"]:
            pass
        # end if
        if p_local_header_["mtime"] != p_central_header_["mtime"]:
            pass
        # end if
        if p_local_header_["filename_len"] != p_central_header_["filename_len"]:
            pass
        # end if
        #// ----- Look for flag bit 3
        if p_local_header_["flag"] & 8 == 8:
            p_local_header_["size"] = p_central_header_["size"]
            p_local_header_["compressed_size"] = p_central_header_["compressed_size"]
            p_local_header_["crc"] = p_central_header_["crc"]
        # end if
        #// ----- Return
        return v_result_
    # end def privcheckfileheaders
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privReadEndCentralDir()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privreadendcentraldir(self, p_central_dir_=None):
        
        
        v_result_ = 1
        #// ----- Go to the end of the zip file
        v_size_ = filesize(self.zipname)
        php_no_error(lambda: fseek(self.zip_fd, v_size_))
        if php_no_error(lambda: ftell(self.zip_fd)) != v_size_:
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Unable to go to the end of the archive '" + self.zipname + "'")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- First try : look if this is an archive with no commentaries (most of the time)
        #// in this case the end of central dir is at 22 bytes of the file end
        v_found_ = 0
        if v_size_ > 26:
            php_no_error(lambda: fseek(self.zip_fd, v_size_ - 22))
            v_pos_ = php_no_error(lambda: ftell(self.zip_fd))
            if v_pos_ != v_size_ - 22:
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Unable to seek back to the middle of the archive '" + self.zipname + "'")
                #// ----- Return
                return PclZip.errorcode()
            # end if
            #// ----- Read for bytes
            v_binary_data_ = php_no_error(lambda: fread(self.zip_fd, 4))
            v_data_ = php_no_error(lambda: unpack("Vid", v_binary_data_))
            #// ----- Check signature
            if v_data_["id"] == 101010256:
                v_found_ = 1
            # end if
            v_pos_ = ftell(self.zip_fd)
        # end if
        #// ----- Go back to the maximum possible size of the Central Dir End Record
        if (not v_found_):
            v_maximum_size_ = 65557
            #// 0xFFFF + 22;
            if v_maximum_size_ > v_size_:
                v_maximum_size_ = v_size_
            # end if
            php_no_error(lambda: fseek(self.zip_fd, v_size_ - v_maximum_size_))
            if php_no_error(lambda: ftell(self.zip_fd)) != v_size_ - v_maximum_size_:
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Unable to seek back to the middle of the archive '" + self.zipname + "'")
                #// ----- Return
                return PclZip.errorcode()
            # end if
            #// ----- Read byte per byte in order to find the signature
            v_pos_ = ftell(self.zip_fd)
            v_bytes_ = 0
            while True:
                
                if not (v_pos_ < v_size_):
                    break
                # end if
                #// ----- Read a byte
                v_byte_ = php_no_error(lambda: fread(self.zip_fd, 1))
                #// -----  Add the byte
                #// $v_bytes = ($v_bytes << 8) | Ord($v_byte);
                #// Note we mask the old value down such that once shifted we can never end up with more than a 32bit number
                #// Otherwise on systems where we have 64bit integers the check below for the magic number will fail.
                v_bytes_ = v_bytes_ & 16777215 << 8 | Ord(v_byte_)
                #// ----- Compare the bytes
                if v_bytes_ == 1347093766:
                    v_pos_ += 1
                    break
                # end if
                v_pos_ += 1
            # end while
            #// ----- Look if not found end of central dir
            if v_pos_ == v_size_:
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Unable to find End of Central Dir Record signature")
                #// ----- Return
                return PclZip.errorcode()
            # end if
        # end if
        #// ----- Read the first 18 bytes of the header
        v_binary_data_ = fread(self.zip_fd, 18)
        #// ----- Look for invalid block size
        if php_strlen(v_binary_data_) != 18:
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Invalid End of Central Dir Record size : " + php_strlen(v_binary_data_))
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Extract the values
        v_data_ = unpack("vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size", v_binary_data_)
        #// ----- Check the global size
        if v_pos_ + v_data_["comment_size"] + 18 != v_size_:
            #// ----- Removed in release 2.2 see readme file
            #// The check of the file size is a little too strict.
            #// Some bugs where found when a zip is encrypted/decrypted with 'crypt'.
            #// While decrypted, zip has training 0 bytes
            if 0:
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "The central dir is not at the end of the archive." + " Some trailing bytes exists after the archive.")
                #// ----- Return
                return PclZip.errorcode()
            # end if
        # end if
        #// ----- Get comment
        if v_data_["comment_size"] != 0:
            p_central_dir_["comment"] = fread(self.zip_fd, v_data_["comment_size"])
        else:
            p_central_dir_["comment"] = ""
        # end if
        p_central_dir_["entries"] = v_data_["entries"]
        p_central_dir_["disk_entries"] = v_data_["disk_entries"]
        p_central_dir_["offset"] = v_data_["offset"]
        p_central_dir_["size"] = v_data_["size"]
        p_central_dir_["disk"] = v_data_["disk"]
        p_central_dir_["disk_start"] = v_data_["disk_start"]
        #// TBC
        #// for(reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {
        #// }
        #// ----- Return
        return v_result_
    # end def privreadendcentraldir
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privDeleteByRule()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privdeletebyrule(self, p_result_list_=None, p_options_=None):
        
        
        v_result_ = 1
        v_list_detail_ = Array()
        #// ----- Open the zip file
        v_result_ = self.privopenfd("rb")
        if v_result_ != 1:
            #// ----- Return
            return v_result_
        # end if
        #// ----- Read the central directory information
        v_central_dir_ = Array()
        v_result_ = self.privreadendcentraldir(v_central_dir_)
        if v_result_ != 1:
            self.privclosefd()
            return v_result_
        # end if
        #// ----- Go to beginning of File
        php_no_error(lambda: rewind(self.zip_fd))
        #// ----- Scan all the files
        #// ----- Start at beginning of Central Dir
        v_pos_entry_ = v_central_dir_["offset"]
        php_no_error(lambda: rewind(self.zip_fd))
        if php_no_error(lambda: fseek(self.zip_fd, v_pos_entry_)):
            #// ----- Close the zip file
            self.privclosefd()
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, "Invalid archive size")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Read each entry
        v_header_list_ = Array()
        j_start_ = 0
        i_ = 0
        v_nb_extracted_ = 0
        while i_ < v_central_dir_["entries"]:
            
            #// ----- Read the file header
            v_header_list_[v_nb_extracted_] = Array()
            v_result_ = self.privreadcentralfileheader(v_header_list_[v_nb_extracted_])
            if v_result_ != 1:
                #// ----- Close the zip file
                self.privclosefd()
                return v_result_
            # end if
            #// ----- Store the index
            v_header_list_[v_nb_extracted_]["index"] = i_
            #// ----- Look for the specific extract rules
            v_found_ = False
            #// ----- Look for extract by name rule
            if (php_isset(lambda : p_options_[PCLZIP_OPT_BY_NAME])) and p_options_[PCLZIP_OPT_BY_NAME] != 0:
                #// ----- Look if the filename is in the list
                j_ = 0
                while j_ < sizeof(p_options_[PCLZIP_OPT_BY_NAME]) and (not v_found_):
                    
                    #// ----- Look for a directory
                    if php_substr(p_options_[PCLZIP_OPT_BY_NAME][j_], -1) == "/":
                        #// ----- Look if the directory is in the filename path
                        if php_strlen(v_header_list_[v_nb_extracted_]["stored_filename"]) > php_strlen(p_options_[PCLZIP_OPT_BY_NAME][j_]) and php_substr(v_header_list_[v_nb_extracted_]["stored_filename"], 0, php_strlen(p_options_[PCLZIP_OPT_BY_NAME][j_])) == p_options_[PCLZIP_OPT_BY_NAME][j_]:
                            v_found_ = True
                        elif v_header_list_[v_nb_extracted_]["external"] & 16 == 16 and v_header_list_[v_nb_extracted_]["stored_filename"] + "/" == p_options_[PCLZIP_OPT_BY_NAME][j_]:
                            v_found_ = True
                        # end if
                        #// ----- Look for a filename
                    elif v_header_list_[v_nb_extracted_]["stored_filename"] == p_options_[PCLZIP_OPT_BY_NAME][j_]:
                        v_found_ = True
                    # end if
                    j_ += 1
                # end while
            else:
                if (php_isset(lambda : p_options_[PCLZIP_OPT_BY_PREG])) and p_options_[PCLZIP_OPT_BY_PREG] != "":
                    if php_preg_match(p_options_[PCLZIP_OPT_BY_PREG], v_header_list_[v_nb_extracted_]["stored_filename"]):
                        v_found_ = True
                    # end if
                else:
                    if (php_isset(lambda : p_options_[PCLZIP_OPT_BY_INDEX])) and p_options_[PCLZIP_OPT_BY_INDEX] != 0:
                        #// ----- Look if the index is in the list
                        j_ = j_start_
                        while j_ < sizeof(p_options_[PCLZIP_OPT_BY_INDEX]) and (not v_found_):
                            
                            if i_ >= p_options_[PCLZIP_OPT_BY_INDEX][j_]["start"] and i_ <= p_options_[PCLZIP_OPT_BY_INDEX][j_]["end"]:
                                v_found_ = True
                            # end if
                            if i_ >= p_options_[PCLZIP_OPT_BY_INDEX][j_]["end"]:
                                j_start_ = j_ + 1
                            # end if
                            if p_options_[PCLZIP_OPT_BY_INDEX][j_]["start"] > i_:
                                break
                            # end if
                            j_ += 1
                        # end while
                    else:
                        v_found_ = True
                    # end if
                # end if
            # end if
            #// ----- Look for deletion
            if v_found_:
                v_header_list_[v_nb_extracted_] = None
            else:
                v_nb_extracted_ += 1
            # end if
            i_ += 1
        # end while
        #// ----- Look if something need to be deleted
        if v_nb_extracted_ > 0:
            #// ----- Creates a temporary file
            v_zip_temp_name_ = PCLZIP_TEMPORARY_DIR + uniqid("pclzip-") + ".tmp"
            #// ----- Creates a temporary zip archive
            v_temp_zip_ = php_new_class("PclZip", lambda : PclZip(v_zip_temp_name_))
            #// ----- Open the temporary zip file in write mode
            v_result_ = v_temp_zip_.privopenfd("wb")
            if v_result_ != 1:
                self.privclosefd()
                #// ----- Return
                return v_result_
            # end if
            #// ----- Look which file need to be kept
            i_ = 0
            while i_ < sizeof(v_header_list_):
                
                #// ----- Calculate the position of the header
                php_no_error(lambda: rewind(self.zip_fd))
                if php_no_error(lambda: fseek(self.zip_fd, v_header_list_[i_]["offset"])):
                    #// ----- Close the zip file
                    self.privclosefd()
                    v_temp_zip_.privclosefd()
                    php_no_error(lambda: unlink(v_zip_temp_name_))
                    #// ----- Error log
                    PclZip.priverrorlog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, "Invalid archive size")
                    #// ----- Return
                    return PclZip.errorcode()
                # end if
                #// ----- Read the file header
                v_local_header_ = Array()
                v_result_ = self.privreadfileheader(v_local_header_)
                if v_result_ != 1:
                    #// ----- Close the zip file
                    self.privclosefd()
                    v_temp_zip_.privclosefd()
                    php_no_error(lambda: unlink(v_zip_temp_name_))
                    #// ----- Return
                    return v_result_
                # end if
                #// ----- Check that local file header is same as central file header
                if self.privcheckfileheaders(v_local_header_, v_header_list_[i_]) != 1:
                    pass
                # end if
                v_local_header_ = None
                #// ----- Write the file header
                v_result_ = v_temp_zip_.privwritefileheader(v_header_list_[i_])
                if v_result_ != 1:
                    #// ----- Close the zip file
                    self.privclosefd()
                    v_temp_zip_.privclosefd()
                    php_no_error(lambda: unlink(v_zip_temp_name_))
                    #// ----- Return
                    return v_result_
                # end if
                #// ----- Read/write the data block
                v_result_ = PclZipUtilCopyBlock(self.zip_fd, v_temp_zip_.zip_fd, v_header_list_[i_]["compressed_size"])
                if v_result_ != 1:
                    #// ----- Close the zip file
                    self.privclosefd()
                    v_temp_zip_.privclosefd()
                    php_no_error(lambda: unlink(v_zip_temp_name_))
                    #// ----- Return
                    return v_result_
                # end if
                i_ += 1
            # end while
            #// ----- Store the offset of the central dir
            v_offset_ = php_no_error(lambda: ftell(v_temp_zip_.zip_fd))
            #// ----- Re-Create the Central Dir files header
            i_ = 0
            while i_ < sizeof(v_header_list_):
                
                #// ----- Create the file header
                v_result_ = v_temp_zip_.privwritecentralfileheader(v_header_list_[i_])
                if v_result_ != 1:
                    v_temp_zip_.privclosefd()
                    self.privclosefd()
                    php_no_error(lambda: unlink(v_zip_temp_name_))
                    #// ----- Return
                    return v_result_
                # end if
                #// ----- Transform the header to a 'usable' info
                v_temp_zip_.privconvertheader2fileinfo(v_header_list_[i_], p_result_list_[i_])
                i_ += 1
            # end while
            #// ----- Zip file comment
            v_comment_ = ""
            if (php_isset(lambda : p_options_[PCLZIP_OPT_COMMENT])):
                v_comment_ = p_options_[PCLZIP_OPT_COMMENT]
            # end if
            #// ----- Calculate the size of the central header
            v_size_ = php_no_error(lambda: ftell(v_temp_zip_.zip_fd)) - v_offset_
            #// ----- Create the central dir footer
            v_result_ = v_temp_zip_.privwritecentralheader(sizeof(v_header_list_), v_size_, v_offset_, v_comment_)
            if v_result_ != 1:
                v_header_list_ = None
                v_temp_zip_.privclosefd()
                self.privclosefd()
                php_no_error(lambda: unlink(v_zip_temp_name_))
                #// ----- Return
                return v_result_
            # end if
            #// ----- Close
            v_temp_zip_.privclosefd()
            self.privclosefd()
            #// ----- Delete the zip file
            #// TBC : I should test the result ...
            php_no_error(lambda: unlink(self.zipname))
            #// ----- Rename the temporary file
            #// TBC : I should test the result ...
            #// @rename($v_zip_temp_name, $this->zipname);
            PclZipUtilRename(v_zip_temp_name_, self.zipname)
            v_temp_zip_ = None
        else:
            if v_central_dir_["entries"] != 0:
                self.privclosefd()
                v_result_ = self.privopenfd("wb")
                if v_result_ != 1:
                    return v_result_
                # end if
                v_result_ = self.privwritecentralheader(0, 0, 0, "")
                if v_result_ != 1:
                    return v_result_
                # end if
                self.privclosefd()
            # end if
        # end if
        #// ----- Return
        return v_result_
    # end def privdeletebyrule
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privDirCheck()
    #// Description :
    #// Check if a directory exists, if not it creates it and all the parents directory
    #// which may be useful.
    #// Parameters :
    #// $p_dir : Directory path to check.
    #// Return Values :
    #// 1 : OK
    #// -1 : Unable to create directory
    #// --------------------------------------------------------------------------------
    def privdircheck(self, p_dir_=None, p_is_dir_=None):
        if p_is_dir_ is None:
            p_is_dir_ = False
        # end if
        
        v_result_ = 1
        #// ----- Remove the final '/'
        if p_is_dir_ and php_substr(p_dir_, -1) == "/":
            p_dir_ = php_substr(p_dir_, 0, php_strlen(p_dir_) - 1)
        # end if
        #// ----- Check the directory availability
        if php_is_dir(p_dir_) or p_dir_ == "":
            return 1
        # end if
        #// ----- Extract parent directory
        p_parent_dir_ = php_dirname(p_dir_)
        #// ----- Just a check
        if p_parent_dir_ != p_dir_:
            #// ----- Look for parent directory
            if p_parent_dir_ != "":
                v_result_ = self.privdircheck(p_parent_dir_)
                if v_result_ != 1:
                    return v_result_
                # end if
            # end if
        # end if
        #// ----- Create the directory
        if (not php_no_error(lambda: mkdir(p_dir_, 511))):
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_DIR_CREATE_FAIL, str("Unable to create directory '") + str(p_dir_) + str("'"))
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Return
        return v_result_
    # end def privdircheck
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privMerge()
    #// Description :
    #// If $p_archive_to_add does not exist, the function exit with a success result.
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privmerge(self, p_archive_to_add_=None):
        
        
        v_result_ = 1
        #// ----- Look if the archive_to_add exists
        if (not php_is_file(p_archive_to_add_.zipname)):
            #// ----- Nothing to merge, so merge is a success
            v_result_ = 1
            #// ----- Return
            return v_result_
        # end if
        #// ----- Look if the archive exists
        if (not php_is_file(self.zipname)):
            #// ----- Do a duplicate
            v_result_ = self.privduplicate(p_archive_to_add_.zipname)
            #// ----- Return
            return v_result_
        # end if
        #// ----- Open the zip file
        v_result_ = self.privopenfd("rb")
        if v_result_ != 1:
            #// ----- Return
            return v_result_
        # end if
        #// ----- Read the central directory information
        v_central_dir_ = Array()
        v_result_ = self.privreadendcentraldir(v_central_dir_)
        if v_result_ != 1:
            self.privclosefd()
            return v_result_
        # end if
        #// ----- Go to beginning of File
        php_no_error(lambda: rewind(self.zip_fd))
        #// ----- Open the archive_to_add file
        v_result_ = p_archive_to_add_.privopenfd("rb")
        if v_result_ != 1:
            self.privclosefd()
            #// ----- Return
            return v_result_
        # end if
        #// ----- Read the central directory information
        v_central_dir_to_add_ = Array()
        v_result_ = p_archive_to_add_.privreadendcentraldir(v_central_dir_to_add_)
        if v_result_ != 1:
            self.privclosefd()
            p_archive_to_add_.privclosefd()
            return v_result_
        # end if
        #// ----- Go to beginning of File
        php_no_error(lambda: rewind(p_archive_to_add_.zip_fd))
        #// ----- Creates a temporary file
        v_zip_temp_name_ = PCLZIP_TEMPORARY_DIR + uniqid("pclzip-") + ".tmp"
        #// ----- Open the temporary file in write mode
        v_zip_temp_fd_ = php_no_error(lambda: fopen(v_zip_temp_name_, "wb"))
        if v_zip_temp_fd_ == 0:
            self.privclosefd()
            p_archive_to_add_.privclosefd()
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open temporary file '" + v_zip_temp_name_ + "' in binary write mode")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Copy the files from the archive to the temporary file
        #// TBC : Here I should better append the file and go back to erase the central dir
        v_size_ = v_central_dir_["offset"]
        while True:
            
            if not (v_size_ != 0):
                break
            # end if
            v_read_size_ = v_size_ if v_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer_ = fread(self.zip_fd, v_read_size_)
            php_no_error(lambda: fwrite(v_zip_temp_fd_, v_buffer_, v_read_size_))
            v_size_ -= v_read_size_
        # end while
        #// ----- Copy the files from the archive_to_add into the temporary file
        v_size_ = v_central_dir_to_add_["offset"]
        while True:
            
            if not (v_size_ != 0):
                break
            # end if
            v_read_size_ = v_size_ if v_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer_ = fread(p_archive_to_add_.zip_fd, v_read_size_)
            php_no_error(lambda: fwrite(v_zip_temp_fd_, v_buffer_, v_read_size_))
            v_size_ -= v_read_size_
        # end while
        #// ----- Store the offset of the central dir
        v_offset_ = php_no_error(lambda: ftell(v_zip_temp_fd_))
        #// ----- Copy the block of file headers from the old archive
        v_size_ = v_central_dir_["size"]
        while True:
            
            if not (v_size_ != 0):
                break
            # end if
            v_read_size_ = v_size_ if v_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer_ = php_no_error(lambda: fread(self.zip_fd, v_read_size_))
            php_no_error(lambda: fwrite(v_zip_temp_fd_, v_buffer_, v_read_size_))
            v_size_ -= v_read_size_
        # end while
        #// ----- Copy the block of file headers from the archive_to_add
        v_size_ = v_central_dir_to_add_["size"]
        while True:
            
            if not (v_size_ != 0):
                break
            # end if
            v_read_size_ = v_size_ if v_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer_ = php_no_error(lambda: fread(p_archive_to_add_.zip_fd, v_read_size_))
            php_no_error(lambda: fwrite(v_zip_temp_fd_, v_buffer_, v_read_size_))
            v_size_ -= v_read_size_
        # end while
        #// ----- Merge the file comments
        v_comment_ = v_central_dir_["comment"] + " " + v_central_dir_to_add_["comment"]
        #// ----- Calculate the size of the (new) central header
        v_size_ = php_no_error(lambda: ftell(v_zip_temp_fd_)) - v_offset_
        #// ----- Swap the file descriptor
        #// Here is a trick : I swap the temporary fd with the zip fd, in order to use
        #// the following methods on the temporary fil and not the real archive fd
        v_swap_ = self.zip_fd
        self.zip_fd = v_zip_temp_fd_
        v_zip_temp_fd_ = v_swap_
        #// ----- Create the central dir footer
        v_result_ = self.privwritecentralheader(v_central_dir_["entries"] + v_central_dir_to_add_["entries"], v_size_, v_offset_, v_comment_)
        if v_result_ != 1:
            self.privclosefd()
            p_archive_to_add_.privclosefd()
            php_no_error(lambda: php_fclose(v_zip_temp_fd_))
            self.zip_fd = None
            v_header_list_ = None
            #// ----- Return
            return v_result_
        # end if
        #// ----- Swap back the file descriptor
        v_swap_ = self.zip_fd
        self.zip_fd = v_zip_temp_fd_
        v_zip_temp_fd_ = v_swap_
        #// ----- Close
        self.privclosefd()
        p_archive_to_add_.privclosefd()
        #// ----- Close the temporary file
        php_no_error(lambda: php_fclose(v_zip_temp_fd_))
        #// ----- Delete the zip file
        #// TBC : I should test the result ...
        php_no_error(lambda: unlink(self.zipname))
        #// ----- Rename the temporary file
        #// TBC : I should test the result ...
        #// @rename($v_zip_temp_name, $this->zipname);
        PclZipUtilRename(v_zip_temp_name_, self.zipname)
        #// ----- Return
        return v_result_
    # end def privmerge
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privDuplicate()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privduplicate(self, p_archive_filename_=None):
        
        
        v_result_ = 1
        #// ----- Look if the $p_archive_filename exists
        if (not php_is_file(p_archive_filename_)):
            #// ----- Nothing to duplicate, so duplicate is a success.
            v_result_ = 1
            #// ----- Return
            return v_result_
        # end if
        #// ----- Open the zip file
        v_result_ = self.privopenfd("wb")
        if v_result_ != 1:
            #// ----- Return
            return v_result_
        # end if
        #// ----- Open the temporary file in write mode
        v_zip_temp_fd_ = php_no_error(lambda: fopen(p_archive_filename_, "rb"))
        if v_zip_temp_fd_ == 0:
            self.privclosefd()
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open archive file '" + p_archive_filename_ + "' in binary write mode")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Copy the files from the archive to the temporary file
        #// TBC : Here I should better append the file and go back to erase the central dir
        v_size_ = filesize(p_archive_filename_)
        while True:
            
            if not (v_size_ != 0):
                break
            # end if
            v_read_size_ = v_size_ if v_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer_ = fread(v_zip_temp_fd_, v_read_size_)
            php_no_error(lambda: fwrite(self.zip_fd, v_buffer_, v_read_size_))
            v_size_ -= v_read_size_
        # end while
        #// ----- Close
        self.privclosefd()
        #// ----- Close the temporary file
        php_no_error(lambda: php_fclose(v_zip_temp_fd_))
        #// ----- Return
        return v_result_
    # end def privduplicate
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privErrorLog()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def priverrorlog(self, p_error_code_=0, p_error_string_=""):
        
        
        if PCLZIP_ERROR_EXTERNAL == 1:
            PclError(p_error_code_, p_error_string_)
        else:
            self.error_code = p_error_code_
            self.error_string = p_error_string_
        # end if
    # end def priverrorlog
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privErrorReset()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def priverrorreset(self):
        
        
        if PCLZIP_ERROR_EXTERNAL == 1:
            PclErrorReset()
        else:
            self.error_code = 0
            self.error_string = ""
        # end if
    # end def priverrorreset
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privDisableMagicQuotes()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privdisablemagicquotes(self):
        
        
        v_result_ = 1
        #// EDIT for WordPress 5.3.0
        #// magic_quote functions are deprecated in PHP 7.4, now assuming it's always off.
        #// 
        #// ----- Look if function exists
        #// if (   (!function_exists("get_magic_quotes_runtime"))
        #// || (!function_exists("set_magic_quotes_runtime"))) {
        #// return $v_result;
        #// }
        #// ----- Look if already done
        #// if ($this->magic_quotes_status != -1) {
        #// return $v_result;
        #// }
        #// ----- Get and memorize the magic_quote value
        #// $this->magic_quotes_status = @get_magic_quotes_runtime();
        #// ----- Disable magic_quotes
        #// if ($this->magic_quotes_status == 1) {
        #// @set_magic_quotes_runtime(0);
        #// }
        #// 
        #// ----- Return
        return v_result_
    # end def privdisablemagicquotes
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privSwapBackMagicQuotes()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privswapbackmagicquotes(self):
        
        
        v_result_ = 1
        #// EDIT for WordPress 5.3.0
        #// magic_quote functions are deprecated in PHP 7.4, now assuming it's always off.
        #// 
        #// ----- Look if function exists
        #// if (   (!function_exists("get_magic_quotes_runtime"))
        #// || (!function_exists("set_magic_quotes_runtime"))) {
        #// return $v_result;
        #// }
        #// ----- Look if something to do
        #// if ($this->magic_quotes_status != -1) {
        #// return $v_result;
        #// }
        #// ----- Swap back magic_quotes
        #// if ($this->magic_quotes_status == 1) {
        #// @set_magic_quotes_runtime($this->magic_quotes_status);
        #// }
        #// 
        #// ----- Return
        return v_result_
    # end def privswapbackmagicquotes
    pass
# end class PclZip
#// End of class
#// --------------------------------------------------------------------------------
#// --------------------------------------------------------------------------------
#// Function : PclZipUtilPathReduction()
#// Description :
#// Parameters :
#// Return Values :
#// --------------------------------------------------------------------------------
def PclZipUtilPathReduction(p_dir_=None, *_args_):
    
    
    v_result_ = ""
    #// ----- Look for not empty path
    if p_dir_ != "":
        #// ----- Explode path by directory names
        v_list_ = php_explode("/", p_dir_)
        #// ----- Study directories from last to first
        v_skip_ = 0
        i_ = sizeof(v_list_) - 1
        while i_ >= 0:
            
            #// ----- Look for current path
            if v_list_[i_] == ".":
                pass
            else:
                if v_list_[i_] == "..":
                    v_skip_ += 1
                else:
                    if v_list_[i_] == "":
                        #// ----- First '/' i.e. root slash
                        if i_ == 0:
                            v_result_ = "/" + v_result_
                            if v_skip_ > 0:
                                #// ----- It is an invalid path, so the path is not modified
                                #// TBC
                                v_result_ = p_dir_
                                v_skip_ = 0
                            # end if
                        else:
                            if i_ == sizeof(v_list_) - 1:
                                v_result_ = v_list_[i_]
                            else:
                                pass
                            # end if
                        # end if
                    else:
                        #// ----- Look for item to skip
                        if v_skip_ > 0:
                            v_skip_ -= 1
                        else:
                            v_result_ = v_list_[i_] + "/" + v_result_ if i_ != sizeof(v_list_) - 1 else ""
                        # end if
                    # end if
                # end if
            # end if
            i_ -= 1
        # end while
        #// ----- Look for skip
        if v_skip_ > 0:
            while True:
                
                if not (v_skip_ > 0):
                    break
                # end if
                v_result_ = "../" + v_result_
                v_skip_ -= 1
            # end while
        # end if
    # end if
    #// ----- Return
    return v_result_
# end def PclZipUtilPathReduction
#// --------------------------------------------------------------------------------
#// --------------------------------------------------------------------------------
#// Function : PclZipUtilPathInclusion()
#// Description :
#// This function indicates if the path $p_path is under the $p_dir tree. Or,
#// said in an other way, if the file or sub-dir $p_path is inside the dir
#// $p_dir.
#// The function indicates also if the path is exactly the same as the dir.
#// This function supports path with duplicated '/' like '//', but does not
#// support '.' or '..' statements.
#// Parameters :
#// Return Values :
#// 0 if $p_path is not inside directory $p_dir
#// 1 if $p_path is inside directory $p_dir
#// 2 if $p_path is exactly the same as $p_dir
#// --------------------------------------------------------------------------------
def PclZipUtilPathInclusion(p_dir_=None, p_path_=None, *_args_):
    
    
    v_result_ = 1
    #// ----- Look for path beginning by .
    if p_dir_ == "." or php_strlen(p_dir_) >= 2 and php_substr(p_dir_, 0, 2) == "./":
        p_dir_ = PclZipUtilTranslateWinPath(php_getcwd(), False) + "/" + php_substr(p_dir_, 1)
    # end if
    if p_path_ == "." or php_strlen(p_path_) >= 2 and php_substr(p_path_, 0, 2) == "./":
        p_path_ = PclZipUtilTranslateWinPath(php_getcwd(), False) + "/" + php_substr(p_path_, 1)
    # end if
    #// ----- Explode dir and path by directory separator
    v_list_dir_ = php_explode("/", p_dir_)
    v_list_dir_size_ = sizeof(v_list_dir_)
    v_list_path_ = php_explode("/", p_path_)
    v_list_path_size_ = sizeof(v_list_path_)
    #// ----- Study directories paths
    i_ = 0
    j_ = 0
    while True:
        
        if not (i_ < v_list_dir_size_ and j_ < v_list_path_size_ and v_result_):
            break
        # end if
        #// ----- Look for empty dir (path reduction)
        if v_list_dir_[i_] == "":
            i_ += 1
            continue
        # end if
        if v_list_path_[j_] == "":
            j_ += 1
            continue
        # end if
        #// ----- Compare the items
        if v_list_dir_[i_] != v_list_path_[j_] and v_list_dir_[i_] != "" and v_list_path_[j_] != "":
            v_result_ = 0
        # end if
        #// ----- Next items
        i_ += 1
        j_ += 1
    # end while
    #// ----- Look if everything seems to be the same
    if v_result_:
        #// ----- Skip all the empty items
        while True:
            
            if not (j_ < v_list_path_size_ and v_list_path_[j_] == ""):
                break
            # end if
            j_ += 1
        # end while
        while True:
            
            if not (i_ < v_list_dir_size_ and v_list_dir_[i_] == ""):
                break
            # end if
            i_ += 1
        # end while
        if i_ >= v_list_dir_size_ and j_ >= v_list_path_size_:
            #// ----- There are exactly the same
            v_result_ = 2
        else:
            if i_ < v_list_dir_size_:
                #// ----- The path is shorter than the dir
                v_result_ = 0
            # end if
        # end if
    # end if
    #// ----- Return
    return v_result_
# end def PclZipUtilPathInclusion
#// --------------------------------------------------------------------------------
#// --------------------------------------------------------------------------------
#// Function : PclZipUtilCopyBlock()
#// Description :
#// Parameters :
#// $p_mode : read/write compression mode
#// 0 : src & dest normal
#// 1 : src gzip, dest normal
#// 2 : src normal, dest gzip
#// 3 : src & dest gzip
#// Return Values :
#// --------------------------------------------------------------------------------
def PclZipUtilCopyBlock(p_src_=None, p_dest_=None, p_size_=None, p_mode_=0, *_args_):
    
    
    v_result_ = 1
    if p_mode_ == 0:
        while True:
            
            if not (p_size_ != 0):
                break
            # end if
            v_read_size_ = p_size_ if p_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer_ = php_no_error(lambda: fread(p_src_, v_read_size_))
            php_no_error(lambda: fwrite(p_dest_, v_buffer_, v_read_size_))
            p_size_ -= v_read_size_
        # end while
    else:
        if p_mode_ == 1:
            while True:
                
                if not (p_size_ != 0):
                    break
                # end if
                v_read_size_ = p_size_ if p_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
                v_buffer_ = php_no_error(lambda: gzread(p_src_, v_read_size_))
                php_no_error(lambda: fwrite(p_dest_, v_buffer_, v_read_size_))
                p_size_ -= v_read_size_
            # end while
        else:
            if p_mode_ == 2:
                while True:
                    
                    if not (p_size_ != 0):
                        break
                    # end if
                    v_read_size_ = p_size_ if p_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
                    v_buffer_ = php_no_error(lambda: fread(p_src_, v_read_size_))
                    php_no_error(lambda: gzwrite(p_dest_, v_buffer_, v_read_size_))
                    p_size_ -= v_read_size_
                # end while
            else:
                if p_mode_ == 3:
                    while True:
                        
                        if not (p_size_ != 0):
                            break
                        # end if
                        v_read_size_ = p_size_ if p_size_ < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
                        v_buffer_ = php_no_error(lambda: gzread(p_src_, v_read_size_))
                        php_no_error(lambda: gzwrite(p_dest_, v_buffer_, v_read_size_))
                        p_size_ -= v_read_size_
                    # end while
                # end if
            # end if
        # end if
    # end if
    #// ----- Return
    return v_result_
# end def PclZipUtilCopyBlock
#// --------------------------------------------------------------------------------
#// --------------------------------------------------------------------------------
#// Function : PclZipUtilRename()
#// Description :
#// This function tries to do a simple rename() function. If it fails, it
#// tries to copy the $p_src file in a new $p_dest file and then unlink the
#// first one.
#// Parameters :
#// $p_src : Old filename
#// $p_dest : New filename
#// Return Values :
#// 1 on success, 0 on failure.
#// --------------------------------------------------------------------------------
def PclZipUtilRename(p_src_=None, p_dest_=None, *_args_):
    
    
    v_result_ = 1
    #// ----- Try to rename the files
    if (not php_no_error(lambda: rename(p_src_, p_dest_))):
        #// ----- Try to copy & unlink the src
        if (not php_no_error(lambda: copy(p_src_, p_dest_))):
            v_result_ = 0
        else:
            if (not php_no_error(lambda: unlink(p_src_))):
                v_result_ = 0
            # end if
        # end if
    # end if
    #// ----- Return
    return v_result_
# end def PclZipUtilRename
#// --------------------------------------------------------------------------------
#// --------------------------------------------------------------------------------
#// Function : PclZipUtilOptionText()
#// Description :
#// Translate option value in text. Mainly for debug purpose.
#// Parameters :
#// $p_option : the option value.
#// Return Values :
#// The option text value.
#// --------------------------------------------------------------------------------
def PclZipUtilOptionText(p_option_=None, *_args_):
    
    
    v_list_ = get_defined_constants()
    reset(v_list_)
    while v_key_:
        v_key_ = key(v_list_)
        v_prefix_ = php_substr(v_key_, 0, 10)
        if v_prefix_ == "PCLZIP_OPT" or v_prefix_ == "PCLZIP_CB_" or v_prefix_ == "PCLZIP_ATT" and v_list_[v_key_] == p_option_:
            return v_key_
        # end if
        next(v_list_)
    # end while
    v_result_ = "Unknown"
    return v_result_
# end def PclZipUtilOptionText
#// --------------------------------------------------------------------------------
#// --------------------------------------------------------------------------------
#// Function : PclZipUtilTranslateWinPath()
#// Description :
#// Translate windows path by replacing '\' by '/' and optionally removing
#// drive letter.
#// Parameters :
#// $p_path : path to translate.
#// $p_remove_disk_letter : true | false
#// Return Values :
#// The path translated.
#// --------------------------------------------------------------------------------
def PclZipUtilTranslateWinPath(p_path_=None, p_remove_disk_letter_=None, *_args_):
    if p_remove_disk_letter_ is None:
        p_remove_disk_letter_ = True
    # end if
    
    if php_stristr(php_uname(), "windows"):
        #// ----- Look for potential disk letter
        v_position_ = php_strpos(p_path_, ":")
        if p_remove_disk_letter_ and v_position_ != False:
            p_path_ = php_substr(p_path_, v_position_ + 1)
        # end if
        #// ----- Change potential windows directory separator
        if php_strpos(p_path_, "\\") > 0 or php_substr(p_path_, 0, 1) == "\\":
            p_path_ = php_strtr(p_path_, "\\", "/")
        # end if
    # end if
    return p_path_
# end def PclZipUtilTranslateWinPath
pass
