#!/usr/bin/env python3
# coding: utf-8
if '__PHP2PY_LOADED__' not in globals():
    import cgi
    import os
    import os.path
    import copy
    import sys
    from goto import with_goto
    with open(os.getenv('PHP2PY_COMPAT', 'php_compat.py')) as f:
        exec(compile(f.read(), '<string>', 'exec'))
    # end with
    globals()['__PHP2PY_LOADED__'] = True
# end if
#// --------------------------------------------------------------------------------
#// PhpConcept Library - Zip Module 2.8.2
#// --------------------------------------------------------------------------------
#// License GNU/LGPL - Vincent Blavet - August 2009
#// http://www.phpconcept.net
#// --------------------------------------------------------------------------------
#// 
#// Presentation :
#// PclZip is a PHP library that manage ZIP archives.
#// So far tests show that archives generated by PclZip are readable by
#// WinZip application and other tools.
#// 
#// Description :
#// See readme.txt and http://www.phpconcept.net
#// 
#// Warning :
#// This library and the associated files are non commercial, non professional
#// work.
#// It should not have unexpected results. However if any damage is caused by
#// this software the author can not be responsible.
#// The use of this software is at the risk of the user.
#// 
#// --------------------------------------------------------------------------------
#// $Id: pclzip.lib.php,v 1.60 2009/09/30 21:01:04 vblavet Exp $
#// --------------------------------------------------------------------------------
#// ----- Constants
if (not php_defined("PCLZIP_READ_BLOCK_SIZE")):
    php_define("PCLZIP_READ_BLOCK_SIZE", 2048)
# end if
#// ----- File list separator
#// In version 1.x of PclZip, the separator for file list is a space
#// (which is not a very smart choice, specifically for windows paths !).
#// A better separator should be a comma (,). This constant gives you the
#// ability to change that.
#// However notice that changing this value, may have impact on existing
#// scripts, using space separated filenames.
#// Recommended values for compatibility with older versions :
#// define( 'PCLZIP_SEPARATOR', ' ' );
#// Recommended values for smart separation of filenames.
if (not php_defined("PCLZIP_SEPARATOR")):
    php_define("PCLZIP_SEPARATOR", ",")
# end if
#// ----- Error configuration
#// 0 : PclZip Class integrated error handling
#// 1 : PclError external library error handling. By enabling this
#// you must ensure that you have included PclError library.
#// [2,...] : reserved for futur use
if (not php_defined("PCLZIP_ERROR_EXTERNAL")):
    php_define("PCLZIP_ERROR_EXTERNAL", 0)
# end if
#// ----- Optional static temporary directory
#// By default temporary files are generated in the script current
#// path.
#// If defined :
#// - MUST BE terminated by a '/'.
#// - MUST be a valid, already created directory
#// Samples :
#// define( 'PCLZIP_TEMPORARY_DIR', '/temp/' );
#// define( 'PCLZIP_TEMPORARY_DIR', 'C:/Temp/' );
if (not php_defined("PCLZIP_TEMPORARY_DIR")):
    php_define("PCLZIP_TEMPORARY_DIR", "")
# end if
#// ----- Optional threshold ratio for use of temporary files
#// Pclzip sense the size of the file to add/extract and decide to
#// use or not temporary file. The algorithm is looking for
#// memory_limit of PHP and apply a ratio.
#// threshold = memory_limit * ratio.
#// Recommended values are under 0.5. Default 0.47.
#// Samples :
#// define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.5 );
if (not php_defined("PCLZIP_TEMPORARY_FILE_RATIO")):
    php_define("PCLZIP_TEMPORARY_FILE_RATIO", 0.47)
# end if
#// --------------------------------------------------------------------------------
#// UNDER THIS LINE NOTHING NEEDS TO BE MODIFIED
#// --------------------------------------------------------------------------------
#// ----- Global variables
g_pclzip_version = "2.8.2"
#// ----- Error codes
#// -1 : Unable to open file in binary write mode
#// -2 : Unable to open file in binary read mode
#// -3 : Invalid parameters
#// -4 : File does not exist
#// -5 : Filename is too long (max. 255)
#// -6 : Not a valid zip file
#// -7 : Invalid extracted file size
#// -8 : Unable to create directory
#// -9 : Invalid archive extension
#// -10 : Invalid archive format
#// -11 : Unable to delete file (unlink)
#// -12 : Unable to rename file (rename)
#// -13 : Invalid header checksum
#// -14 : Invalid archive size
php_define("PCLZIP_ERR_USER_ABORTED", 2)
php_define("PCLZIP_ERR_NO_ERROR", 0)
php_define("PCLZIP_ERR_WRITE_OPEN_FAIL", -1)
php_define("PCLZIP_ERR_READ_OPEN_FAIL", -2)
php_define("PCLZIP_ERR_INVALID_PARAMETER", -3)
php_define("PCLZIP_ERR_MISSING_FILE", -4)
php_define("PCLZIP_ERR_FILENAME_TOO_LONG", -5)
php_define("PCLZIP_ERR_INVALID_ZIP", -6)
php_define("PCLZIP_ERR_BAD_EXTRACTED_FILE", -7)
php_define("PCLZIP_ERR_DIR_CREATE_FAIL", -8)
php_define("PCLZIP_ERR_BAD_EXTENSION", -9)
php_define("PCLZIP_ERR_BAD_FORMAT", -10)
php_define("PCLZIP_ERR_DELETE_FILE_FAIL", -11)
php_define("PCLZIP_ERR_RENAME_FILE_FAIL", -12)
php_define("PCLZIP_ERR_BAD_CHECKSUM", -13)
php_define("PCLZIP_ERR_INVALID_ARCHIVE_ZIP", -14)
php_define("PCLZIP_ERR_MISSING_OPTION_VALUE", -15)
php_define("PCLZIP_ERR_INVALID_OPTION_VALUE", -16)
php_define("PCLZIP_ERR_ALREADY_A_DIRECTORY", -17)
php_define("PCLZIP_ERR_UNSUPPORTED_COMPRESSION", -18)
php_define("PCLZIP_ERR_UNSUPPORTED_ENCRYPTION", -19)
php_define("PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE", -20)
php_define("PCLZIP_ERR_DIRECTORY_RESTRICTION", -21)
#// ----- Options values
php_define("PCLZIP_OPT_PATH", 77001)
php_define("PCLZIP_OPT_ADD_PATH", 77002)
php_define("PCLZIP_OPT_REMOVE_PATH", 77003)
php_define("PCLZIP_OPT_REMOVE_ALL_PATH", 77004)
php_define("PCLZIP_OPT_SET_CHMOD", 77005)
php_define("PCLZIP_OPT_EXTRACT_AS_STRING", 77006)
php_define("PCLZIP_OPT_NO_COMPRESSION", 77007)
php_define("PCLZIP_OPT_BY_NAME", 77008)
php_define("PCLZIP_OPT_BY_INDEX", 77009)
php_define("PCLZIP_OPT_BY_EREG", 77010)
php_define("PCLZIP_OPT_BY_PREG", 77011)
php_define("PCLZIP_OPT_COMMENT", 77012)
php_define("PCLZIP_OPT_ADD_COMMENT", 77013)
php_define("PCLZIP_OPT_PREPEND_COMMENT", 77014)
php_define("PCLZIP_OPT_EXTRACT_IN_OUTPUT", 77015)
php_define("PCLZIP_OPT_REPLACE_NEWER", 77016)
php_define("PCLZIP_OPT_STOP_ON_ERROR", 77017)
#// Having big trouble with crypt. Need to multiply 2 long int
#// which is not correctly supported by PHP ...
#// define( 'PCLZIP_OPT_CRYPT', 77018 );
php_define("PCLZIP_OPT_EXTRACT_DIR_RESTRICTION", 77019)
php_define("PCLZIP_OPT_TEMP_FILE_THRESHOLD", 77020)
php_define("PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD", 77020)
#// alias
php_define("PCLZIP_OPT_TEMP_FILE_ON", 77021)
php_define("PCLZIP_OPT_ADD_TEMP_FILE_ON", 77021)
#// alias
php_define("PCLZIP_OPT_TEMP_FILE_OFF", 77022)
php_define("PCLZIP_OPT_ADD_TEMP_FILE_OFF", 77022)
#// alias
#// ----- File description attributes
php_define("PCLZIP_ATT_FILE_NAME", 79001)
php_define("PCLZIP_ATT_FILE_NEW_SHORT_NAME", 79002)
php_define("PCLZIP_ATT_FILE_NEW_FULL_NAME", 79003)
php_define("PCLZIP_ATT_FILE_MTIME", 79004)
php_define("PCLZIP_ATT_FILE_CONTENT", 79005)
php_define("PCLZIP_ATT_FILE_COMMENT", 79006)
#// ----- Call backs values
php_define("PCLZIP_CB_PRE_EXTRACT", 78001)
php_define("PCLZIP_CB_POST_EXTRACT", 78002)
php_define("PCLZIP_CB_PRE_ADD", 78003)
php_define("PCLZIP_CB_POST_ADD", 78004)
#// For futur use
#// define( 'PCLZIP_CB_PRE_LIST', 78005 );
#// define( 'PCLZIP_CB_POST_LIST', 78006 );
#// define( 'PCLZIP_CB_PRE_DELETE', 78007 );
#// define( 'PCLZIP_CB_POST_DELETE', 78008 );
#// 
#// --------------------------------------------------------------------------------
#// Class : PclZip
#// Description :
#// PclZip is the class that represent a Zip archive.
#// The public methods allow the manipulation of the archive.
#// Attributes :
#// Attributes must not be accessed directly.
#// Methods :
#// PclZip() : Object creator
#// create() : Creates the Zip archive
#// listContent() : List the content of the Zip archive
#// extract() : Extract the content of the archive
#// properties() : List the properties of the archive
#// --------------------------------------------------------------------------------
class PclZip():
    zipname = ""
    zip_fd = 0
    error_code = 1
    error_string = ""
    magic_quotes_status = Array()
    #// --------------------------------------------------------------------------------
    #// Function : PclZip()
    #// Description :
    #// Creates a PclZip object and set the name of the associated Zip archive
    #// filename.
    #// Note that no real action is taken, if the archive does not exist it is not
    #// created. Use create() for that.
    #// --------------------------------------------------------------------------------
    def __init__(self, p_zipname=None):
        
        #// ----- Tests the zlib
        if (not php_function_exists("gzopen")):
            php_print("Abort " + php_basename(__FILE__) + " : Missing zlib extensions")
            php_exit()
        # end if
        #// ----- Set the attributes
        self.zipname = p_zipname
        self.zip_fd = 0
        self.magic_quotes_status = -1
        #// ----- Return
        return
    # end def __init__
    def pclzip(self, p_zipname=None):
        
        self.__init__(p_zipname)
    # end def pclzip
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function :
    #// create($p_filelist, $p_add_dir="", $p_remove_dir="")
    #// create($p_filelist, $p_option, $p_option_value, ...)
    #// Description :
    #// This method supports two different synopsis. The first one is historical.
    #// This method creates a Zip Archive. The Zip file is created in the
    #// filesystem. The files and directories indicated in $p_filelist
    #// are added in the archive. See the parameters description for the
    #// supported format of $p_filelist.
    #// When a directory is in the list, the directory and its content is added
    #// in the archive.
    #// In this synopsis, the function takes an optional variable list of
    #// options. See below the supported options.
    #// Parameters :
    #// $p_filelist : An array containing file or directory names, or
    #// a string containing one filename or one directory name, or
    #// a string containing a list of filenames and/or directory
    #// names separated by spaces.
    #// $p_add_dir : A path to add before the real path of the archived file,
    #// in order to have it memorized in the archive.
    #// $p_remove_dir : A path to remove from the real path of the file to archive,
    #// in order to have a shorter path memorized in the archive.
    #// When $p_add_dir and $p_remove_dir are set, $p_remove_dir
    #// is removed first, before $p_add_dir is added.
    #// Options :
    #// PCLZIP_OPT_ADD_PATH :
    #// PCLZIP_OPT_REMOVE_PATH :
    #// PCLZIP_OPT_REMOVE_ALL_PATH :
    #// PCLZIP_OPT_COMMENT :
    #// PCLZIP_CB_PRE_ADD :
    #// PCLZIP_CB_POST_ADD :
    #// Return Values :
    #// 0 on failure,
    #// The list of the added files, with a status of the add action.
    #// (see PclZip::listContent() for list entry format)
    #// --------------------------------------------------------------------------------
    def create(self, p_filelist=None):
        
        v_result = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Set default values
        v_options = Array()
        v_options[PCLZIP_OPT_NO_COMPRESSION] = False
        #// ----- Look for variable options arguments
        v_size = php_func_num_args()
        #// ----- Look for arguments
        if v_size > 1:
            #// ----- Get the arguments
            v_arg_list = php_func_get_args()
            #// ----- Remove from the options list the first argument
            php_array_shift(v_arg_list)
            v_size -= 1
            #// ----- Look for first arg
            if is_integer(v_arg_list[0]) and v_arg_list[0] > 77000:
                #// ----- Parse the options
                v_result = self.privparseoptions(v_arg_list, v_size, v_options, Array({PCLZIP_OPT_REMOVE_PATH: "optional", PCLZIP_OPT_REMOVE_ALL_PATH: "optional", PCLZIP_OPT_ADD_PATH: "optional", PCLZIP_CB_PRE_ADD: "optional", PCLZIP_CB_POST_ADD: "optional", PCLZIP_OPT_NO_COMPRESSION: "optional", PCLZIP_OPT_COMMENT: "optional", PCLZIP_OPT_TEMP_FILE_THRESHOLD: "optional", PCLZIP_OPT_TEMP_FILE_ON: "optional", PCLZIP_OPT_TEMP_FILE_OFF: "optional"}))
                if v_result != 1:
                    return 0
                # end if
            else:
                #// ----- Get the first argument
                v_options[PCLZIP_OPT_ADD_PATH] = v_arg_list[0]
                #// ----- Look for the optional second argument
                if v_size == 2:
                    v_options[PCLZIP_OPT_REMOVE_PATH] = v_arg_list[1]
                else:
                    if v_size > 2:
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments")
                        return 0
                    # end if
                # end if
            # end if
        # end if
        #// ----- Look for default option values
        self.privoptiondefaultthreshold(v_options)
        #// ----- Init
        v_string_list = Array()
        v_att_list = Array()
        v_filedescr_list = Array()
        p_result_list = Array()
        #// ----- Look if the $p_filelist is really an array
        if php_is_array(p_filelist):
            #// ----- Look if the first element is also an array
            #// This will mean that this is a file description entry
            if (php_isset(lambda : p_filelist[0])) and php_is_array(p_filelist[0]):
                v_att_list = p_filelist
            else:
                v_string_list = p_filelist
            # end if
        else:
            if php_is_string(p_filelist):
                #// ----- Create a list from the string
                v_string_list = php_explode(PCLZIP_SEPARATOR, p_filelist)
            else:
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_filelist")
                return 0
            # end if
        # end if
        #// ----- Reformat the string list
        if sizeof(v_string_list) != 0:
            for v_string in v_string_list:
                if v_string != "":
                    v_att_list[-1][PCLZIP_ATT_FILE_NAME] = v_string
                # end if
            # end for
        # end if
        #// ----- For each file in the list check the attributes
        v_supported_attributes = Array({PCLZIP_ATT_FILE_NAME: "mandatory", PCLZIP_ATT_FILE_NEW_SHORT_NAME: "optional", PCLZIP_ATT_FILE_NEW_FULL_NAME: "optional", PCLZIP_ATT_FILE_MTIME: "optional", PCLZIP_ATT_FILE_CONTENT: "optional", PCLZIP_ATT_FILE_COMMENT: "optional"})
        for v_entry in v_att_list:
            v_result = self.privfiledescrparseatt(v_entry, v_filedescr_list[-1], v_options, v_supported_attributes)
            if v_result != 1:
                return 0
            # end if
        # end for
        #// ----- Expand the filelist (expand directories)
        v_result = self.privfiledescrexpand(v_filedescr_list, v_options)
        if v_result != 1:
            return 0
        # end if
        #// ----- Call the create fct
        v_result = self.privcreate(v_filedescr_list, p_result_list, v_options)
        if v_result != 1:
            return 0
        # end if
        #// ----- Return
        return p_result_list
    # end def create
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function :
    #// add($p_filelist, $p_add_dir="", $p_remove_dir="")
    #// add($p_filelist, $p_option, $p_option_value, ...)
    #// Description :
    #// This method supports two synopsis. The first one is historical.
    #// This methods add the list of files in an existing archive.
    #// If a file with the same name already exists, it is added at the end of the
    #// archive, the first one is still present.
    #// If the archive does not exist, it is created.
    #// Parameters :
    #// $p_filelist : An array containing file or directory names, or
    #// a string containing one filename or one directory name, or
    #// a string containing a list of filenames and/or directory
    #// names separated by spaces.
    #// $p_add_dir : A path to add before the real path of the archived file,
    #// in order to have it memorized in the archive.
    #// $p_remove_dir : A path to remove from the real path of the file to archive,
    #// in order to have a shorter path memorized in the archive.
    #// When $p_add_dir and $p_remove_dir are set, $p_remove_dir
    #// is removed first, before $p_add_dir is added.
    #// Options :
    #// PCLZIP_OPT_ADD_PATH :
    #// PCLZIP_OPT_REMOVE_PATH :
    #// PCLZIP_OPT_REMOVE_ALL_PATH :
    #// PCLZIP_OPT_COMMENT :
    #// PCLZIP_OPT_ADD_COMMENT :
    #// PCLZIP_OPT_PREPEND_COMMENT :
    #// PCLZIP_CB_PRE_ADD :
    #// PCLZIP_CB_POST_ADD :
    #// Return Values :
    #// 0 on failure,
    #// The list of the added files, with a status of the add action.
    #// (see PclZip::listContent() for list entry format)
    #// --------------------------------------------------------------------------------
    def add(self, p_filelist=None):
        
        v_result = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Set default values
        v_options = Array()
        v_options[PCLZIP_OPT_NO_COMPRESSION] = False
        #// ----- Look for variable options arguments
        v_size = php_func_num_args()
        #// ----- Look for arguments
        if v_size > 1:
            #// ----- Get the arguments
            v_arg_list = php_func_get_args()
            #// ----- Remove form the options list the first argument
            php_array_shift(v_arg_list)
            v_size -= 1
            #// ----- Look for first arg
            if is_integer(v_arg_list[0]) and v_arg_list[0] > 77000:
                #// ----- Parse the options
                v_result = self.privparseoptions(v_arg_list, v_size, v_options, Array({PCLZIP_OPT_REMOVE_PATH: "optional", PCLZIP_OPT_REMOVE_ALL_PATH: "optional", PCLZIP_OPT_ADD_PATH: "optional", PCLZIP_CB_PRE_ADD: "optional", PCLZIP_CB_POST_ADD: "optional", PCLZIP_OPT_NO_COMPRESSION: "optional", PCLZIP_OPT_COMMENT: "optional", PCLZIP_OPT_ADD_COMMENT: "optional", PCLZIP_OPT_PREPEND_COMMENT: "optional", PCLZIP_OPT_TEMP_FILE_THRESHOLD: "optional", PCLZIP_OPT_TEMP_FILE_ON: "optional", PCLZIP_OPT_TEMP_FILE_OFF: "optional"}))
                if v_result != 1:
                    return 0
                # end if
            else:
                #// ----- Get the first argument
                v_options[PCLZIP_OPT_ADD_PATH] = v_add_path
                #// ----- Look for the optional second argument
                if v_size == 2:
                    v_options[PCLZIP_OPT_REMOVE_PATH] = v_arg_list[1]
                else:
                    if v_size > 2:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments")
                        #// ----- Return
                        return 0
                    # end if
                # end if
            # end if
        # end if
        #// ----- Look for default option values
        self.privoptiondefaultthreshold(v_options)
        #// ----- Init
        v_string_list = Array()
        v_att_list = Array()
        v_filedescr_list = Array()
        p_result_list = Array()
        #// ----- Look if the $p_filelist is really an array
        if php_is_array(p_filelist):
            #// ----- Look if the first element is also an array
            #// This will mean that this is a file description entry
            if (php_isset(lambda : p_filelist[0])) and php_is_array(p_filelist[0]):
                v_att_list = p_filelist
            else:
                v_string_list = p_filelist
            # end if
        else:
            if php_is_string(p_filelist):
                #// ----- Create a list from the string
                v_string_list = php_explode(PCLZIP_SEPARATOR, p_filelist)
            else:
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type '" + gettype(p_filelist) + "' for p_filelist")
                return 0
            # end if
        # end if
        #// ----- Reformat the string list
        if sizeof(v_string_list) != 0:
            for v_string in v_string_list:
                v_att_list[-1][PCLZIP_ATT_FILE_NAME] = v_string
            # end for
        # end if
        #// ----- For each file in the list check the attributes
        v_supported_attributes = Array({PCLZIP_ATT_FILE_NAME: "mandatory", PCLZIP_ATT_FILE_NEW_SHORT_NAME: "optional", PCLZIP_ATT_FILE_NEW_FULL_NAME: "optional", PCLZIP_ATT_FILE_MTIME: "optional", PCLZIP_ATT_FILE_CONTENT: "optional", PCLZIP_ATT_FILE_COMMENT: "optional"})
        for v_entry in v_att_list:
            v_result = self.privfiledescrparseatt(v_entry, v_filedescr_list[-1], v_options, v_supported_attributes)
            if v_result != 1:
                return 0
            # end if
        # end for
        #// ----- Expand the filelist (expand directories)
        v_result = self.privfiledescrexpand(v_filedescr_list, v_options)
        if v_result != 1:
            return 0
        # end if
        #// ----- Call the create fct
        v_result = self.privadd(v_filedescr_list, p_result_list, v_options)
        if v_result != 1:
            return 0
        # end if
        #// ----- Return
        return p_result_list
    # end def add
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : listContent()
    #// Description :
    #// This public method, gives the list of the files and directories, with their
    #// properties.
    #// The properties of each entries in the list are (used also in other functions) :
    #// filename : Name of the file. For a create or add action it is the filename
    #// given by the user. For an extract function it is the filename
    #// of the extracted file.
    #// stored_filename : Name of the file / directory stored in the archive.
    #// size : Size of the stored file.
    #// compressed_size : Size of the file's data compressed in the archive
    #// (without the headers overhead)
    #// mtime : Last known modification date of the file (UNIX timestamp)
    #// comment : Comment associated with the file
    #// folder : true | false
    #// index : index of the file in the archive
    #// status : status of the action (depending of the action) :
    #// Values are :
    #// ok : OK !
    #// filtered : the file / dir is not extracted (filtered by user)
    #// already_a_directory : the file can not be extracted because a
    #// directory with the same name already exists
    #// write_protected : the file can not be extracted because a file
    #// with the same name already exists and is
    #// write protected
    #// newer_exist : the file was not extracted because a newer file exists
    #// path_creation_fail : the file is not extracted because the folder
    #// does not exist and can not be created
    #// write_error : the file was not extracted because there was a
    #// error while writing the file
    #// read_error : the file was not extracted because there was a error
    #// while reading the file
    #// invalid_header : the file was not extracted because of an archive
    #// format error (bad file header)
    #// Note that each time a method can continue operating when there
    #// is an action error on a file, the error is only logged in the file status.
    #// Return Values :
    #// 0 on an unrecoverable failure,
    #// The list of the files in the archive.
    #// --------------------------------------------------------------------------------
    def listcontent(self):
        
        v_result = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Check archive
        if (not self.privcheckformat()):
            return 0
        # end if
        #// ----- Call the extracting fct
        p_list = Array()
        v_result = self.privlist(p_list)
        if v_result != 1:
            p_list = None
            return 0
        # end if
        #// ----- Return
        return p_list
    # end def listcontent
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function :
    #// extract($p_path="./", $p_remove_path="")
    #// extract([$p_option, $p_option_value, ...])
    #// Description :
    #// This method supports two synopsis. The first one is historical.
    #// This method extract all the files / directories from the archive to the
    #// folder indicated in $p_path.
    #// If you want to ignore the 'root' part of path of the memorized files
    #// you can indicate this in the optional $p_remove_path parameter.
    #// By default, if a newer file with the same name already exists, the
    #// file is not extracted.
    #// 
    #// If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH options
    #// are used, the path indicated in PCLZIP_OPT_ADD_PATH is append
    #// at the end of the path value of PCLZIP_OPT_PATH.
    #// Parameters :
    #// $p_path : Path where the files and directories are to be extracted
    #// $p_remove_path : First part ('root' part) of the memorized path
    #// (if any similar) to remove while extracting.
    #// Options :
    #// PCLZIP_OPT_PATH :
    #// PCLZIP_OPT_ADD_PATH :
    #// PCLZIP_OPT_REMOVE_PATH :
    #// PCLZIP_OPT_REMOVE_ALL_PATH :
    #// PCLZIP_CB_PRE_EXTRACT :
    #// PCLZIP_CB_POST_EXTRACT :
    #// Return Values :
    #// 0 or a negative value on failure,
    #// The list of the extracted files, with a status of the action.
    #// (see PclZip::listContent() for list entry format)
    #// --------------------------------------------------------------------------------
    def extract(self):
        
        v_result = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Check archive
        if (not self.privcheckformat()):
            return 0
        # end if
        #// ----- Set default values
        v_options = Array()
        #// $v_path = "./";
        v_path = ""
        v_remove_path = ""
        v_remove_all_path = False
        #// ----- Look for variable options arguments
        v_size = php_func_num_args()
        #// ----- Default values for option
        v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = False
        #// ----- Look for arguments
        if v_size > 0:
            #// ----- Get the arguments
            v_arg_list = php_func_get_args()
            #// ----- Look for first arg
            if is_integer(v_arg_list[0]) and v_arg_list[0] > 77000:
                #// ----- Parse the options
                v_result = self.privparseoptions(v_arg_list, v_size, v_options, Array({PCLZIP_OPT_PATH: "optional", PCLZIP_OPT_REMOVE_PATH: "optional", PCLZIP_OPT_REMOVE_ALL_PATH: "optional", PCLZIP_OPT_ADD_PATH: "optional", PCLZIP_CB_PRE_EXTRACT: "optional", PCLZIP_CB_POST_EXTRACT: "optional", PCLZIP_OPT_SET_CHMOD: "optional", PCLZIP_OPT_BY_NAME: "optional", PCLZIP_OPT_BY_EREG: "optional", PCLZIP_OPT_BY_PREG: "optional", PCLZIP_OPT_BY_INDEX: "optional", PCLZIP_OPT_EXTRACT_AS_STRING: "optional", PCLZIP_OPT_EXTRACT_IN_OUTPUT: "optional", PCLZIP_OPT_REPLACE_NEWER: "optional", PCLZIP_OPT_STOP_ON_ERROR: "optional", PCLZIP_OPT_EXTRACT_DIR_RESTRICTION: "optional", PCLZIP_OPT_TEMP_FILE_THRESHOLD: "optional", PCLZIP_OPT_TEMP_FILE_ON: "optional", PCLZIP_OPT_TEMP_FILE_OFF: "optional"}))
                if v_result != 1:
                    return 0
                # end if
                #// ----- Set the arguments
                if (php_isset(lambda : v_options[PCLZIP_OPT_PATH])):
                    v_path = v_options[PCLZIP_OPT_PATH]
                # end if
                if (php_isset(lambda : v_options[PCLZIP_OPT_REMOVE_PATH])):
                    v_remove_path = v_options[PCLZIP_OPT_REMOVE_PATH]
                # end if
                if (php_isset(lambda : v_options[PCLZIP_OPT_REMOVE_ALL_PATH])):
                    v_remove_all_path = v_options[PCLZIP_OPT_REMOVE_ALL_PATH]
                # end if
                if (php_isset(lambda : v_options[PCLZIP_OPT_ADD_PATH])):
                    #// ----- Check for '/' in last path char
                    if php_strlen(v_path) > 0 and php_substr(v_path, -1) != "/":
                        v_path += "/"
                    # end if
                    v_path += v_options[PCLZIP_OPT_ADD_PATH]
                # end if
            else:
                #// ----- Get the first argument
                v_path = v_arg_list[0]
                #// ----- Look for the optional second argument
                if v_size == 2:
                    v_remove_path = v_arg_list[1]
                else:
                    if v_size > 2:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments")
                        #// ----- Return
                        return 0
                    # end if
                # end if
            # end if
        # end if
        #// ----- Look for default option values
        self.privoptiondefaultthreshold(v_options)
        #// ----- Trace
        #// ----- Call the extracting fct
        p_list = Array()
        v_result = self.privextractbyrule(p_list, v_path, v_remove_path, v_remove_all_path, v_options)
        if v_result < 1:
            p_list = None
            return 0
        # end if
        #// ----- Return
        return p_list
    # end def extract
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function :
    #// extractByIndex($p_index, $p_path="./", $p_remove_path="")
    #// extractByIndex($p_index, [$p_option, $p_option_value, ...])
    #// Description :
    #// This method supports two synopsis. The first one is historical.
    #// This method is doing a partial extract of the archive.
    #// The extracted files or folders are identified by their index in the
    #// archive (from 0 to n).
    #// Note that if the index identify a folder, only the folder entry is
    #// extracted, not all the files included in the archive.
    #// Parameters :
    #// $p_index : A single index (integer) or a string of indexes of files to
    #// extract. The form of the string is "0,4-6,8-12" with only numbers
    #// and '-' for range or ',' to separate ranges. No spaces or ';'
    #// are allowed.
    #// $p_path : Path where the files and directories are to be extracted
    #// $p_remove_path : First part ('root' part) of the memorized path
    #// (if any similar) to remove while extracting.
    #// Options :
    #// PCLZIP_OPT_PATH :
    #// PCLZIP_OPT_ADD_PATH :
    #// PCLZIP_OPT_REMOVE_PATH :
    #// PCLZIP_OPT_REMOVE_ALL_PATH :
    #// PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and
    #// not as files.
    #// The resulting content is in a new field 'content' in the file
    #// structure.
    #// This option must be used alone (any other options are ignored).
    #// PCLZIP_CB_PRE_EXTRACT :
    #// PCLZIP_CB_POST_EXTRACT :
    #// Return Values :
    #// 0 on failure,
    #// The list of the extracted files, with a status of the action.
    #// (see PclZip::listContent() for list entry format)
    #// --------------------------------------------------------------------------------
    #// function extractByIndex($p_index, options...)
    def extractbyindex(self, p_index=None):
        
        v_result = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Check archive
        if (not self.privcheckformat()):
            return 0
        # end if
        #// ----- Set default values
        v_options = Array()
        #// $v_path = "./";
        v_path = ""
        v_remove_path = ""
        v_remove_all_path = False
        #// ----- Look for variable options arguments
        v_size = php_func_num_args()
        #// ----- Default values for option
        v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = False
        #// ----- Look for arguments
        if v_size > 1:
            #// ----- Get the arguments
            v_arg_list = php_func_get_args()
            #// ----- Remove form the options list the first argument
            php_array_shift(v_arg_list)
            v_size -= 1
            #// ----- Look for first arg
            if is_integer(v_arg_list[0]) and v_arg_list[0] > 77000:
                #// ----- Parse the options
                v_result = self.privparseoptions(v_arg_list, v_size, v_options, Array({PCLZIP_OPT_PATH: "optional", PCLZIP_OPT_REMOVE_PATH: "optional", PCLZIP_OPT_REMOVE_ALL_PATH: "optional", PCLZIP_OPT_EXTRACT_AS_STRING: "optional", PCLZIP_OPT_ADD_PATH: "optional", PCLZIP_CB_PRE_EXTRACT: "optional", PCLZIP_CB_POST_EXTRACT: "optional", PCLZIP_OPT_SET_CHMOD: "optional", PCLZIP_OPT_REPLACE_NEWER: "optional", PCLZIP_OPT_STOP_ON_ERROR: "optional", PCLZIP_OPT_EXTRACT_DIR_RESTRICTION: "optional", PCLZIP_OPT_TEMP_FILE_THRESHOLD: "optional", PCLZIP_OPT_TEMP_FILE_ON: "optional", PCLZIP_OPT_TEMP_FILE_OFF: "optional"}))
                if v_result != 1:
                    return 0
                # end if
                #// ----- Set the arguments
                if (php_isset(lambda : v_options[PCLZIP_OPT_PATH])):
                    v_path = v_options[PCLZIP_OPT_PATH]
                # end if
                if (php_isset(lambda : v_options[PCLZIP_OPT_REMOVE_PATH])):
                    v_remove_path = v_options[PCLZIP_OPT_REMOVE_PATH]
                # end if
                if (php_isset(lambda : v_options[PCLZIP_OPT_REMOVE_ALL_PATH])):
                    v_remove_all_path = v_options[PCLZIP_OPT_REMOVE_ALL_PATH]
                # end if
                if (php_isset(lambda : v_options[PCLZIP_OPT_ADD_PATH])):
                    #// ----- Check for '/' in last path char
                    if php_strlen(v_path) > 0 and php_substr(v_path, -1) != "/":
                        v_path += "/"
                    # end if
                    v_path += v_options[PCLZIP_OPT_ADD_PATH]
                # end if
                if (not (php_isset(lambda : v_options[PCLZIP_OPT_EXTRACT_AS_STRING]))):
                    v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = False
                # end if
            else:
                #// ----- Get the first argument
                v_path = v_arg_list[0]
                #// ----- Look for the optional second argument
                if v_size == 2:
                    v_remove_path = v_arg_list[1]
                else:
                    if v_size > 2:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments")
                        #// ----- Return
                        return 0
                    # end if
                # end if
            # end if
        # end if
        #// ----- Trace
        #// ----- Trick
        #// Here I want to reuse extractByRule(), so I need to parse the $p_index
        #// with privParseOptions()
        v_arg_trick = Array(PCLZIP_OPT_BY_INDEX, p_index)
        v_options_trick = Array()
        v_result = self.privparseoptions(v_arg_trick, sizeof(v_arg_trick), v_options_trick, Array({PCLZIP_OPT_BY_INDEX: "optional"}))
        if v_result != 1:
            return 0
        # end if
        v_options[PCLZIP_OPT_BY_INDEX] = v_options_trick[PCLZIP_OPT_BY_INDEX]
        #// ----- Look for default option values
        self.privoptiondefaultthreshold(v_options)
        #// ----- Call the extracting fct
        v_result = self.privextractbyrule(p_list, v_path, v_remove_path, v_remove_all_path, v_options)
        if v_result < 1:
            return 0
        # end if
        #// ----- Return
        return p_list
    # end def extractbyindex
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function :
    #// delete([$p_option, $p_option_value, ...])
    #// Description :
    #// This method removes files from the archive.
    #// If no parameters are given, then all the archive is emptied.
    #// Parameters :
    #// None or optional arguments.
    #// Options :
    #// PCLZIP_OPT_BY_INDEX :
    #// PCLZIP_OPT_BY_NAME :
    #// PCLZIP_OPT_BY_EREG :
    #// PCLZIP_OPT_BY_PREG :
    #// Return Values :
    #// 0 on failure,
    #// The list of the files which are still present in the archive.
    #// (see PclZip::listContent() for list entry format)
    #// --------------------------------------------------------------------------------
    def delete(self):
        
        v_result = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Check archive
        if (not self.privcheckformat()):
            return 0
        # end if
        #// ----- Set default values
        v_options = Array()
        #// ----- Look for variable options arguments
        v_size = php_func_num_args()
        #// ----- Look for arguments
        if v_size > 0:
            #// ----- Get the arguments
            v_arg_list = php_func_get_args()
            #// ----- Parse the options
            v_result = self.privparseoptions(v_arg_list, v_size, v_options, Array({PCLZIP_OPT_BY_NAME: "optional", PCLZIP_OPT_BY_EREG: "optional", PCLZIP_OPT_BY_PREG: "optional", PCLZIP_OPT_BY_INDEX: "optional"}))
            if v_result != 1:
                return 0
            # end if
        # end if
        #// ----- Magic quotes trick
        self.privdisablemagicquotes()
        #// ----- Call the delete fct
        v_list = Array()
        v_result = self.privdeletebyrule(v_list, v_options)
        if v_result != 1:
            self.privswapbackmagicquotes()
            v_list = None
            return 0
        # end if
        #// ----- Magic quotes trick
        self.privswapbackmagicquotes()
        #// ----- Return
        return v_list
    # end def delete
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : deleteByIndex()
    #// Description :
    #// Deprecated
    #// delete(PCLZIP_OPT_BY_INDEX, $p_index) should be preferred.
    #// --------------------------------------------------------------------------------
    def deletebyindex(self, p_index=None):
        
        p_list = self.delete(PCLZIP_OPT_BY_INDEX, p_index)
        #// ----- Return
        return p_list
    # end def deletebyindex
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : properties()
    #// Description :
    #// This method gives the properties of the archive.
    #// The properties are :
    #// nb : Number of files in the archive
    #// comment : Comment associated with the archive file
    #// status : not_exist, ok
    #// Parameters :
    #// None
    #// Return Values :
    #// 0 on failure,
    #// An array with the archive properties.
    #// --------------------------------------------------------------------------------
    def properties(self):
        
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Magic quotes trick
        self.privdisablemagicquotes()
        #// ----- Check archive
        if (not self.privcheckformat()):
            self.privswapbackmagicquotes()
            return 0
        # end if
        #// ----- Default properties
        v_prop = Array()
        v_prop["comment"] = ""
        v_prop["nb"] = 0
        v_prop["status"] = "not_exist"
        #// ----- Look if file exists
        if php_no_error(lambda: php_is_file(self.zipname)):
            #// ----- Open the zip file
            self.zip_fd = php_no_error(lambda: fopen(self.zipname, "rb"))
            if self.zip_fd == 0:
                self.privswapbackmagicquotes()
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open archive '" + self.zipname + "' in binary read mode")
                #// ----- Return
                return 0
            # end if
            #// ----- Read the central directory information
            v_central_dir = Array()
            v_result = self.privreadendcentraldir(v_central_dir)
            if v_result != 1:
                self.privswapbackmagicquotes()
                return 0
            # end if
            #// ----- Close the zip file
            self.privclosefd()
            #// ----- Set the user attributes
            v_prop["comment"] = v_central_dir["comment"]
            v_prop["nb"] = v_central_dir["entries"]
            v_prop["status"] = "ok"
        # end if
        #// ----- Magic quotes trick
        self.privswapbackmagicquotes()
        #// ----- Return
        return v_prop
    # end def properties
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : duplicate()
    #// Description :
    #// This method creates an archive by copying the content of an other one. If
    #// the archive already exist, it is replaced by the new one without any warning.
    #// Parameters :
    #// $p_archive : The filename of a valid archive, or
    #// a valid PclZip object.
    #// Return Values :
    #// 1 on success.
    #// 0 or a negative value on error (error code).
    #// --------------------------------------------------------------------------------
    def duplicate(self, p_archive=None):
        
        v_result = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Look if the $p_archive is a PclZip object
        if php_is_object(p_archive) and get_class(p_archive) == "pclzip":
            #// ----- Duplicate the archive
            v_result = self.privduplicate(p_archive.zipname)
        else:
            if php_is_string(p_archive):
                #// ----- Check that $p_archive is a valid zip file
                #// TBC : Should also check the archive format
                if (not php_is_file(p_archive)):
                    #// ----- Error log
                    PclZip.priverrorlog(PCLZIP_ERR_MISSING_FILE, "No file with filename '" + p_archive + "'")
                    v_result = PCLZIP_ERR_MISSING_FILE
                else:
                    #// ----- Duplicate the archive
                    v_result = self.privduplicate(p_archive)
                # end if
            else:
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add")
                v_result = PCLZIP_ERR_INVALID_PARAMETER
            # end if
        # end if
        #// ----- Return
        return v_result
    # end def duplicate
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : merge()
    #// Description :
    #// This method merge the $p_archive_to_add archive at the end of the current
    #// one ($this).
    #// If the archive ($this) does not exist, the merge becomes a duplicate.
    #// If the $p_archive_to_add archive does not exist, the merge is a success.
    #// Parameters :
    #// $p_archive_to_add : It can be directly the filename of a valid zip archive,
    #// or a PclZip object archive.
    #// Return Values :
    #// 1 on success,
    #// 0 or negative values on error (see below).
    #// --------------------------------------------------------------------------------
    def merge(self, p_archive_to_add=None):
        
        v_result = 1
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Check archive
        if (not self.privcheckformat()):
            return 0
        # end if
        #// ----- Look if the $p_archive_to_add is a PclZip object
        if php_is_object(p_archive_to_add) and get_class(p_archive_to_add) == "pclzip":
            #// ----- Merge the archive
            v_result = self.privmerge(p_archive_to_add)
        else:
            if php_is_string(p_archive_to_add):
                #// ----- Create a temporary archive
                v_object_archive = php_new_class("PclZip", lambda : PclZip(p_archive_to_add))
                #// ----- Merge the archive
                v_result = self.privmerge(v_object_archive)
            else:
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add")
                v_result = PCLZIP_ERR_INVALID_PARAMETER
            # end if
        # end if
        #// ----- Return
        return v_result
    # end def merge
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : errorCode()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def errorcode(self):
        
        if PCLZIP_ERROR_EXTERNAL == 1:
            return PclErrorCode()
        else:
            return self.error_code
        # end if
    # end def errorcode
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : errorName()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def errorname(self, p_with_code=False):
        
        v_name = Array({PCLZIP_ERR_NO_ERROR: "PCLZIP_ERR_NO_ERROR", PCLZIP_ERR_WRITE_OPEN_FAIL: "PCLZIP_ERR_WRITE_OPEN_FAIL", PCLZIP_ERR_READ_OPEN_FAIL: "PCLZIP_ERR_READ_OPEN_FAIL", PCLZIP_ERR_INVALID_PARAMETER: "PCLZIP_ERR_INVALID_PARAMETER", PCLZIP_ERR_MISSING_FILE: "PCLZIP_ERR_MISSING_FILE", PCLZIP_ERR_FILENAME_TOO_LONG: "PCLZIP_ERR_FILENAME_TOO_LONG", PCLZIP_ERR_INVALID_ZIP: "PCLZIP_ERR_INVALID_ZIP", PCLZIP_ERR_BAD_EXTRACTED_FILE: "PCLZIP_ERR_BAD_EXTRACTED_FILE", PCLZIP_ERR_DIR_CREATE_FAIL: "PCLZIP_ERR_DIR_CREATE_FAIL", PCLZIP_ERR_BAD_EXTENSION: "PCLZIP_ERR_BAD_EXTENSION", PCLZIP_ERR_BAD_FORMAT: "PCLZIP_ERR_BAD_FORMAT", PCLZIP_ERR_DELETE_FILE_FAIL: "PCLZIP_ERR_DELETE_FILE_FAIL", PCLZIP_ERR_RENAME_FILE_FAIL: "PCLZIP_ERR_RENAME_FILE_FAIL", PCLZIP_ERR_BAD_CHECKSUM: "PCLZIP_ERR_BAD_CHECKSUM", PCLZIP_ERR_INVALID_ARCHIVE_ZIP: "PCLZIP_ERR_INVALID_ARCHIVE_ZIP", PCLZIP_ERR_MISSING_OPTION_VALUE: "PCLZIP_ERR_MISSING_OPTION_VALUE", PCLZIP_ERR_INVALID_OPTION_VALUE: "PCLZIP_ERR_INVALID_OPTION_VALUE", PCLZIP_ERR_UNSUPPORTED_COMPRESSION: "PCLZIP_ERR_UNSUPPORTED_COMPRESSION", PCLZIP_ERR_UNSUPPORTED_ENCRYPTION: "PCLZIP_ERR_UNSUPPORTED_ENCRYPTION", PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE: "PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE", PCLZIP_ERR_DIRECTORY_RESTRICTION: "PCLZIP_ERR_DIRECTORY_RESTRICTION"})
        if (php_isset(lambda : v_name[self.error_code])):
            v_value = v_name[self.error_code]
        else:
            v_value = "NoName"
        # end if
        if p_with_code:
            return v_value + " (" + self.error_code + ")"
        else:
            return v_value
        # end if
    # end def errorname
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : errorInfo()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def errorinfo(self, p_full=False):
        
        if PCLZIP_ERROR_EXTERNAL == 1:
            return PclErrorString()
        else:
            if p_full:
                return self.errorname(True) + " : " + self.error_string
            else:
                return self.error_string + " [code " + self.error_code + "]"
            # end if
        # end if
    # end def errorinfo
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS
    #// 
    #// THESES FUNCTIONS MUST NOT BE USED DIRECTLY
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privCheckFormat()
    #// Description :
    #// This method check that the archive exists and is a valid zip archive.
    #// Several level of check exists. (futur)
    #// Parameters :
    #// $p_level : Level of check. Default 0.
    #// 0 : Check the first bytes (magic codes) (default value))
    #// 1 : 0 + Check the central directory (futur)
    #// 2 : 1 + Check each file header (futur)
    #// Return Values :
    #// true on success,
    #// false on error, the error code is set.
    #// --------------------------------------------------------------------------------
    def privcheckformat(self, p_level=0):
        
        v_result = True
        #// ----- Reset the file system cache
        clearstatcache()
        #// ----- Reset the error handler
        self.priverrorreset()
        #// ----- Look if the file exits
        if (not php_is_file(self.zipname)):
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_MISSING_FILE, "Missing archive file '" + self.zipname + "'")
            return False
        # end if
        #// ----- Check that the file is readable
        if (not php_is_readable(self.zipname)):
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to read archive '" + self.zipname + "'")
            return False
        # end if
        #// ----- Check the magic code
        #// TBC
        #// ----- Check the central header
        #// TBC
        #// ----- Check each file header
        #// TBC
        #// ----- Return
        return v_result
    # end def privcheckformat
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privParseOptions()
    #// Description :
    #// This internal methods reads the variable list of arguments ($p_options_list,
    #// $p_size) and generate an array with the options and values ($v_result_list).
    #// $v_requested_options contains the options that can be present and those that
    #// must be present.
    #// $v_requested_options is an array, with the option value as key, and 'optional',
    #// or 'mandatory' as value.
    #// Parameters :
    #// See above.
    #// Return Values :
    #// 1 on success.
    #// 0 on failure.
    #// --------------------------------------------------------------------------------
    def privparseoptions(self, p_options_list=None, p_size=None, v_result_list=None, v_requested_options=False):
        
        v_result = 1
        #// ----- Read the options
        i = 0
        while True:
            
            if not (i < p_size):
                break
            # end if
            #// ----- Check if the option is supported
            if (not (php_isset(lambda : v_requested_options[p_options_list[i]]))):
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid optional parameter '" + p_options_list[i] + "' for this method")
                #// ----- Return
                return PclZip.errorcode()
            # end if
            #// ----- Look for next option
            for case in Switch(p_options_list[i]):
                if case(PCLZIP_OPT_PATH):
                    pass
                # end if
                if case(PCLZIP_OPT_REMOVE_PATH):
                    pass
                # end if
                if case(PCLZIP_OPT_ADD_PATH):
                    #// ----- Check the number of parameters
                    if i + 1 >= p_size:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    v_result_list[p_options_list[i]] = PclZipUtilTranslateWinPath(p_options_list[i + 1], False)
                    i += 1
                    break
                # end if
                if case(PCLZIP_OPT_TEMP_FILE_THRESHOLD):
                    #// ----- Check the number of parameters
                    if i + 1 >= p_size:
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        return PclZip.errorcode()
                    # end if
                    #// ----- Check for incompatible options
                    if (php_isset(lambda : v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Option '" + PclZipUtilOptionText(p_options_list[i]) + "' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'")
                        return PclZip.errorcode()
                    # end if
                    #// ----- Check the value
                    v_value = p_options_list[i + 1]
                    if (not is_integer(v_value)) or v_value < 0:
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Integer expected for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value (and convert it in bytes)
                    v_result_list[p_options_list[i]] = v_value * 1048576
                    i += 1
                    break
                # end if
                if case(PCLZIP_OPT_TEMP_FILE_ON):
                    #// ----- Check for incompatible options
                    if (php_isset(lambda : v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Option '" + PclZipUtilOptionText(p_options_list[i]) + "' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'")
                        return PclZip.errorcode()
                    # end if
                    v_result_list[p_options_list[i]] = True
                    break
                # end if
                if case(PCLZIP_OPT_TEMP_FILE_OFF):
                    #// ----- Check for incompatible options
                    if (php_isset(lambda : v_result_list[PCLZIP_OPT_TEMP_FILE_ON])):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Option '" + PclZipUtilOptionText(p_options_list[i]) + "' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'")
                        return PclZip.errorcode()
                    # end if
                    #// ----- Check for incompatible options
                    if (php_isset(lambda : v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Option '" + PclZipUtilOptionText(p_options_list[i]) + "' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'")
                        return PclZip.errorcode()
                    # end if
                    v_result_list[p_options_list[i]] = True
                    break
                # end if
                if case(PCLZIP_OPT_EXTRACT_DIR_RESTRICTION):
                    #// ----- Check the number of parameters
                    if i + 1 >= p_size:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    if php_is_string(p_options_list[i + 1]) and p_options_list[i + 1] != "":
                        v_result_list[p_options_list[i]] = PclZipUtilTranslateWinPath(p_options_list[i + 1], False)
                        i += 1
                    # end if
                    break
                # end if
                if case(PCLZIP_OPT_BY_NAME):
                    #// ----- Check the number of parameters
                    if i + 1 >= p_size:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    if php_is_string(p_options_list[i + 1]):
                        v_result_list[p_options_list[i]][0] = p_options_list[i + 1]
                    else:
                        if php_is_array(p_options_list[i + 1]):
                            v_result_list[p_options_list[i]] = p_options_list[i + 1]
                        else:
                            #// ----- Error log
                            PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                            #// ----- Return
                            return PclZip.errorcode()
                        # end if
                    # end if
                    i += 1
                    break
                # end if
                if case(PCLZIP_OPT_BY_EREG):
                    #// ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG
                    #// to PCLZIP_OPT_BY_PREG
                    p_options_list[i] = PCLZIP_OPT_BY_PREG
                # end if
                if case(PCLZIP_OPT_BY_PREG):
                    #// case PCLZIP_OPT_CRYPT :
                    #// ----- Check the number of parameters
                    if i + 1 >= p_size:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    if php_is_string(p_options_list[i + 1]):
                        v_result_list[p_options_list[i]] = p_options_list[i + 1]
                    else:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    i += 1
                    break
                # end if
                if case(PCLZIP_OPT_COMMENT):
                    pass
                # end if
                if case(PCLZIP_OPT_ADD_COMMENT):
                    pass
                # end if
                if case(PCLZIP_OPT_PREPEND_COMMENT):
                    #// ----- Check the number of parameters
                    if i + 1 >= p_size:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    if php_is_string(p_options_list[i + 1]):
                        v_result_list[p_options_list[i]] = p_options_list[i + 1]
                    else:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    i += 1
                    break
                # end if
                if case(PCLZIP_OPT_BY_INDEX):
                    #// ----- Check the number of parameters
                    if i + 1 >= p_size:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    v_work_list = Array()
                    if php_is_string(p_options_list[i + 1]):
                        #// ----- Remove spaces
                        p_options_list[i + 1] = php_strtr(p_options_list[i + 1], " ", "")
                        #// ----- Parse items
                        v_work_list = php_explode(",", p_options_list[i + 1])
                    else:
                        if is_integer(p_options_list[i + 1]):
                            v_work_list[0] = p_options_list[i + 1] + "-" + p_options_list[i + 1]
                        else:
                            if php_is_array(p_options_list[i + 1]):
                                v_work_list = p_options_list[i + 1]
                            else:
                                #// ----- Error log
                                PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Value must be integer, string or array for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                                #// ----- Return
                                return PclZip.errorcode()
                            # end if
                        # end if
                    # end if
                    #// ----- Reduce the index list
                    #// each index item in the list must be a couple with a start and
                    #// an end value : [0,3], [5-5], [8-10], ...
                    #// ----- Check the format of each item
                    v_sort_flag = False
                    v_sort_value = 0
                    j = 0
                    while j < sizeof(v_work_list):
                        
                        #// ----- Explode the item
                        v_item_list = php_explode("-", v_work_list[j])
                        v_size_item_list = sizeof(v_item_list)
                        #// ----- TBC : Here we might check that each item is a
                        #// real integer ...
                        #// ----- Look for single value
                        if v_size_item_list == 1:
                            #// ----- Set the option value
                            v_result_list[p_options_list[i]][j]["start"] = v_item_list[0]
                            v_result_list[p_options_list[i]][j]["end"] = v_item_list[0]
                        elif v_size_item_list == 2:
                            #// ----- Set the option value
                            v_result_list[p_options_list[i]][j]["start"] = v_item_list[0]
                            v_result_list[p_options_list[i]][j]["end"] = v_item_list[1]
                        else:
                            #// ----- Error log
                            PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Too many values in index range for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                            #// ----- Return
                            return PclZip.errorcode()
                        # end if
                        #// ----- Look for list sort
                        if v_result_list[p_options_list[i]][j]["start"] < v_sort_value:
                            v_sort_flag = True
                            #// ----- TBC : An automatic sort should be written ...
                            #// ----- Error log
                            PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Invalid order of index range for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                            #// ----- Return
                            return PclZip.errorcode()
                        # end if
                        v_sort_value = v_result_list[p_options_list[i]][j]["start"]
                        j += 1
                    # end while
                    #// ----- Sort the items
                    if v_sort_flag:
                        pass
                    # end if
                    #// ----- Next option
                    i += 1
                    break
                # end if
                if case(PCLZIP_OPT_REMOVE_ALL_PATH):
                    pass
                # end if
                if case(PCLZIP_OPT_EXTRACT_AS_STRING):
                    pass
                # end if
                if case(PCLZIP_OPT_NO_COMPRESSION):
                    pass
                # end if
                if case(PCLZIP_OPT_EXTRACT_IN_OUTPUT):
                    pass
                # end if
                if case(PCLZIP_OPT_REPLACE_NEWER):
                    pass
                # end if
                if case(PCLZIP_OPT_STOP_ON_ERROR):
                    v_result_list[p_options_list[i]] = True
                    break
                # end if
                if case(PCLZIP_OPT_SET_CHMOD):
                    #// ----- Check the number of parameters
                    if i + 1 >= p_size:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    v_result_list[p_options_list[i]] = p_options_list[i + 1]
                    i += 1
                    break
                # end if
                if case(PCLZIP_CB_PRE_EXTRACT):
                    pass
                # end if
                if case(PCLZIP_CB_POST_EXTRACT):
                    pass
                # end if
                if case(PCLZIP_CB_PRE_ADD):
                    pass
                # end if
                if case(PCLZIP_CB_POST_ADD):
                    #// for futur use
                    #// case PCLZIP_CB_PRE_DELETE :
                    #// case PCLZIP_CB_POST_DELETE :
                    #// case PCLZIP_CB_PRE_LIST :
                    #// case PCLZIP_CB_POST_LIST :
                    #// 
                    #// ----- Check the number of parameters
                    if i + 1 >= p_size:
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Get the value
                    v_function_name = p_options_list[i + 1]
                    #// ----- Check that the value is a valid existing function
                    if (not php_function_exists(v_function_name)):
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Function '" + v_function_name + "()' is not an existing function for option '" + PclZipUtilOptionText(p_options_list[i]) + "'")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                    #// ----- Set the attribute
                    v_result_list[p_options_list[i]] = v_function_name
                    i += 1
                    break
                # end if
                if case():
                    #// ----- Error log
                    PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Unknown parameter '" + p_options_list[i] + "'")
                    #// ----- Return
                    return PclZip.errorcode()
                # end if
            # end for
            #// ----- Next options
            i += 1
        # end while
        #// ----- Look for mandatory options
        if v_requested_options != False:
            key = reset(v_requested_options)
            while key:
                key = key(v_requested_options)
                #// ----- Look for mandatory option
                if v_requested_options[key] == "mandatory":
                    #// ----- Look if present
                    if (not (php_isset(lambda : v_result_list[key]))):
                        #// ----- Error log
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter " + PclZipUtilOptionText(key) + "(" + key + ")")
                        #// ----- Return
                        return PclZip.errorcode()
                    # end if
                # end if
                key = next(v_requested_options)
            # end while
        # end if
        #// ----- Look for default values
        if (not (php_isset(lambda : v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD]))):
            pass
        # end if
        #// ----- Return
        return v_result
    # end def privparseoptions
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privOptionDefaultThreshold()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privoptiondefaultthreshold(self, p_options=None):
        
        v_result = 1
        if (php_isset(lambda : p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) or (php_isset(lambda : p_options[PCLZIP_OPT_TEMP_FILE_OFF])):
            return v_result
        # end if
        #// ----- Get 'memory_limit' configuration value
        v_memory_limit = php_ini_get("memory_limit")
        v_memory_limit = php_trim(v_memory_limit)
        v_memory_limit_int = php_int(v_memory_limit)
        last = php_strtolower(php_substr(v_memory_limit, -1))
        if last == "g":
            #// $v_memory_limit_int = $v_memory_limit_int*1024*1024*1024;
            v_memory_limit_int = v_memory_limit_int * 1073741824
        # end if
        if last == "m":
            #// $v_memory_limit_int = $v_memory_limit_int*1024*1024;
            v_memory_limit_int = v_memory_limit_int * 1048576
        # end if
        if last == "k":
            v_memory_limit_int = v_memory_limit_int * 1024
        # end if
        p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor(v_memory_limit_int * PCLZIP_TEMPORARY_FILE_RATIO)
        #// ----- Sanity check : No threshold if value lower than 1M
        if p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576:
            p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = None
        # end if
        #// ----- Return
        return v_result
    # end def privoptiondefaultthreshold
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privFileDescrParseAtt()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// 1 on success.
    #// 0 on failure.
    #// --------------------------------------------------------------------------------
    def privfiledescrparseatt(self, p_file_list=None, p_filedescr=None, v_options=None, v_requested_options=False):
        
        v_result = 1
        #// ----- For each file in the list check the attributes
        for v_key,v_value in p_file_list:
            #// ----- Check if the option is supported
            if (not (php_isset(lambda : v_requested_options[v_key]))):
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file attribute '" + v_key + "' for this file")
                #// ----- Return
                return PclZip.errorcode()
            # end if
            #// ----- Look for attribute
            for case in Switch(v_key):
                if case(PCLZIP_ATT_FILE_NAME):
                    if (not php_is_string(v_value)):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " + gettype(v_value) + ". String expected for attribute '" + PclZipUtilOptionText(v_key) + "'")
                        return PclZip.errorcode()
                    # end if
                    p_filedescr["filename"] = PclZipUtilPathReduction(v_value)
                    if p_filedescr["filename"] == "":
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty filename for attribute '" + PclZipUtilOptionText(v_key) + "'")
                        return PclZip.errorcode()
                    # end if
                    break
                # end if
                if case(PCLZIP_ATT_FILE_NEW_SHORT_NAME):
                    if (not php_is_string(v_value)):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " + gettype(v_value) + ". String expected for attribute '" + PclZipUtilOptionText(v_key) + "'")
                        return PclZip.errorcode()
                    # end if
                    p_filedescr["new_short_name"] = PclZipUtilPathReduction(v_value)
                    if p_filedescr["new_short_name"] == "":
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty short filename for attribute '" + PclZipUtilOptionText(v_key) + "'")
                        return PclZip.errorcode()
                    # end if
                    break
                # end if
                if case(PCLZIP_ATT_FILE_NEW_FULL_NAME):
                    if (not php_is_string(v_value)):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " + gettype(v_value) + ". String expected for attribute '" + PclZipUtilOptionText(v_key) + "'")
                        return PclZip.errorcode()
                    # end if
                    p_filedescr["new_full_name"] = PclZipUtilPathReduction(v_value)
                    if p_filedescr["new_full_name"] == "":
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty full filename for attribute '" + PclZipUtilOptionText(v_key) + "'")
                        return PclZip.errorcode()
                    # end if
                    break
                # end if
                if case(PCLZIP_ATT_FILE_COMMENT):
                    if (not php_is_string(v_value)):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " + gettype(v_value) + ". String expected for attribute '" + PclZipUtilOptionText(v_key) + "'")
                        return PclZip.errorcode()
                    # end if
                    p_filedescr["comment"] = v_value
                    break
                # end if
                if case(PCLZIP_ATT_FILE_MTIME):
                    if (not is_integer(v_value)):
                        PclZip.priverrorlog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " + gettype(v_value) + ". Integer expected for attribute '" + PclZipUtilOptionText(v_key) + "'")
                        return PclZip.errorcode()
                    # end if
                    p_filedescr["mtime"] = v_value
                    break
                # end if
                if case(PCLZIP_ATT_FILE_CONTENT):
                    p_filedescr["content"] = v_value
                    break
                # end if
                if case():
                    #// ----- Error log
                    PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Unknown parameter '" + v_key + "'")
                    #// ----- Return
                    return PclZip.errorcode()
                # end if
            # end for
            #// ----- Look for mandatory options
            if v_requested_options != False:
                key = reset(v_requested_options)
                while key:
                    key = key(v_requested_options)
                    #// ----- Look for mandatory option
                    if v_requested_options[key] == "mandatory":
                        #// ----- Look if present
                        if (not (php_isset(lambda : p_file_list[key]))):
                            PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter " + PclZipUtilOptionText(key) + "(" + key + ")")
                            return PclZip.errorcode()
                        # end if
                    # end if
                    key = next(v_requested_options)
                # end while
            # end if
            pass
        # end for
        #// ----- Return
        return v_result
    # end def privfiledescrparseatt
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privFileDescrExpand()
    #// Description :
    #// This method look for each item of the list to see if its a file, a folder
    #// or a string to be added as file. For any other type of files (link, other)
    #// just ignore the item.
    #// Then prepare the information that will be stored for that file.
    #// When its a folder, expand the folder with all the files that are in that
    #// folder (recursively).
    #// Parameters :
    #// Return Values :
    #// 1 on success.
    #// 0 on failure.
    #// --------------------------------------------------------------------------------
    def privfiledescrexpand(self, p_filedescr_list=None, p_options=None):
        
        v_result = 1
        #// ----- Create a result list
        v_result_list = Array()
        #// ----- Look each entry
        i = 0
        while i < sizeof(p_filedescr_list):
            
            #// ----- Get filedescr
            v_descr = p_filedescr_list[i]
            #// ----- Reduce the filename
            v_descr["filename"] = PclZipUtilTranslateWinPath(v_descr["filename"], False)
            v_descr["filename"] = PclZipUtilPathReduction(v_descr["filename"])
            #// ----- Look for real file or folder
            if php_file_exists(v_descr["filename"]):
                if php_no_error(lambda: php_is_file(v_descr["filename"])):
                    v_descr["type"] = "file"
                else:
                    if php_no_error(lambda: php_is_dir(v_descr["filename"])):
                        v_descr["type"] = "folder"
                    else:
                        if php_no_error(lambda: php_is_link(v_descr["filename"])):
                            continue
                        else:
                            continue
                        # end if
                    # end if
                # end if
            else:
                if (php_isset(lambda : v_descr["content"])):
                    v_descr["type"] = "virtual_file"
                else:
                    #// ----- Error log
                    PclZip.priverrorlog(PCLZIP_ERR_MISSING_FILE, "File '" + v_descr["filename"] + "' does not exist")
                    #// ----- Return
                    return PclZip.errorcode()
                # end if
            # end if
            #// ----- Calculate the stored filename
            self.privcalculatestoredfilename(v_descr, p_options)
            #// ----- Add the descriptor in result list
            v_result_list[sizeof(v_result_list)] = v_descr
            #// ----- Look for folder
            if v_descr["type"] == "folder":
                #// ----- List of items in folder
                v_dirlist_descr = Array()
                v_dirlist_nb = 0
                v_folder_handler = php_no_error(lambda: php_opendir(v_descr["filename"]))
                if v_folder_handler:
                    while True:
                        v_item_handler = php_no_error(lambda: php_readdir(v_folder_handler))
                        if not (v_item_handler != False):
                            break
                        # end if
                        #// ----- Skip '.' and '..'
                        if v_item_handler == "." or v_item_handler == "..":
                            continue
                        # end if
                        #// ----- Compose the full filename
                        v_dirlist_descr[v_dirlist_nb]["filename"] = v_descr["filename"] + "/" + v_item_handler
                        #// ----- Look for different stored filename
                        #// Because the name of the folder was changed, the name of the
                        #// files/sub-folders also change
                        if v_descr["stored_filename"] != v_descr["filename"] and (not (php_isset(lambda : p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))):
                            if v_descr["stored_filename"] != "":
                                v_dirlist_descr[v_dirlist_nb]["new_full_name"] = v_descr["stored_filename"] + "/" + v_item_handler
                            else:
                                v_dirlist_descr[v_dirlist_nb]["new_full_name"] = v_item_handler
                            # end if
                        # end if
                        v_dirlist_nb += 1
                    # end while
                    php_no_error(lambda: php_closedir(v_folder_handler))
                else:
                    pass
                # end if
                #// ----- Expand each element of the list
                if v_dirlist_nb != 0:
                    #// ----- Expand
                    v_result = self.privfiledescrexpand(v_dirlist_descr, p_options)
                    if v_result != 1:
                        return v_result
                    # end if
                    #// ----- Concat the resulting list
                    v_result_list = php_array_merge(v_result_list, v_dirlist_descr)
                # end if
                v_dirlist_descr = None
            # end if
            i += 1
        # end while
        #// ----- Get the result list
        p_filedescr_list = v_result_list
        #// ----- Return
        return v_result
    # end def privfiledescrexpand
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privCreate()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privcreate(self, p_filedescr_list=None, p_result_list=None, p_options=None):
        
        v_result = 1
        v_list_detail = Array()
        #// ----- Magic quotes trick
        self.privdisablemagicquotes()
        #// ----- Open the file in write mode
        v_result = self.privopenfd("wb")
        if v_result != 1:
            #// ----- Return
            return v_result
        # end if
        #// ----- Add the list of files
        v_result = self.privaddlist(p_filedescr_list, p_result_list, p_options)
        #// ----- Close
        self.privclosefd()
        #// ----- Magic quotes trick
        self.privswapbackmagicquotes()
        #// ----- Return
        return v_result
    # end def privcreate
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privAdd()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privadd(self, p_filedescr_list=None, p_result_list=None, p_options=None):
        
        v_result = 1
        v_list_detail = Array()
        #// ----- Look if the archive exists or is empty
        if (not php_is_file(self.zipname)) or filesize(self.zipname) == 0:
            #// ----- Do a create
            v_result = self.privcreate(p_filedescr_list, p_result_list, p_options)
            #// ----- Return
            return v_result
        # end if
        #// ----- Magic quotes trick
        self.privdisablemagicquotes()
        #// ----- Open the zip file
        v_result = self.privopenfd("rb")
        if v_result != 1:
            #// ----- Magic quotes trick
            self.privswapbackmagicquotes()
            #// ----- Return
            return v_result
        # end if
        #// ----- Read the central directory information
        v_central_dir = Array()
        v_result = self.privreadendcentraldir(v_central_dir)
        if v_result != 1:
            self.privclosefd()
            self.privswapbackmagicquotes()
            return v_result
        # end if
        #// ----- Go to beginning of File
        php_no_error(lambda: rewind(self.zip_fd))
        #// ----- Creates a temporary file
        v_zip_temp_name = PCLZIP_TEMPORARY_DIR + uniqid("pclzip-") + ".tmp"
        #// ----- Open the temporary file in write mode
        v_zip_temp_fd = php_no_error(lambda: fopen(v_zip_temp_name, "wb"))
        if v_zip_temp_fd == 0:
            self.privclosefd()
            self.privswapbackmagicquotes()
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open temporary file '" + v_zip_temp_name + "' in binary write mode")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Copy the files from the archive to the temporary file
        #// TBC : Here I should better append the file and go back to erase the central dir
        v_size = v_central_dir["offset"]
        while True:
            
            if not (v_size != 0):
                break
            # end if
            v_read_size = v_size if v_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer = fread(self.zip_fd, v_read_size)
            php_no_error(lambda: fwrite(v_zip_temp_fd, v_buffer, v_read_size))
            v_size -= v_read_size
        # end while
        #// ----- Swap the file descriptor
        #// Here is a trick : I swap the temporary fd with the zip fd, in order to use
        #// the following methods on the temporary fil and not the real archive
        v_swap = self.zip_fd
        self.zip_fd = v_zip_temp_fd
        v_zip_temp_fd = v_swap
        #// ----- Add the files
        v_header_list = Array()
        v_result = self.privaddfilelist(p_filedescr_list, v_header_list, p_options)
        if v_result != 1:
            php_fclose(v_zip_temp_fd)
            self.privclosefd()
            php_no_error(lambda: unlink(v_zip_temp_name))
            self.privswapbackmagicquotes()
            #// ----- Return
            return v_result
        # end if
        #// ----- Store the offset of the central dir
        v_offset = php_no_error(lambda: ftell(self.zip_fd))
        #// ----- Copy the block of file headers from the old archive
        v_size = v_central_dir["size"]
        while True:
            
            if not (v_size != 0):
                break
            # end if
            v_read_size = v_size if v_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer = php_no_error(lambda: fread(v_zip_temp_fd, v_read_size))
            php_no_error(lambda: fwrite(self.zip_fd, v_buffer, v_read_size))
            v_size -= v_read_size
        # end while
        #// ----- Create the Central Dir files header
        i = 0
        v_count = 0
        while i < sizeof(v_header_list):
            
            #// ----- Create the file header
            if v_header_list[i]["status"] == "ok":
                v_result = self.privwritecentralfileheader(v_header_list[i])
                if v_result != 1:
                    php_fclose(v_zip_temp_fd)
                    self.privclosefd()
                    php_no_error(lambda: unlink(v_zip_temp_name))
                    self.privswapbackmagicquotes()
                    #// ----- Return
                    return v_result
                # end if
                v_count += 1
            # end if
            #// ----- Transform the header to a 'usable' info
            self.privconvertheader2fileinfo(v_header_list[i], p_result_list[i])
            i += 1
        # end while
        #// ----- Zip file comment
        v_comment = v_central_dir["comment"]
        if (php_isset(lambda : p_options[PCLZIP_OPT_COMMENT])):
            v_comment = p_options[PCLZIP_OPT_COMMENT]
        # end if
        if (php_isset(lambda : p_options[PCLZIP_OPT_ADD_COMMENT])):
            v_comment = v_comment + p_options[PCLZIP_OPT_ADD_COMMENT]
        # end if
        if (php_isset(lambda : p_options[PCLZIP_OPT_PREPEND_COMMENT])):
            v_comment = p_options[PCLZIP_OPT_PREPEND_COMMENT] + v_comment
        # end if
        #// ----- Calculate the size of the central header
        v_size = php_no_error(lambda: ftell(self.zip_fd)) - v_offset
        #// ----- Create the central dir footer
        v_result = self.privwritecentralheader(v_count + v_central_dir["entries"], v_size, v_offset, v_comment)
        if v_result != 1:
            v_header_list = None
            self.privswapbackmagicquotes()
            #// ----- Return
            return v_result
        # end if
        #// ----- Swap back the file descriptor
        v_swap = self.zip_fd
        self.zip_fd = v_zip_temp_fd
        v_zip_temp_fd = v_swap
        #// ----- Close
        self.privclosefd()
        #// ----- Close the temporary file
        php_no_error(lambda: php_fclose(v_zip_temp_fd))
        #// ----- Magic quotes trick
        self.privswapbackmagicquotes()
        #// ----- Delete the zip file
        #// TBC : I should test the result ...
        php_no_error(lambda: unlink(self.zipname))
        #// ----- Rename the temporary file
        #// TBC : I should test the result ...
        #// @rename($v_zip_temp_name, $this->zipname);
        PclZipUtilRename(v_zip_temp_name, self.zipname)
        #// ----- Return
        return v_result
    # end def privadd
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privOpenFd()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def privopenfd(self, p_mode=None):
        
        v_result = 1
        #// ----- Look if already open
        if self.zip_fd != 0:
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Zip file '" + self.zipname + "' already open")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Open the zip file
        self.zip_fd = php_no_error(lambda: fopen(self.zipname, p_mode))
        if self.zip_fd == 0:
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open archive '" + self.zipname + "' in " + p_mode + " mode")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Return
        return v_result
    # end def privopenfd
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privCloseFd()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def privclosefd(self):
        
        v_result = 1
        if self.zip_fd != 0:
            php_no_error(lambda: php_fclose(self.zip_fd))
        # end if
        self.zip_fd = 0
        #// ----- Return
        return v_result
    # end def privclosefd
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privAddList()
    #// Description :
    #// $p_add_dir and $p_remove_dir will give the ability to memorize a path which is
    #// different from the real path of the file. This is useful if you want to have PclTar
    #// running in any directory, and memorize relative path from an other directory.
    #// Parameters :
    #// $p_list : An array containing the file or directory names to add in the tar
    #// $p_result_list : list of added files with their properties (specially the status field)
    #// $p_add_dir : Path to add in the filename path archived
    #// $p_remove_dir : Path to remove in the filename path archived
    #// Return Values :
    #// --------------------------------------------------------------------------------
    #// function privAddList($p_list, &$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &$p_options)
    def privaddlist(self, p_filedescr_list=None, p_result_list=None, p_options=None):
        
        v_result = 1
        #// ----- Add the files
        v_header_list = Array()
        v_result = self.privaddfilelist(p_filedescr_list, v_header_list, p_options)
        if v_result != 1:
            #// ----- Return
            return v_result
        # end if
        #// ----- Store the offset of the central dir
        v_offset = php_no_error(lambda: ftell(self.zip_fd))
        #// ----- Create the Central Dir files header
        i = 0
        v_count = 0
        while i < sizeof(v_header_list):
            
            #// ----- Create the file header
            if v_header_list[i]["status"] == "ok":
                v_result = self.privwritecentralfileheader(v_header_list[i])
                if v_result != 1:
                    #// ----- Return
                    return v_result
                # end if
                v_count += 1
            # end if
            #// ----- Transform the header to a 'usable' info
            self.privconvertheader2fileinfo(v_header_list[i], p_result_list[i])
            i += 1
        # end while
        #// ----- Zip file comment
        v_comment = ""
        if (php_isset(lambda : p_options[PCLZIP_OPT_COMMENT])):
            v_comment = p_options[PCLZIP_OPT_COMMENT]
        # end if
        #// ----- Calculate the size of the central header
        v_size = php_no_error(lambda: ftell(self.zip_fd)) - v_offset
        #// ----- Create the central dir footer
        v_result = self.privwritecentralheader(v_count, v_size, v_offset, v_comment)
        if v_result != 1:
            v_header_list = None
            #// ----- Return
            return v_result
        # end if
        #// ----- Return
        return v_result
    # end def privaddlist
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privAddFileList()
    #// Description :
    #// Parameters :
    #// $p_filedescr_list : An array containing the file description
    #// or directory names to add in the zip
    #// $p_result_list : list of added files with their properties (specially the status field)
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privaddfilelist(self, p_filedescr_list=None, p_result_list=None, p_options=None):
        
        v_result = 1
        v_header = Array()
        #// ----- Recuperate the current number of elt in list
        v_nb = sizeof(p_result_list)
        #// ----- Loop on the files
        j = 0
        while j < sizeof(p_filedescr_list) and v_result == 1:
            
            #// ----- Format the filename
            p_filedescr_list[j]["filename"] = PclZipUtilTranslateWinPath(p_filedescr_list[j]["filename"], False)
            #// ----- Skip empty file names
            #// TBC : Can this be possible ? not checked in DescrParseAtt ?
            if p_filedescr_list[j]["filename"] == "":
                continue
            # end if
            #// ----- Check the filename
            if p_filedescr_list[j]["type"] != "virtual_file" and (not php_file_exists(p_filedescr_list[j]["filename"])):
                PclZip.priverrorlog(PCLZIP_ERR_MISSING_FILE, "File '" + p_filedescr_list[j]["filename"] + "' does not exist")
                return PclZip.errorcode()
            # end if
            #// ----- Look if it is a file or a dir with no all path remove option
            #// or a dir with all its path removed
            #// if (   (is_file($p_filedescr_list[$j]['filename']))
            #// || (   is_dir($p_filedescr_list[$j]['filename'])
            if p_filedescr_list[j]["type"] == "file" or p_filedescr_list[j]["type"] == "virtual_file" or p_filedescr_list[j]["type"] == "folder" and (not (php_isset(lambda : p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) or (not p_options[PCLZIP_OPT_REMOVE_ALL_PATH]):
                #// ----- Add the file
                v_result = self.privaddfile(p_filedescr_list[j], v_header, p_options)
                if v_result != 1:
                    return v_result
                # end if
                #// ----- Store the file infos
                p_result_list[v_nb] = v_header
                v_nb += 1
            # end if
            j += 1
        # end while
        #// ----- Return
        return v_result
    # end def privaddfilelist
    v_nb += 1
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privAddFile()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privaddfile(self, p_filedescr=None, p_header=None, p_options=None):
        
        v_result = 1
        #// ----- Working variable
        p_filename = p_filedescr["filename"]
        #// TBC : Already done in the fileAtt check ... ?
        if p_filename == "":
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file list parameter (invalid or empty list)")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Look for a stored different filename
        #// TBC : Removed
        #// if (isset($p_filedescr['stored_filename'])) {
        #// $v_stored_filename = $p_filedescr['stored_filename'];
        #// }
        #// else {
        #// $v_stored_filename = $p_filedescr['stored_filename'];
        #// }
        #// 
        #// ----- Set the file properties
        clearstatcache()
        p_header["version"] = 20
        p_header["version_extracted"] = 10
        p_header["flag"] = 0
        p_header["compression"] = 0
        p_header["crc"] = 0
        p_header["compressed_size"] = 0
        p_header["filename_len"] = php_strlen(p_filename)
        p_header["extra_len"] = 0
        p_header["disk"] = 0
        p_header["internal"] = 0
        p_header["offset"] = 0
        p_header["filename"] = p_filename
        #// TBC : Removed    $p_header['stored_filename'] = $v_stored_filename;
        p_header["stored_filename"] = p_filedescr["stored_filename"]
        p_header["extra"] = ""
        p_header["status"] = "ok"
        p_header["index"] = -1
        #// ----- Look for regular file
        if p_filedescr["type"] == "file":
            p_header["external"] = 0
            p_header["size"] = filesize(p_filename)
        else:
            if p_filedescr["type"] == "folder":
                p_header["external"] = 16
                p_header["mtime"] = filemtime(p_filename)
                p_header["size"] = filesize(p_filename)
            else:
                if p_filedescr["type"] == "virtual_file":
                    p_header["external"] = 0
                    p_header["size"] = php_strlen(p_filedescr["content"])
                # end if
            # end if
        # end if
        #// ----- Look for filetime
        if (php_isset(lambda : p_filedescr["mtime"])):
            p_header["mtime"] = p_filedescr["mtime"]
        else:
            if p_filedescr["type"] == "virtual_file":
                p_header["mtime"] = time()
            else:
                p_header["mtime"] = filemtime(p_filename)
            # end if
        # end if
        #// ------ Look for file comment
        if (php_isset(lambda : p_filedescr["comment"])):
            p_header["comment_len"] = php_strlen(p_filedescr["comment"])
            p_header["comment"] = p_filedescr["comment"]
        else:
            p_header["comment_len"] = 0
            p_header["comment"] = ""
        # end if
        #// ----- Look for pre-add callback
        if (php_isset(lambda : p_options[PCLZIP_CB_PRE_ADD])):
            #// ----- Generate a local information
            v_local_header = Array()
            self.privconvertheader2fileinfo(p_header, v_local_header)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result = p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, v_local_header)
            if v_result == 0:
                #// ----- Change the file status
                p_header["status"] = "skipped"
                v_result = 1
            # end if
            #// ----- Update the information
            #// Only some fields can be modified
            if p_header["stored_filename"] != v_local_header["stored_filename"]:
                p_header["stored_filename"] = PclZipUtilPathReduction(v_local_header["stored_filename"])
            # end if
        # end if
        #// ----- Look for empty stored filename
        if p_header["stored_filename"] == "":
            p_header["status"] = "filtered"
        # end if
        #// ----- Check the path length
        if php_strlen(p_header["stored_filename"]) > 255:
            p_header["status"] = "filename_too_long"
        # end if
        #// ----- Look if no error, or file not skipped
        if p_header["status"] == "ok":
            #// ----- Look for a file
            if p_filedescr["type"] == "file":
                #// ----- Look for using temporary file to zip
                if (not (php_isset(lambda : p_options[PCLZIP_OPT_TEMP_FILE_OFF]))) and (php_isset(lambda : p_options[PCLZIP_OPT_TEMP_FILE_ON])) or (php_isset(lambda : p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) and p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= p_header["size"]:
                    v_result = self.privaddfileusingtempfile(p_filedescr, p_header, p_options)
                    if v_result < PCLZIP_ERR_NO_ERROR:
                        return v_result
                    # end if
                else:
                    #// ----- Open the source file
                    v_file = php_no_error(lambda: fopen(p_filename, "rb"))
                    if v_file == 0:
                        PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, str("Unable to open file '") + str(p_filename) + str("' in binary read mode"))
                        return PclZip.errorcode()
                    # end if
                    #// ----- Read the file content
                    v_content = php_no_error(lambda: fread(v_file, p_header["size"]))
                    #// ----- Close the file
                    php_no_error(lambda: php_fclose(v_file))
                    #// ----- Calculate the CRC
                    p_header["crc"] = php_no_error(lambda: crc32(v_content))
                    #// ----- Look for no compression
                    if p_options[PCLZIP_OPT_NO_COMPRESSION]:
                        #// ----- Set header parameters
                        p_header["compressed_size"] = p_header["size"]
                        p_header["compression"] = 0
                    else:
                        #// ----- Compress the content
                        v_content = php_no_error(lambda: gzdeflate(v_content))
                        #// ----- Set header parameters
                        p_header["compressed_size"] = php_strlen(v_content)
                        p_header["compression"] = 8
                    # end if
                    #// ----- Call the header generation
                    v_result = self.privwritefileheader(p_header)
                    if v_result != 1:
                        php_no_error(lambda: php_fclose(v_file))
                        return v_result
                    # end if
                    #// ----- Write the compressed (or not) content
                    php_no_error(lambda: fwrite(self.zip_fd, v_content, p_header["compressed_size"]))
                # end if
            else:
                if p_filedescr["type"] == "virtual_file":
                    v_content = p_filedescr["content"]
                    #// ----- Calculate the CRC
                    p_header["crc"] = php_no_error(lambda: crc32(v_content))
                    #// ----- Look for no compression
                    if p_options[PCLZIP_OPT_NO_COMPRESSION]:
                        #// ----- Set header parameters
                        p_header["compressed_size"] = p_header["size"]
                        p_header["compression"] = 0
                    else:
                        #// ----- Compress the content
                        v_content = php_no_error(lambda: gzdeflate(v_content))
                        #// ----- Set header parameters
                        p_header["compressed_size"] = php_strlen(v_content)
                        p_header["compression"] = 8
                    # end if
                    #// ----- Call the header generation
                    v_result = self.privwritefileheader(p_header)
                    if v_result != 1:
                        php_no_error(lambda: php_fclose(v_file))
                        return v_result
                    # end if
                    #// ----- Write the compressed (or not) content
                    php_no_error(lambda: fwrite(self.zip_fd, v_content, p_header["compressed_size"]))
                else:
                    if p_filedescr["type"] == "folder":
                        #// ----- Look for directory last '/'
                        if php_no_error(lambda: php_substr(p_header["stored_filename"], -1)) != "/":
                            p_header["stored_filename"] += "/"
                        # end if
                        #// ----- Set the file properties
                        p_header["size"] = 0
                        #// $p_header['external'] = 0x41FF0010;   // Value for a folder : to be checked
                        p_header["external"] = 16
                        #// Value for a folder : to be checked
                        #// ----- Call the header generation
                        v_result = self.privwritefileheader(p_header)
                        if v_result != 1:
                            return v_result
                        # end if
                    # end if
                # end if
            # end if
        # end if
        #// ----- Look for post-add callback
        if (php_isset(lambda : p_options[PCLZIP_CB_POST_ADD])):
            #// ----- Generate a local information
            v_local_header = Array()
            self.privconvertheader2fileinfo(p_header, v_local_header)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result = p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, v_local_header)
            if v_result == 0:
                #// ----- Ignored
                v_result = 1
            # end if
            pass
        # end if
        #// ----- Return
        return v_result
    # end def privaddfile
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privAddFileUsingTempFile()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privaddfileusingtempfile(self, p_filedescr=None, p_header=None, p_options=None):
        
        v_result = PCLZIP_ERR_NO_ERROR
        #// ----- Working variable
        p_filename = p_filedescr["filename"]
        #// ----- Open the source file
        v_file = php_no_error(lambda: fopen(p_filename, "rb"))
        if v_file == 0:
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, str("Unable to open file '") + str(p_filename) + str("' in binary read mode"))
            return PclZip.errorcode()
        # end if
        #// ----- Creates a compressed temporary file
        v_gzip_temp_name = PCLZIP_TEMPORARY_DIR + uniqid("pclzip-") + ".gz"
        v_file_compressed = php_no_error(lambda: gzopen(v_gzip_temp_name, "wb"))
        if v_file_compressed == 0:
            php_fclose(v_file)
            PclZip.priverrorlog(PCLZIP_ERR_WRITE_OPEN_FAIL, "Unable to open temporary file '" + v_gzip_temp_name + "' in binary write mode")
            return PclZip.errorcode()
        # end if
        #// ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
        v_size = filesize(p_filename)
        while True:
            
            if not (v_size != 0):
                break
            # end if
            v_read_size = v_size if v_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer = php_no_error(lambda: fread(v_file, v_read_size))
            #// $v_binary_data = pack('a'.$v_read_size, $v_buffer);
            php_no_error(lambda: gzputs(v_file_compressed, v_buffer, v_read_size))
            v_size -= v_read_size
        # end while
        #// ----- Close the file
        php_no_error(lambda: php_fclose(v_file))
        php_no_error(lambda: gzclose(v_file_compressed))
        #// ----- Check the minimum file size
        if filesize(v_gzip_temp_name) < 18:
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "gzip temporary file '" + v_gzip_temp_name + "' has invalid filesize - should be minimum 18 bytes")
            return PclZip.errorcode()
        # end if
        #// ----- Extract the compressed attributes
        v_file_compressed = php_no_error(lambda: fopen(v_gzip_temp_name, "rb"))
        if v_file_compressed == 0:
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open temporary file '" + v_gzip_temp_name + "' in binary read mode")
            return PclZip.errorcode()
        # end if
        #// ----- Read the gzip file header
        v_binary_data = php_no_error(lambda: fread(v_file_compressed, 10))
        v_data_header = unpack("a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os", v_binary_data)
        #// ----- Check some parameters
        v_data_header["os"] = bin2hex(v_data_header["os"])
        #// ----- Read the gzip file footer
        php_no_error(lambda: fseek(v_file_compressed, filesize(v_gzip_temp_name) - 8))
        v_binary_data = php_no_error(lambda: fread(v_file_compressed, 8))
        v_data_footer = unpack("Vcrc/Vcompressed_size", v_binary_data)
        #// ----- Set the attributes
        p_header["compression"] = php_ord(v_data_header["cm"])
        #// $p_header['mtime'] = $v_data_header['mtime'];
        p_header["crc"] = v_data_footer["crc"]
        p_header["compressed_size"] = filesize(v_gzip_temp_name) - 18
        #// ----- Close the file
        php_no_error(lambda: php_fclose(v_file_compressed))
        #// ----- Call the header generation
        v_result = self.privwritefileheader(p_header)
        if v_result != 1:
            return v_result
        # end if
        #// ----- Add the compressed data
        v_file_compressed = php_no_error(lambda: fopen(v_gzip_temp_name, "rb"))
        if v_file_compressed == 0:
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open temporary file '" + v_gzip_temp_name + "' in binary read mode")
            return PclZip.errorcode()
        # end if
        #// ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
        fseek(v_file_compressed, 10)
        v_size = p_header["compressed_size"]
        while True:
            
            if not (v_size != 0):
                break
            # end if
            v_read_size = v_size if v_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer = php_no_error(lambda: fread(v_file_compressed, v_read_size))
            #// $v_binary_data = pack('a'.$v_read_size, $v_buffer);
            php_no_error(lambda: fwrite(self.zip_fd, v_buffer, v_read_size))
            v_size -= v_read_size
        # end while
        #// ----- Close the file
        php_no_error(lambda: php_fclose(v_file_compressed))
        #// ----- Unlink the temporary file
        php_no_error(lambda: unlink(v_gzip_temp_name))
        #// ----- Return
        return v_result
    # end def privaddfileusingtempfile
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privCalculateStoredFilename()
    #// Description :
    #// Based on file descriptor properties and global options, this method
    #// calculate the filename that will be stored in the archive.
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privcalculatestoredfilename(self, p_filedescr=None, p_options=None):
        
        v_result = 1
        #// ----- Working variables
        p_filename = p_filedescr["filename"]
        if (php_isset(lambda : p_options[PCLZIP_OPT_ADD_PATH])):
            p_add_dir = p_options[PCLZIP_OPT_ADD_PATH]
        else:
            p_add_dir = ""
        # end if
        if (php_isset(lambda : p_options[PCLZIP_OPT_REMOVE_PATH])):
            p_remove_dir = p_options[PCLZIP_OPT_REMOVE_PATH]
        else:
            p_remove_dir = ""
        # end if
        if (php_isset(lambda : p_options[PCLZIP_OPT_REMOVE_ALL_PATH])):
            p_remove_all_dir = p_options[PCLZIP_OPT_REMOVE_ALL_PATH]
        else:
            p_remove_all_dir = 0
        # end if
        #// ----- Look for full name change
        if (php_isset(lambda : p_filedescr["new_full_name"])):
            #// ----- Remove drive letter if any
            v_stored_filename = PclZipUtilTranslateWinPath(p_filedescr["new_full_name"])
        else:
            #// ----- Look for short name change
            #// Its when we change just the filename but not the path
            if (php_isset(lambda : p_filedescr["new_short_name"])):
                v_path_info = pathinfo(p_filename)
                v_dir = ""
                if v_path_info["dirname"] != "":
                    v_dir = v_path_info["dirname"] + "/"
                # end if
                v_stored_filename = v_dir + p_filedescr["new_short_name"]
            else:
                #// ----- Calculate the stored filename
                v_stored_filename = p_filename
            # end if
            #// ----- Look for all path to remove
            if p_remove_all_dir:
                v_stored_filename = php_basename(p_filename)
            else:
                if p_remove_dir != "":
                    if php_substr(p_remove_dir, -1) != "/":
                        p_remove_dir += "/"
                    # end if
                    if php_substr(p_filename, 0, 2) == "./" or php_substr(p_remove_dir, 0, 2) == "./":
                        if php_substr(p_filename, 0, 2) == "./" and php_substr(p_remove_dir, 0, 2) != "./":
                            p_remove_dir = "./" + p_remove_dir
                        # end if
                        if php_substr(p_filename, 0, 2) != "./" and php_substr(p_remove_dir, 0, 2) == "./":
                            p_remove_dir = php_substr(p_remove_dir, 2)
                        # end if
                    # end if
                    v_compare = PclZipUtilPathInclusion(p_remove_dir, v_stored_filename)
                    if v_compare > 0:
                        if v_compare == 2:
                            v_stored_filename = ""
                        else:
                            v_stored_filename = php_substr(v_stored_filename, php_strlen(p_remove_dir))
                        # end if
                    # end if
                # end if
            # end if
            #// ----- Remove drive letter if any
            v_stored_filename = PclZipUtilTranslateWinPath(v_stored_filename)
            #// ----- Look for path to add
            if p_add_dir != "":
                if php_substr(p_add_dir, -1) == "/":
                    v_stored_filename = p_add_dir + v_stored_filename
                else:
                    v_stored_filename = p_add_dir + "/" + v_stored_filename
                # end if
            # end if
        # end if
        #// ----- Filename (reduce the path of stored name)
        v_stored_filename = PclZipUtilPathReduction(v_stored_filename)
        p_filedescr["stored_filename"] = v_stored_filename
        #// ----- Return
        return v_result
    # end def privcalculatestoredfilename
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privWriteFileHeader()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privwritefileheader(self, p_header=None):
        
        v_result = 1
        #// ----- Store the offset position of the file
        p_header["offset"] = ftell(self.zip_fd)
        #// ----- Transform UNIX mtime to DOS format mdate/mtime
        v_date = getdate(p_header["mtime"])
        v_mtime = v_date["hours"] << 11 + v_date["minutes"] << 5 + v_date["seconds"] / 2
        v_mdate = v_date["year"] - 1980 << 9 + v_date["mon"] << 5 + v_date["mday"]
        #// ----- Packed data
        v_binary_data = pack("VvvvvvVVVvv", 67324752, p_header["version_extracted"], p_header["flag"], p_header["compression"], v_mtime, v_mdate, p_header["crc"], p_header["compressed_size"], p_header["size"], php_strlen(p_header["stored_filename"]), p_header["extra_len"])
        #// ----- Write the first 148 bytes of the header in the archive
        fputs(self.zip_fd, v_binary_data, 30)
        #// ----- Write the variable fields
        if php_strlen(p_header["stored_filename"]) != 0:
            fputs(self.zip_fd, p_header["stored_filename"], php_strlen(p_header["stored_filename"]))
        # end if
        if p_header["extra_len"] != 0:
            fputs(self.zip_fd, p_header["extra"], p_header["extra_len"])
        # end if
        #// ----- Return
        return v_result
    # end def privwritefileheader
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privWriteCentralFileHeader()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privwritecentralfileheader(self, p_header=None):
        
        v_result = 1
        #// TBC
        #// for(reset($p_header); $key = key($p_header); next($p_header)) {
        #// }
        #// ----- Transform UNIX mtime to DOS format mdate/mtime
        v_date = getdate(p_header["mtime"])
        v_mtime = v_date["hours"] << 11 + v_date["minutes"] << 5 + v_date["seconds"] / 2
        v_mdate = v_date["year"] - 1980 << 9 + v_date["mon"] << 5 + v_date["mday"]
        #// ----- Packed data
        v_binary_data = pack("VvvvvvvVVVvvvvvVV", 33639248, p_header["version"], p_header["version_extracted"], p_header["flag"], p_header["compression"], v_mtime, v_mdate, p_header["crc"], p_header["compressed_size"], p_header["size"], php_strlen(p_header["stored_filename"]), p_header["extra_len"], p_header["comment_len"], p_header["disk"], p_header["internal"], p_header["external"], p_header["offset"])
        #// ----- Write the 42 bytes of the header in the zip file
        fputs(self.zip_fd, v_binary_data, 46)
        #// ----- Write the variable fields
        if php_strlen(p_header["stored_filename"]) != 0:
            fputs(self.zip_fd, p_header["stored_filename"], php_strlen(p_header["stored_filename"]))
        # end if
        if p_header["extra_len"] != 0:
            fputs(self.zip_fd, p_header["extra"], p_header["extra_len"])
        # end if
        if p_header["comment_len"] != 0:
            fputs(self.zip_fd, p_header["comment"], p_header["comment_len"])
        # end if
        #// ----- Return
        return v_result
    # end def privwritecentralfileheader
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privWriteCentralHeader()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privwritecentralheader(self, p_nb_entries=None, p_size=None, p_offset=None, p_comment=None):
        
        v_result = 1
        #// ----- Packed data
        v_binary_data = pack("VvvvvVVv", 101010256, 0, 0, p_nb_entries, p_nb_entries, p_size, p_offset, php_strlen(p_comment))
        #// ----- Write the 22 bytes of the header in the zip file
        fputs(self.zip_fd, v_binary_data, 22)
        #// ----- Write the variable fields
        if php_strlen(p_comment) != 0:
            fputs(self.zip_fd, p_comment, php_strlen(p_comment))
        # end if
        #// ----- Return
        return v_result
    # end def privwritecentralheader
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privList()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privlist(self, p_list=None):
        
        v_result = 1
        #// ----- Magic quotes trick
        self.privdisablemagicquotes()
        #// ----- Open the zip file
        self.zip_fd = php_no_error(lambda: fopen(self.zipname, "rb"))
        if self.zip_fd == 0:
            #// ----- Magic quotes trick
            self.privswapbackmagicquotes()
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open archive '" + self.zipname + "' in binary read mode")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Read the central directory information
        v_central_dir = Array()
        v_result = self.privreadendcentraldir(v_central_dir)
        if v_result != 1:
            self.privswapbackmagicquotes()
            return v_result
        # end if
        #// ----- Go to beginning of Central Dir
        php_no_error(lambda: rewind(self.zip_fd))
        if php_no_error(lambda: fseek(self.zip_fd, v_central_dir["offset"])):
            self.privswapbackmagicquotes()
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, "Invalid archive size")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Read each entry
        i = 0
        while i < v_central_dir["entries"]:
            
            #// ----- Read the file header
            v_result = self.privreadcentralfileheader(v_header)
            if v_result != 1:
                self.privswapbackmagicquotes()
                return v_result
            # end if
            v_header["index"] = i
            #// ----- Get the only interesting attributes
            self.privconvertheader2fileinfo(v_header, p_list[i])
            v_header = None
            i += 1
        # end while
        #// ----- Close the zip file
        self.privclosefd()
        #// ----- Magic quotes trick
        self.privswapbackmagicquotes()
        #// ----- Return
        return v_result
    # end def privlist
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privConvertHeader2FileInfo()
    #// Description :
    #// This function takes the file information from the central directory
    #// entries and extract the interesting parameters that will be given back.
    #// The resulting file infos are set in the array $p_info
    #// $p_info['filename'] : Filename with full path. Given by user (add),
    #// extracted in the filesystem (extract).
    #// $p_info['stored_filename'] : Stored filename in the archive.
    #// $p_info['size'] = Size of the file.
    #// $p_info['compressed_size'] = Compressed size of the file.
    #// $p_info['mtime'] = Last modification date of the file.
    #// $p_info['comment'] = Comment associated with the file.
    #// $p_info['folder'] = true/false : indicates if the entry is a folder or not.
    #// $p_info['status'] = status of the action on the file.
    #// $p_info['crc'] = CRC of the file content.
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privconvertheader2fileinfo(self, p_header=None, p_info=None):
        
        v_result = 1
        #// ----- Get the interesting attributes
        v_temp_path = PclZipUtilPathReduction(p_header["filename"])
        p_info["filename"] = v_temp_path
        v_temp_path = PclZipUtilPathReduction(p_header["stored_filename"])
        p_info["stored_filename"] = v_temp_path
        p_info["size"] = p_header["size"]
        p_info["compressed_size"] = p_header["compressed_size"]
        p_info["mtime"] = p_header["mtime"]
        p_info["comment"] = p_header["comment"]
        p_info["folder"] = p_header["external"] & 16 == 16
        p_info["index"] = p_header["index"]
        p_info["status"] = p_header["status"]
        p_info["crc"] = p_header["crc"]
        #// ----- Return
        return v_result
    # end def privconvertheader2fileinfo
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privExtractByRule()
    #// Description :
    #// Extract a file or directory depending of rules (by index, by name, ...)
    #// Parameters :
    #// $p_file_list : An array where will be placed the properties of each
    #// extracted file
    #// $p_path : Path to add while writing the extracted files
    #// $p_remove_path : Path to remove (from the file memorized path) while writing the
    #// extracted files. If the path does not match the file path,
    #// the file is extracted with its memorized path.
    #// $p_remove_path does not apply to 'list' mode.
    #// $p_path and $p_remove_path are commulative.
    #// Return Values :
    #// 1 on success,0 or less on error (see error code list)
    #// --------------------------------------------------------------------------------
    def privextractbyrule(self, p_file_list=None, p_path=None, p_remove_path=None, p_remove_all_path=None, p_options=None):
        
        v_result = 1
        #// ----- Magic quotes trick
        self.privdisablemagicquotes()
        #// ----- Check the path
        if p_path == "" or php_substr(p_path, 0, 1) != "/" and php_substr(p_path, 0, 3) != "../" and php_substr(p_path, 1, 2) != ":/":
            p_path = "./" + p_path
        # end if
        #// ----- Reduce the path last (and duplicated) '/'
        if p_path != "./" and p_path != "/":
            #// ----- Look for the path end '/'
            while True:
                
                if not (php_substr(p_path, -1) == "/"):
                    break
                # end if
                p_path = php_substr(p_path, 0, php_strlen(p_path) - 1)
            # end while
        # end if
        #// ----- Look for path to remove format (should end by /)
        if p_remove_path != "" and php_substr(p_remove_path, -1) != "/":
            p_remove_path += "/"
        # end if
        p_remove_path_size = php_strlen(p_remove_path)
        #// ----- Open the zip file
        v_result = self.privopenfd("rb")
        if v_result != 1:
            self.privswapbackmagicquotes()
            return v_result
        # end if
        #// ----- Read the central directory information
        v_central_dir = Array()
        v_result = self.privreadendcentraldir(v_central_dir)
        if v_result != 1:
            #// ----- Close the zip file
            self.privclosefd()
            self.privswapbackmagicquotes()
            return v_result
        # end if
        #// ----- Start at beginning of Central Dir
        v_pos_entry = v_central_dir["offset"]
        #// ----- Read each entry
        j_start = 0
        i = 0
        v_nb_extracted = 0
        while i < v_central_dir["entries"]:
            
            #// ----- Read next Central dir entry
            php_no_error(lambda: rewind(self.zip_fd))
            if php_no_error(lambda: fseek(self.zip_fd, v_pos_entry)):
                #// ----- Close the zip file
                self.privclosefd()
                self.privswapbackmagicquotes()
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, "Invalid archive size")
                #// ----- Return
                return PclZip.errorcode()
            # end if
            #// ----- Read the file header
            v_header = Array()
            v_result = self.privreadcentralfileheader(v_header)
            if v_result != 1:
                #// ----- Close the zip file
                self.privclosefd()
                self.privswapbackmagicquotes()
                return v_result
            # end if
            #// ----- Store the index
            v_header["index"] = i
            #// ----- Store the file position
            v_pos_entry = ftell(self.zip_fd)
            #// ----- Look for the specific extract rules
            v_extract = False
            #// ----- Look for extract by name rule
            if (php_isset(lambda : p_options[PCLZIP_OPT_BY_NAME])) and p_options[PCLZIP_OPT_BY_NAME] != 0:
                #// ----- Look if the filename is in the list
                j = 0
                while j < sizeof(p_options[PCLZIP_OPT_BY_NAME]) and (not v_extract):
                    
                    #// ----- Look for a directory
                    if php_substr(p_options[PCLZIP_OPT_BY_NAME][j], -1) == "/":
                        #// ----- Look if the directory is in the filename path
                        if php_strlen(v_header["stored_filename"]) > php_strlen(p_options[PCLZIP_OPT_BY_NAME][j]) and php_substr(v_header["stored_filename"], 0, php_strlen(p_options[PCLZIP_OPT_BY_NAME][j])) == p_options[PCLZIP_OPT_BY_NAME][j]:
                            v_extract = True
                        # end if
                        #// ----- Look for a filename
                    elif v_header["stored_filename"] == p_options[PCLZIP_OPT_BY_NAME][j]:
                        v_extract = True
                    # end if
                    j += 1
                # end while
            else:
                if (php_isset(lambda : p_options[PCLZIP_OPT_BY_PREG])) and p_options[PCLZIP_OPT_BY_PREG] != "":
                    if php_preg_match(p_options[PCLZIP_OPT_BY_PREG], v_header["stored_filename"]):
                        v_extract = True
                    # end if
                else:
                    if (php_isset(lambda : p_options[PCLZIP_OPT_BY_INDEX])) and p_options[PCLZIP_OPT_BY_INDEX] != 0:
                        #// ----- Look if the index is in the list
                        j = j_start
                        while j < sizeof(p_options[PCLZIP_OPT_BY_INDEX]) and (not v_extract):
                            
                            if i >= p_options[PCLZIP_OPT_BY_INDEX][j]["start"] and i <= p_options[PCLZIP_OPT_BY_INDEX][j]["end"]:
                                v_extract = True
                            # end if
                            if i >= p_options[PCLZIP_OPT_BY_INDEX][j]["end"]:
                                j_start = j + 1
                            # end if
                            if p_options[PCLZIP_OPT_BY_INDEX][j]["start"] > i:
                                break
                            # end if
                            j += 1
                        # end while
                    else:
                        v_extract = True
                    # end if
                # end if
            # end if
            #// ----- Check compression method
            if v_extract and v_header["compression"] != 8 and v_header["compression"] != 0:
                v_header["status"] = "unsupported_compression"
                #// ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                if (php_isset(lambda : p_options[PCLZIP_OPT_STOP_ON_ERROR])) and p_options[PCLZIP_OPT_STOP_ON_ERROR] == True:
                    self.privswapbackmagicquotes()
                    PclZip.priverrorlog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION, "Filename '" + v_header["stored_filename"] + "' is " + "compressed by an unsupported compression " + "method (" + v_header["compression"] + ") ")
                    return PclZip.errorcode()
                # end if
            # end if
            #// ----- Check encrypted files
            if v_extract and v_header["flag"] & 1 == 1:
                v_header["status"] = "unsupported_encryption"
                #// ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                if (php_isset(lambda : p_options[PCLZIP_OPT_STOP_ON_ERROR])) and p_options[PCLZIP_OPT_STOP_ON_ERROR] == True:
                    self.privswapbackmagicquotes()
                    PclZip.priverrorlog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, "Unsupported encryption for " + " filename '" + v_header["stored_filename"] + "'")
                    return PclZip.errorcode()
                # end if
            # end if
            #// ----- Look for real extraction
            if v_extract and v_header["status"] != "ok":
                v_result = self.privconvertheader2fileinfo(v_header, p_file_list[v_nb_extracted])
                v_nb_extracted += 1
                if v_result != 1:
                    self.privclosefd()
                    self.privswapbackmagicquotes()
                    return v_result
                # end if
                v_extract = False
            # end if
            #// ----- Look for real extraction
            if v_extract:
                #// ----- Go to the file position
                php_no_error(lambda: rewind(self.zip_fd))
                if php_no_error(lambda: fseek(self.zip_fd, v_header["offset"])):
                    #// ----- Close the zip file
                    self.privclosefd()
                    self.privswapbackmagicquotes()
                    #// ----- Error log
                    PclZip.priverrorlog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, "Invalid archive size")
                    #// ----- Return
                    return PclZip.errorcode()
                # end if
                #// ----- Look for extraction as string
                if p_options[PCLZIP_OPT_EXTRACT_AS_STRING]:
                    v_string = ""
                    #// ----- Extracting the file
                    v_result1 = self.privextractfileasstring(v_header, v_string, p_options)
                    if v_result1 < 1:
                        self.privclosefd()
                        self.privswapbackmagicquotes()
                        return v_result1
                    # end if
                    #// ----- Get the only interesting attributes
                    v_result = self.privconvertheader2fileinfo(v_header, p_file_list[v_nb_extracted])
                    if v_result != 1:
                        #// ----- Close the zip file
                        self.privclosefd()
                        self.privswapbackmagicquotes()
                        return v_result
                    # end if
                    #// ----- Set the file content
                    p_file_list[v_nb_extracted]["content"] = v_string
                    #// ----- Next extracted file
                    v_nb_extracted += 1
                    #// ----- Look for user callback abort
                    if v_result1 == 2:
                        break
                    # end if
                    #// ----- Look for extraction in standard output
                elif (php_isset(lambda : p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) and p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT]:
                    #// ----- Extracting the file in standard output
                    v_result1 = self.privextractfileinoutput(v_header, p_options)
                    if v_result1 < 1:
                        self.privclosefd()
                        self.privswapbackmagicquotes()
                        return v_result1
                    # end if
                    #// ----- Get the only interesting attributes
                    v_result = self.privconvertheader2fileinfo(v_header, p_file_list[v_nb_extracted])
                    if v_result != 1:
                        self.privclosefd()
                        self.privswapbackmagicquotes()
                        return v_result
                    # end if
                    v_nb_extracted += 1
                    v_nb_extracted += 1
                    #// ----- Look for user callback abort
                    if v_result1 == 2:
                        break
                    # end if
                else:
                    #// ----- Extracting the file
                    v_result1 = self.privextractfile(v_header, p_path, p_remove_path, p_remove_all_path, p_options)
                    if v_result1 < 1:
                        self.privclosefd()
                        self.privswapbackmagicquotes()
                        return v_result1
                    # end if
                    #// ----- Get the only interesting attributes
                    v_result = self.privconvertheader2fileinfo(v_header, p_file_list[v_nb_extracted])
                    if v_result != 1:
                        #// ----- Close the zip file
                        self.privclosefd()
                        self.privswapbackmagicquotes()
                        return v_result
                    # end if
                    v_nb_extracted += 1
                    v_nb_extracted += 1
                    #// ----- Look for user callback abort
                    if v_result1 == 2:
                        break
                    # end if
                # end if
            # end if
            i += 1
        # end while
        #// ----- Close the zip file
        self.privclosefd()
        self.privswapbackmagicquotes()
        #// ----- Return
        return v_result
    # end def privextractbyrule
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privExtractFile()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// 
    #// 1 : ... ?
    #// PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback
    #// --------------------------------------------------------------------------------
    def privextractfile(self, p_entry=None, p_path=None, p_remove_path=None, p_remove_all_path=None, p_options=None):
        
        v_result = 1
        #// ----- Read the file header
        v_result = self.privreadfileheader(v_header)
        if v_result != 1:
            #// ----- Return
            return v_result
        # end if
        #// ----- Check that the file header is coherent with $p_entry info
        if self.privcheckfileheaders(v_header, p_entry) != 1:
            pass
        # end if
        #// ----- Look for all path to remove
        if p_remove_all_path == True:
            #// ----- Look for folder entry that not need to be extracted
            if p_entry["external"] & 16 == 16:
                p_entry["status"] = "filtered"
                return v_result
            # end if
            #// ----- Get the basename of the path
            p_entry["filename"] = php_basename(p_entry["filename"])
        else:
            if p_remove_path != "":
                if PclZipUtilPathInclusion(p_remove_path, p_entry["filename"]) == 2:
                    #// ----- Change the file status
                    p_entry["status"] = "filtered"
                    #// ----- Return
                    return v_result
                # end if
                p_remove_path_size = php_strlen(p_remove_path)
                if php_substr(p_entry["filename"], 0, p_remove_path_size) == p_remove_path:
                    #// ----- Remove the path
                    p_entry["filename"] = php_substr(p_entry["filename"], p_remove_path_size)
                # end if
            # end if
        # end if
        #// ----- Add the path
        if p_path != "":
            p_entry["filename"] = p_path + "/" + p_entry["filename"]
        # end if
        #// ----- Check a base_dir_restriction
        if (php_isset(lambda : p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])):
            v_inclusion = PclZipUtilPathInclusion(p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION], p_entry["filename"])
            if v_inclusion == 0:
                PclZip.priverrorlog(PCLZIP_ERR_DIRECTORY_RESTRICTION, "Filename '" + p_entry["filename"] + "' is " + "outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION")
                return PclZip.errorcode()
            # end if
        # end if
        #// ----- Look for pre-extract callback
        if (php_isset(lambda : p_options[PCLZIP_CB_PRE_EXTRACT])):
            #// ----- Generate a local information
            v_local_header = Array()
            self.privconvertheader2fileinfo(p_entry, v_local_header)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result = p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, v_local_header)
            if v_result == 0:
                #// ----- Change the file status
                p_entry["status"] = "skipped"
                v_result = 1
            # end if
            #// ----- Look for abort result
            if v_result == 2:
                #// ----- This status is internal and will be changed in 'skipped'
                p_entry["status"] = "aborted"
                v_result = PCLZIP_ERR_USER_ABORTED
            # end if
            #// ----- Update the information
            #// Only some fields can be modified
            p_entry["filename"] = v_local_header["filename"]
        # end if
        #// ----- Look if extraction should be done
        if p_entry["status"] == "ok":
            #// ----- Look for specific actions while the file exist
            if php_file_exists(p_entry["filename"]):
                #// ----- Look if file is a directory
                if php_is_dir(p_entry["filename"]):
                    #// ----- Change the file status
                    p_entry["status"] = "already_a_directory"
                    #// ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                    #// For historical reason first PclZip implementation does not stop
                    #// when this kind of error occurs.
                    if (php_isset(lambda : p_options[PCLZIP_OPT_STOP_ON_ERROR])) and p_options[PCLZIP_OPT_STOP_ON_ERROR] == True:
                        PclZip.priverrorlog(PCLZIP_ERR_ALREADY_A_DIRECTORY, "Filename '" + p_entry["filename"] + "' is " + "already used by an existing directory")
                        return PclZip.errorcode()
                    # end if
                else:
                    if (not is_writeable(p_entry["filename"])):
                        #// ----- Change the file status
                        p_entry["status"] = "write_protected"
                        #// ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                        #// For historical reason first PclZip implementation does not stop
                        #// when this kind of error occurs.
                        if (php_isset(lambda : p_options[PCLZIP_OPT_STOP_ON_ERROR])) and p_options[PCLZIP_OPT_STOP_ON_ERROR] == True:
                            PclZip.priverrorlog(PCLZIP_ERR_WRITE_OPEN_FAIL, "Filename '" + p_entry["filename"] + "' exists " + "and is write protected")
                            return PclZip.errorcode()
                        # end if
                    else:
                        if filemtime(p_entry["filename"]) > p_entry["mtime"]:
                            #// ----- Change the file status
                            if (php_isset(lambda : p_options[PCLZIP_OPT_REPLACE_NEWER])) and p_options[PCLZIP_OPT_REPLACE_NEWER] == True:
                                pass
                            else:
                                p_entry["status"] = "newer_exist"
                                #// ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                                #// For historical reason first PclZip implementation does not stop
                                #// when this kind of error occurs.
                                if (php_isset(lambda : p_options[PCLZIP_OPT_STOP_ON_ERROR])) and p_options[PCLZIP_OPT_STOP_ON_ERROR] == True:
                                    PclZip.priverrorlog(PCLZIP_ERR_WRITE_OPEN_FAIL, "Newer version of '" + p_entry["filename"] + "' exists " + "and option PCLZIP_OPT_REPLACE_NEWER is not selected")
                                    return PclZip.errorcode()
                                # end if
                            # end if
                        # end if
                    # end if
                # end if
            else:
                if p_entry["external"] & 16 == 16 or php_substr(p_entry["filename"], -1) == "/":
                    v_dir_to_check = p_entry["filename"]
                else:
                    if (not php_strstr(p_entry["filename"], "/")):
                        v_dir_to_check = ""
                    else:
                        v_dir_to_check = php_dirname(p_entry["filename"])
                    # end if
                # end if
                v_result = self.privdircheck(v_dir_to_check, p_entry["external"] & 16 == 16)
                if v_result != 1:
                    #// ----- Change the file status
                    p_entry["status"] = "path_creation_fail"
                    #// ----- Return
                    #// return $v_result;
                    v_result = 1
                # end if
            # end if
        # end if
        #// ----- Look if extraction should be done
        if p_entry["status"] == "ok":
            #// ----- Do the extraction (if not a folder)
            if (not p_entry["external"] & 16 == 16):
                #// ----- Look for not compressed file
                if p_entry["compression"] == 0:
                    #// ----- Opening destination file
                    v_dest_file = php_no_error(lambda: fopen(p_entry["filename"], "wb"))
                    if v_dest_file == 0:
                        #// ----- Change the file status
                        p_entry["status"] = "write_error"
                        #// ----- Return
                        return v_result
                    # end if
                    #// ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
                    v_size = p_entry["compressed_size"]
                    while True:
                        
                        if not (v_size != 0):
                            break
                        # end if
                        v_read_size = v_size if v_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
                        v_buffer = php_no_error(lambda: fread(self.zip_fd, v_read_size))
                        #// Try to speed up the code
                        #// $v_binary_data = pack('a'.$v_read_size, $v_buffer);
                        #// @fwrite($v_dest_file, $v_binary_data, $v_read_size);
                        #//
                        php_no_error(lambda: fwrite(v_dest_file, v_buffer, v_read_size))
                        v_size -= v_read_size
                    # end while
                    #// ----- Closing the destination file
                    php_fclose(v_dest_file)
                    #// ----- Change the file mtime
                    touch(p_entry["filename"], p_entry["mtime"])
                else:
                    #// ----- TBC
                    #// Need to be finished
                    if p_entry["flag"] & 1 == 1:
                        PclZip.priverrorlog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, "File '" + p_entry["filename"] + "' is encrypted. Encrypted files are not supported.")
                        return PclZip.errorcode()
                    # end if
                    #// ----- Look for using temporary file to unzip
                    if (not (php_isset(lambda : p_options[PCLZIP_OPT_TEMP_FILE_OFF]))) and (php_isset(lambda : p_options[PCLZIP_OPT_TEMP_FILE_ON])) or (php_isset(lambda : p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) and p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= p_entry["size"]:
                        v_result = self.privextractfileusingtempfile(p_entry, p_options)
                        if v_result < PCLZIP_ERR_NO_ERROR:
                            return v_result
                        # end if
                    else:
                        #// ----- Read the compressed file in a buffer (one shot)
                        v_buffer = php_no_error(lambda: fread(self.zip_fd, p_entry["compressed_size"]))
                        #// ----- Decompress the file
                        v_file_content = php_no_error(lambda: gzinflate(v_buffer))
                        v_buffer = None
                        if v_file_content == False:
                            #// ----- Change the file status
                            #// TBC
                            p_entry["status"] = "error"
                            return v_result
                        # end if
                        #// ----- Opening destination file
                        v_dest_file = php_no_error(lambda: fopen(p_entry["filename"], "wb"))
                        if v_dest_file == 0:
                            #// ----- Change the file status
                            p_entry["status"] = "write_error"
                            return v_result
                        # end if
                        #// ----- Write the uncompressed data
                        php_no_error(lambda: fwrite(v_dest_file, v_file_content, p_entry["size"]))
                        v_file_content = None
                        #// ----- Closing the destination file
                        php_no_error(lambda: php_fclose(v_dest_file))
                    # end if
                    #// ----- Change the file mtime
                    php_no_error(lambda: touch(p_entry["filename"], p_entry["mtime"]))
                # end if
                #// ----- Look for chmod option
                if (php_isset(lambda : p_options[PCLZIP_OPT_SET_CHMOD])):
                    #// ----- Change the mode of the file
                    php_no_error(lambda: chmod(p_entry["filename"], p_options[PCLZIP_OPT_SET_CHMOD]))
                # end if
            # end if
        # end if
        #// ----- Change abort status
        if p_entry["status"] == "aborted":
            p_entry["status"] = "skipped"
            #// ----- Look for post-extract callback
        elif (php_isset(lambda : p_options[PCLZIP_CB_POST_EXTRACT])):
            #// ----- Generate a local information
            v_local_header = Array()
            self.privconvertheader2fileinfo(p_entry, v_local_header)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result = p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, v_local_header)
            #// ----- Look for abort result
            if v_result == 2:
                v_result = PCLZIP_ERR_USER_ABORTED
            # end if
        # end if
        #// ----- Return
        return v_result
    # end def privextractfile
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privExtractFileUsingTempFile()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privextractfileusingtempfile(self, p_entry=None, p_options=None):
        
        v_result = 1
        #// ----- Creates a temporary file
        v_gzip_temp_name = PCLZIP_TEMPORARY_DIR + uniqid("pclzip-") + ".gz"
        v_dest_file = php_no_error(lambda: fopen(v_gzip_temp_name, "wb"))
        if v_dest_file == 0:
            php_fclose(v_file)
            PclZip.priverrorlog(PCLZIP_ERR_WRITE_OPEN_FAIL, "Unable to open temporary file '" + v_gzip_temp_name + "' in binary write mode")
            return PclZip.errorcode()
        # end if
        #// ----- Write gz file format header
        v_binary_data = pack("va1a1Va1a1", 35615, Chr(p_entry["compression"]), Chr(0), time(), Chr(0), Chr(3))
        php_no_error(lambda: fwrite(v_dest_file, v_binary_data, 10))
        #// ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
        v_size = p_entry["compressed_size"]
        while True:
            
            if not (v_size != 0):
                break
            # end if
            v_read_size = v_size if v_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer = php_no_error(lambda: fread(self.zip_fd, v_read_size))
            #// $v_binary_data = pack('a'.$v_read_size, $v_buffer);
            php_no_error(lambda: fwrite(v_dest_file, v_buffer, v_read_size))
            v_size -= v_read_size
        # end while
        #// ----- Write gz file format footer
        v_binary_data = pack("VV", p_entry["crc"], p_entry["size"])
        php_no_error(lambda: fwrite(v_dest_file, v_binary_data, 8))
        #// ----- Close the temporary file
        php_no_error(lambda: php_fclose(v_dest_file))
        #// ----- Opening destination file
        v_dest_file = php_no_error(lambda: fopen(p_entry["filename"], "wb"))
        if v_dest_file == 0:
            p_entry["status"] = "write_error"
            return v_result
        # end if
        #// ----- Open the temporary gz file
        v_src_file = php_no_error(lambda: gzopen(v_gzip_temp_name, "rb"))
        if v_src_file == 0:
            php_no_error(lambda: php_fclose(v_dest_file))
            p_entry["status"] = "read_error"
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open temporary file '" + v_gzip_temp_name + "' in binary read mode")
            return PclZip.errorcode()
        # end if
        #// ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
        v_size = p_entry["size"]
        while True:
            
            if not (v_size != 0):
                break
            # end if
            v_read_size = v_size if v_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer = php_no_error(lambda: gzread(v_src_file, v_read_size))
            #// $v_binary_data = pack('a'.$v_read_size, $v_buffer);
            php_no_error(lambda: fwrite(v_dest_file, v_buffer, v_read_size))
            v_size -= v_read_size
        # end while
        php_no_error(lambda: php_fclose(v_dest_file))
        php_no_error(lambda: gzclose(v_src_file))
        #// ----- Delete the temporary file
        php_no_error(lambda: unlink(v_gzip_temp_name))
        #// ----- Return
        return v_result
    # end def privextractfileusingtempfile
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privExtractFileInOutput()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privextractfileinoutput(self, p_entry=None, p_options=None):
        
        v_result = 1
        #// ----- Read the file header
        v_result = self.privreadfileheader(v_header)
        if v_result != 1:
            return v_result
        # end if
        #// ----- Check that the file header is coherent with $p_entry info
        if self.privcheckfileheaders(v_header, p_entry) != 1:
            pass
        # end if
        #// ----- Look for pre-extract callback
        if (php_isset(lambda : p_options[PCLZIP_CB_PRE_EXTRACT])):
            #// ----- Generate a local information
            v_local_header = Array()
            self.privconvertheader2fileinfo(p_entry, v_local_header)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            #// eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');
            v_result = p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, v_local_header)
            if v_result == 0:
                #// ----- Change the file status
                p_entry["status"] = "skipped"
                v_result = 1
            # end if
            #// ----- Look for abort result
            if v_result == 2:
                #// ----- This status is internal and will be changed in 'skipped'
                p_entry["status"] = "aborted"
                v_result = PCLZIP_ERR_USER_ABORTED
            # end if
            #// ----- Update the information
            #// Only some fields can be modified
            p_entry["filename"] = v_local_header["filename"]
        # end if
        #// ----- Trace
        #// ----- Look if extraction should be done
        if p_entry["status"] == "ok":
            #// ----- Do the extraction (if not a folder)
            if (not p_entry["external"] & 16 == 16):
                #// ----- Look for not compressed file
                if p_entry["compressed_size"] == p_entry["size"]:
                    #// ----- Read the file in a buffer (one shot)
                    v_buffer = php_no_error(lambda: fread(self.zip_fd, p_entry["compressed_size"]))
                    #// ----- Send the file to the output
                    php_print(v_buffer)
                    v_buffer = None
                else:
                    #// ----- Read the compressed file in a buffer (one shot)
                    v_buffer = php_no_error(lambda: fread(self.zip_fd, p_entry["compressed_size"]))
                    #// ----- Decompress the file
                    v_file_content = gzinflate(v_buffer)
                    v_buffer = None
                    #// ----- Send the file to the output
                    php_print(v_file_content)
                    v_file_content = None
                # end if
            # end if
        # end if
        #// ----- Change abort status
        if p_entry["status"] == "aborted":
            p_entry["status"] = "skipped"
            #// ----- Look for post-extract callback
        elif (php_isset(lambda : p_options[PCLZIP_CB_POST_EXTRACT])):
            #// ----- Generate a local information
            v_local_header = Array()
            self.privconvertheader2fileinfo(p_entry, v_local_header)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result = p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, v_local_header)
            #// ----- Look for abort result
            if v_result == 2:
                v_result = PCLZIP_ERR_USER_ABORTED
            # end if
        # end if
        return v_result
    # end def privextractfileinoutput
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privExtractFileAsString()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privextractfileasstring(self, p_entry=None, p_string=None, p_options=None):
        
        v_result = 1
        #// ----- Read the file header
        v_header = Array()
        v_result = self.privreadfileheader(v_header)
        if v_result != 1:
            #// ----- Return
            return v_result
        # end if
        #// ----- Check that the file header is coherent with $p_entry info
        if self.privcheckfileheaders(v_header, p_entry) != 1:
            pass
        # end if
        #// ----- Look for pre-extract callback
        if (php_isset(lambda : p_options[PCLZIP_CB_PRE_EXTRACT])):
            #// ----- Generate a local information
            v_local_header = Array()
            self.privconvertheader2fileinfo(p_entry, v_local_header)
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result = p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, v_local_header)
            if v_result == 0:
                #// ----- Change the file status
                p_entry["status"] = "skipped"
                v_result = 1
            # end if
            #// ----- Look for abort result
            if v_result == 2:
                #// ----- This status is internal and will be changed in 'skipped'
                p_entry["status"] = "aborted"
                v_result = PCLZIP_ERR_USER_ABORTED
            # end if
            #// ----- Update the information
            #// Only some fields can be modified
            p_entry["filename"] = v_local_header["filename"]
        # end if
        #// ----- Look if extraction should be done
        if p_entry["status"] == "ok":
            #// ----- Do the extraction (if not a folder)
            if (not p_entry["external"] & 16 == 16):
                #// ----- Look for not compressed file
                #// if ($p_entry['compressed_size'] == $p_entry['size'])
                if p_entry["compression"] == 0:
                    #// ----- Reading the file
                    p_string = php_no_error(lambda: fread(self.zip_fd, p_entry["compressed_size"]))
                else:
                    #// ----- Reading the file
                    v_data = php_no_error(lambda: fread(self.zip_fd, p_entry["compressed_size"]))
                    #// ----- Decompress the file
                    p_string = php_no_error(lambda: gzinflate(v_data))
                    if p_string == False:
                        pass
                    # end if
                # end if
                pass
            else:
                pass
            # end if
        # end if
        #// ----- Change abort status
        if p_entry["status"] == "aborted":
            p_entry["status"] = "skipped"
            #// ----- Look for post-extract callback
        elif (php_isset(lambda : p_options[PCLZIP_CB_POST_EXTRACT])):
            #// ----- Generate a local information
            v_local_header = Array()
            self.privconvertheader2fileinfo(p_entry, v_local_header)
            #// ----- Swap the content to header
            v_local_header["content"] = p_string
            p_string = ""
            #// ----- Call the callback
            #// Here I do not use call_user_func() because I need to send a reference to the
            #// header.
            v_result = p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, v_local_header)
            #// ----- Swap back the content to header
            p_string = v_local_header["content"]
            v_local_header["content"] = None
            #// ----- Look for abort result
            if v_result == 2:
                v_result = PCLZIP_ERR_USER_ABORTED
            # end if
        # end if
        #// ----- Return
        return v_result
    # end def privextractfileasstring
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privReadFileHeader()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privreadfileheader(self, p_header=None):
        
        v_result = 1
        #// ----- Read the 4 bytes signature
        v_binary_data = php_no_error(lambda: fread(self.zip_fd, 4))
        v_data = unpack("Vid", v_binary_data)
        #// ----- Check signature
        if v_data["id"] != 67324752:
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Invalid archive structure")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Read the first 42 bytes of the header
        v_binary_data = fread(self.zip_fd, 26)
        #// ----- Look for invalid block size
        if php_strlen(v_binary_data) != 26:
            p_header["filename"] = ""
            p_header["status"] = "invalid_header"
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : " + php_strlen(v_binary_data))
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Extract the values
        v_data = unpack("vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len", v_binary_data)
        #// ----- Get filename
        p_header["filename"] = fread(self.zip_fd, v_data["filename_len"])
        #// ----- Get extra_fields
        if v_data["extra_len"] != 0:
            p_header["extra"] = fread(self.zip_fd, v_data["extra_len"])
        else:
            p_header["extra"] = ""
        # end if
        #// ----- Extract properties
        p_header["version_extracted"] = v_data["version"]
        p_header["compression"] = v_data["compression"]
        p_header["size"] = v_data["size"]
        p_header["compressed_size"] = v_data["compressed_size"]
        p_header["crc"] = v_data["crc"]
        p_header["flag"] = v_data["flag"]
        p_header["filename_len"] = v_data["filename_len"]
        #// ----- Recuperate date in UNIX format
        p_header["mdate"] = v_data["mdate"]
        p_header["mtime"] = v_data["mtime"]
        if p_header["mdate"] and p_header["mtime"]:
            #// ----- Extract time
            v_hour = p_header["mtime"] & 63488 >> 11
            v_minute = p_header["mtime"] & 2016 >> 5
            v_seconde = p_header["mtime"] & 31 * 2
            #// ----- Extract date
            v_year = p_header["mdate"] & 65024 >> 9 + 1980
            v_month = p_header["mdate"] & 480 >> 5
            v_day = p_header["mdate"] & 31
            #// ----- Get UNIX date format
            p_header["mtime"] = php_no_error(lambda: mktime(v_hour, v_minute, v_seconde, v_month, v_day, v_year))
        else:
            p_header["mtime"] = time()
        # end if
        #// TBC
        #// for(reset($v_data); $key = key($v_data); next($v_data)) {
        #// }
        #// ----- Set the stored filename
        p_header["stored_filename"] = p_header["filename"]
        #// ----- Set the status field
        p_header["status"] = "ok"
        #// ----- Return
        return v_result
    # end def privreadfileheader
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privReadCentralFileHeader()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privreadcentralfileheader(self, p_header=None):
        
        v_result = 1
        #// ----- Read the 4 bytes signature
        v_binary_data = php_no_error(lambda: fread(self.zip_fd, 4))
        v_data = unpack("Vid", v_binary_data)
        #// ----- Check signature
        if v_data["id"] != 33639248:
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Invalid archive structure")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Read the first 42 bytes of the header
        v_binary_data = fread(self.zip_fd, 42)
        #// ----- Look for invalid block size
        if php_strlen(v_binary_data) != 42:
            p_header["filename"] = ""
            p_header["status"] = "invalid_header"
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : " + php_strlen(v_binary_data))
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Extract the values
        p_header = unpack("vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset", v_binary_data)
        #// ----- Get filename
        if p_header["filename_len"] != 0:
            p_header["filename"] = fread(self.zip_fd, p_header["filename_len"])
        else:
            p_header["filename"] = ""
        # end if
        #// ----- Get extra
        if p_header["extra_len"] != 0:
            p_header["extra"] = fread(self.zip_fd, p_header["extra_len"])
        else:
            p_header["extra"] = ""
        # end if
        #// ----- Get comment
        if p_header["comment_len"] != 0:
            p_header["comment"] = fread(self.zip_fd, p_header["comment_len"])
        else:
            p_header["comment"] = ""
        # end if
        #// ----- Extract properties
        #// ----- Recuperate date in UNIX format
        #// if ($p_header['mdate'] && $p_header['mtime'])
        #// TBC : bug : this was ignoring time with 0/0/0
        if 1:
            #// ----- Extract time
            v_hour = p_header["mtime"] & 63488 >> 11
            v_minute = p_header["mtime"] & 2016 >> 5
            v_seconde = p_header["mtime"] & 31 * 2
            #// ----- Extract date
            v_year = p_header["mdate"] & 65024 >> 9 + 1980
            v_month = p_header["mdate"] & 480 >> 5
            v_day = p_header["mdate"] & 31
            #// ----- Get UNIX date format
            p_header["mtime"] = php_no_error(lambda: mktime(v_hour, v_minute, v_seconde, v_month, v_day, v_year))
        else:
            p_header["mtime"] = time()
        # end if
        #// ----- Set the stored filename
        p_header["stored_filename"] = p_header["filename"]
        #// ----- Set default status to ok
        p_header["status"] = "ok"
        #// ----- Look if it is a directory
        if php_substr(p_header["filename"], -1) == "/":
            #// $p_header['external'] = 0x41FF0010;
            p_header["external"] = 16
        # end if
        #// ----- Return
        return v_result
    # end def privreadcentralfileheader
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privCheckFileHeaders()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// 1 on success,
    #// 0 on error;
    #// --------------------------------------------------------------------------------
    def privcheckfileheaders(self, p_local_header=None, p_central_header=None):
        
        v_result = 1
        #// ----- Check the static values
        #// TBC
        if p_local_header["filename"] != p_central_header["filename"]:
            pass
        # end if
        if p_local_header["version_extracted"] != p_central_header["version_extracted"]:
            pass
        # end if
        if p_local_header["flag"] != p_central_header["flag"]:
            pass
        # end if
        if p_local_header["compression"] != p_central_header["compression"]:
            pass
        # end if
        if p_local_header["mtime"] != p_central_header["mtime"]:
            pass
        # end if
        if p_local_header["filename_len"] != p_central_header["filename_len"]:
            pass
        # end if
        #// ----- Look for flag bit 3
        if p_local_header["flag"] & 8 == 8:
            p_local_header["size"] = p_central_header["size"]
            p_local_header["compressed_size"] = p_central_header["compressed_size"]
            p_local_header["crc"] = p_central_header["crc"]
        # end if
        #// ----- Return
        return v_result
    # end def privcheckfileheaders
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privReadEndCentralDir()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privreadendcentraldir(self, p_central_dir=None):
        
        v_result = 1
        #// ----- Go to the end of the zip file
        v_size = filesize(self.zipname)
        php_no_error(lambda: fseek(self.zip_fd, v_size))
        if php_no_error(lambda: ftell(self.zip_fd)) != v_size:
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Unable to go to the end of the archive '" + self.zipname + "'")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- First try : look if this is an archive with no commentaries (most of the time)
        #// in this case the end of central dir is at 22 bytes of the file end
        v_found = 0
        if v_size > 26:
            php_no_error(lambda: fseek(self.zip_fd, v_size - 22))
            v_pos = php_no_error(lambda: ftell(self.zip_fd))
            if v_pos != v_size - 22:
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Unable to seek back to the middle of the archive '" + self.zipname + "'")
                #// ----- Return
                return PclZip.errorcode()
            # end if
            #// ----- Read for bytes
            v_binary_data = php_no_error(lambda: fread(self.zip_fd, 4))
            v_data = php_no_error(lambda: unpack("Vid", v_binary_data))
            #// ----- Check signature
            if v_data["id"] == 101010256:
                v_found = 1
            # end if
            v_pos = ftell(self.zip_fd)
        # end if
        #// ----- Go back to the maximum possible size of the Central Dir End Record
        if (not v_found):
            v_maximum_size = 65557
            #// 0xFFFF + 22;
            if v_maximum_size > v_size:
                v_maximum_size = v_size
            # end if
            php_no_error(lambda: fseek(self.zip_fd, v_size - v_maximum_size))
            if php_no_error(lambda: ftell(self.zip_fd)) != v_size - v_maximum_size:
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Unable to seek back to the middle of the archive '" + self.zipname + "'")
                #// ----- Return
                return PclZip.errorcode()
            # end if
            #// ----- Read byte per byte in order to find the signature
            v_pos = ftell(self.zip_fd)
            v_bytes = 0
            while True:
                
                if not (v_pos < v_size):
                    break
                # end if
                #// ----- Read a byte
                v_byte = php_no_error(lambda: fread(self.zip_fd, 1))
                #// -----  Add the byte
                #// $v_bytes = ($v_bytes << 8) | Ord($v_byte);
                #// Note we mask the old value down such that once shifted we can never end up with more than a 32bit number
                #// Otherwise on systems where we have 64bit integers the check below for the magic number will fail.
                v_bytes = v_bytes & 16777215 << 8 | Ord(v_byte)
                #// ----- Compare the bytes
                if v_bytes == 1347093766:
                    v_pos += 1
                    break
                # end if
                v_pos += 1
            # end while
            #// ----- Look if not found end of central dir
            if v_pos == v_size:
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Unable to find End of Central Dir Record signature")
                #// ----- Return
                return PclZip.errorcode()
            # end if
        # end if
        #// ----- Read the first 18 bytes of the header
        v_binary_data = fread(self.zip_fd, 18)
        #// ----- Look for invalid block size
        if php_strlen(v_binary_data) != 18:
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "Invalid End of Central Dir Record size : " + php_strlen(v_binary_data))
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Extract the values
        v_data = unpack("vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size", v_binary_data)
        #// ----- Check the global size
        if v_pos + v_data["comment_size"] + 18 != v_size:
            #// ----- Removed in release 2.2 see readme file
            #// The check of the file size is a little too strict.
            #// Some bugs where found when a zip is encrypted/decrypted with 'crypt'.
            #// While decrypted, zip has training 0 bytes
            if 0:
                #// ----- Error log
                PclZip.priverrorlog(PCLZIP_ERR_BAD_FORMAT, "The central dir is not at the end of the archive." + " Some trailing bytes exists after the archive.")
                #// ----- Return
                return PclZip.errorcode()
            # end if
        # end if
        #// ----- Get comment
        if v_data["comment_size"] != 0:
            p_central_dir["comment"] = fread(self.zip_fd, v_data["comment_size"])
        else:
            p_central_dir["comment"] = ""
        # end if
        p_central_dir["entries"] = v_data["entries"]
        p_central_dir["disk_entries"] = v_data["disk_entries"]
        p_central_dir["offset"] = v_data["offset"]
        p_central_dir["size"] = v_data["size"]
        p_central_dir["disk"] = v_data["disk"]
        p_central_dir["disk_start"] = v_data["disk_start"]
        #// TBC
        #// for(reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {
        #// }
        #// ----- Return
        return v_result
    # end def privreadendcentraldir
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privDeleteByRule()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privdeletebyrule(self, p_result_list=None, p_options=None):
        
        v_result = 1
        v_list_detail = Array()
        #// ----- Open the zip file
        v_result = self.privopenfd("rb")
        if v_result != 1:
            #// ----- Return
            return v_result
        # end if
        #// ----- Read the central directory information
        v_central_dir = Array()
        v_result = self.privreadendcentraldir(v_central_dir)
        if v_result != 1:
            self.privclosefd()
            return v_result
        # end if
        #// ----- Go to beginning of File
        php_no_error(lambda: rewind(self.zip_fd))
        #// ----- Scan all the files
        #// ----- Start at beginning of Central Dir
        v_pos_entry = v_central_dir["offset"]
        php_no_error(lambda: rewind(self.zip_fd))
        if php_no_error(lambda: fseek(self.zip_fd, v_pos_entry)):
            #// ----- Close the zip file
            self.privclosefd()
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, "Invalid archive size")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Read each entry
        v_header_list = Array()
        j_start = 0
        i = 0
        v_nb_extracted = 0
        while i < v_central_dir["entries"]:
            
            #// ----- Read the file header
            v_header_list[v_nb_extracted] = Array()
            v_result = self.privreadcentralfileheader(v_header_list[v_nb_extracted])
            if v_result != 1:
                #// ----- Close the zip file
                self.privclosefd()
                return v_result
            # end if
            #// ----- Store the index
            v_header_list[v_nb_extracted]["index"] = i
            #// ----- Look for the specific extract rules
            v_found = False
            #// ----- Look for extract by name rule
            if (php_isset(lambda : p_options[PCLZIP_OPT_BY_NAME])) and p_options[PCLZIP_OPT_BY_NAME] != 0:
                #// ----- Look if the filename is in the list
                j = 0
                while j < sizeof(p_options[PCLZIP_OPT_BY_NAME]) and (not v_found):
                    
                    #// ----- Look for a directory
                    if php_substr(p_options[PCLZIP_OPT_BY_NAME][j], -1) == "/":
                        #// ----- Look if the directory is in the filename path
                        if php_strlen(v_header_list[v_nb_extracted]["stored_filename"]) > php_strlen(p_options[PCLZIP_OPT_BY_NAME][j]) and php_substr(v_header_list[v_nb_extracted]["stored_filename"], 0, php_strlen(p_options[PCLZIP_OPT_BY_NAME][j])) == p_options[PCLZIP_OPT_BY_NAME][j]:
                            v_found = True
                        elif v_header_list[v_nb_extracted]["external"] & 16 == 16 and v_header_list[v_nb_extracted]["stored_filename"] + "/" == p_options[PCLZIP_OPT_BY_NAME][j]:
                            v_found = True
                        # end if
                        #// ----- Look for a filename
                    elif v_header_list[v_nb_extracted]["stored_filename"] == p_options[PCLZIP_OPT_BY_NAME][j]:
                        v_found = True
                    # end if
                    j += 1
                # end while
            else:
                if (php_isset(lambda : p_options[PCLZIP_OPT_BY_PREG])) and p_options[PCLZIP_OPT_BY_PREG] != "":
                    if php_preg_match(p_options[PCLZIP_OPT_BY_PREG], v_header_list[v_nb_extracted]["stored_filename"]):
                        v_found = True
                    # end if
                else:
                    if (php_isset(lambda : p_options[PCLZIP_OPT_BY_INDEX])) and p_options[PCLZIP_OPT_BY_INDEX] != 0:
                        #// ----- Look if the index is in the list
                        j = j_start
                        while j < sizeof(p_options[PCLZIP_OPT_BY_INDEX]) and (not v_found):
                            
                            if i >= p_options[PCLZIP_OPT_BY_INDEX][j]["start"] and i <= p_options[PCLZIP_OPT_BY_INDEX][j]["end"]:
                                v_found = True
                            # end if
                            if i >= p_options[PCLZIP_OPT_BY_INDEX][j]["end"]:
                                j_start = j + 1
                            # end if
                            if p_options[PCLZIP_OPT_BY_INDEX][j]["start"] > i:
                                break
                            # end if
                            j += 1
                        # end while
                    else:
                        v_found = True
                    # end if
                # end if
            # end if
            #// ----- Look for deletion
            if v_found:
                v_header_list[v_nb_extracted] = None
            else:
                v_nb_extracted += 1
            # end if
            i += 1
        # end while
        #// ----- Look if something need to be deleted
        if v_nb_extracted > 0:
            #// ----- Creates a temporary file
            v_zip_temp_name = PCLZIP_TEMPORARY_DIR + uniqid("pclzip-") + ".tmp"
            #// ----- Creates a temporary zip archive
            v_temp_zip = php_new_class("PclZip", lambda : PclZip(v_zip_temp_name))
            #// ----- Open the temporary zip file in write mode
            v_result = v_temp_zip.privopenfd("wb")
            if v_result != 1:
                self.privclosefd()
                #// ----- Return
                return v_result
            # end if
            #// ----- Look which file need to be kept
            i = 0
            while i < sizeof(v_header_list):
                
                #// ----- Calculate the position of the header
                php_no_error(lambda: rewind(self.zip_fd))
                if php_no_error(lambda: fseek(self.zip_fd, v_header_list[i]["offset"])):
                    #// ----- Close the zip file
                    self.privclosefd()
                    v_temp_zip.privclosefd()
                    php_no_error(lambda: unlink(v_zip_temp_name))
                    #// ----- Error log
                    PclZip.priverrorlog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, "Invalid archive size")
                    #// ----- Return
                    return PclZip.errorcode()
                # end if
                #// ----- Read the file header
                v_local_header = Array()
                v_result = self.privreadfileheader(v_local_header)
                if v_result != 1:
                    #// ----- Close the zip file
                    self.privclosefd()
                    v_temp_zip.privclosefd()
                    php_no_error(lambda: unlink(v_zip_temp_name))
                    #// ----- Return
                    return v_result
                # end if
                #// ----- Check that local file header is same as central file header
                if self.privcheckfileheaders(v_local_header, v_header_list[i]) != 1:
                    pass
                # end if
                v_local_header = None
                #// ----- Write the file header
                v_result = v_temp_zip.privwritefileheader(v_header_list[i])
                if v_result != 1:
                    #// ----- Close the zip file
                    self.privclosefd()
                    v_temp_zip.privclosefd()
                    php_no_error(lambda: unlink(v_zip_temp_name))
                    #// ----- Return
                    return v_result
                # end if
                #// ----- Read/write the data block
                v_result = PclZipUtilCopyBlock(self.zip_fd, v_temp_zip.zip_fd, v_header_list[i]["compressed_size"])
                if v_result != 1:
                    #// ----- Close the zip file
                    self.privclosefd()
                    v_temp_zip.privclosefd()
                    php_no_error(lambda: unlink(v_zip_temp_name))
                    #// ----- Return
                    return v_result
                # end if
                i += 1
            # end while
            #// ----- Store the offset of the central dir
            v_offset = php_no_error(lambda: ftell(v_temp_zip.zip_fd))
            #// ----- Re-Create the Central Dir files header
            i = 0
            while i < sizeof(v_header_list):
                
                #// ----- Create the file header
                v_result = v_temp_zip.privwritecentralfileheader(v_header_list[i])
                if v_result != 1:
                    v_temp_zip.privclosefd()
                    self.privclosefd()
                    php_no_error(lambda: unlink(v_zip_temp_name))
                    #// ----- Return
                    return v_result
                # end if
                #// ----- Transform the header to a 'usable' info
                v_temp_zip.privconvertheader2fileinfo(v_header_list[i], p_result_list[i])
                i += 1
            # end while
            #// ----- Zip file comment
            v_comment = ""
            if (php_isset(lambda : p_options[PCLZIP_OPT_COMMENT])):
                v_comment = p_options[PCLZIP_OPT_COMMENT]
            # end if
            #// ----- Calculate the size of the central header
            v_size = php_no_error(lambda: ftell(v_temp_zip.zip_fd)) - v_offset
            #// ----- Create the central dir footer
            v_result = v_temp_zip.privwritecentralheader(sizeof(v_header_list), v_size, v_offset, v_comment)
            if v_result != 1:
                v_header_list = None
                v_temp_zip.privclosefd()
                self.privclosefd()
                php_no_error(lambda: unlink(v_zip_temp_name))
                #// ----- Return
                return v_result
            # end if
            #// ----- Close
            v_temp_zip.privclosefd()
            self.privclosefd()
            #// ----- Delete the zip file
            #// TBC : I should test the result ...
            php_no_error(lambda: unlink(self.zipname))
            #// ----- Rename the temporary file
            #// TBC : I should test the result ...
            #// @rename($v_zip_temp_name, $this->zipname);
            PclZipUtilRename(v_zip_temp_name, self.zipname)
            v_temp_zip = None
        else:
            if v_central_dir["entries"] != 0:
                self.privclosefd()
                v_result = self.privopenfd("wb")
                if v_result != 1:
                    return v_result
                # end if
                v_result = self.privwritecentralheader(0, 0, 0, "")
                if v_result != 1:
                    return v_result
                # end if
                self.privclosefd()
            # end if
        # end if
        #// ----- Return
        return v_result
    # end def privdeletebyrule
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privDirCheck()
    #// Description :
    #// Check if a directory exists, if not it creates it and all the parents directory
    #// which may be useful.
    #// Parameters :
    #// $p_dir : Directory path to check.
    #// Return Values :
    #// 1 : OK
    #// -1 : Unable to create directory
    #// --------------------------------------------------------------------------------
    def privdircheck(self, p_dir=None, p_is_dir=False):
        
        v_result = 1
        #// ----- Remove the final '/'
        if p_is_dir and php_substr(p_dir, -1) == "/":
            p_dir = php_substr(p_dir, 0, php_strlen(p_dir) - 1)
        # end if
        #// ----- Check the directory availability
        if php_is_dir(p_dir) or p_dir == "":
            return 1
        # end if
        #// ----- Extract parent directory
        p_parent_dir = php_dirname(p_dir)
        #// ----- Just a check
        if p_parent_dir != p_dir:
            #// ----- Look for parent directory
            if p_parent_dir != "":
                v_result = self.privdircheck(p_parent_dir)
                if v_result != 1:
                    return v_result
                # end if
            # end if
        # end if
        #// ----- Create the directory
        if (not php_no_error(lambda: mkdir(p_dir, 511))):
            #// ----- Error log
            PclZip.priverrorlog(PCLZIP_ERR_DIR_CREATE_FAIL, str("Unable to create directory '") + str(p_dir) + str("'"))
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Return
        return v_result
    # end def privdircheck
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privMerge()
    #// Description :
    #// If $p_archive_to_add does not exist, the function exit with a success result.
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privmerge(self, p_archive_to_add=None):
        
        v_result = 1
        #// ----- Look if the archive_to_add exists
        if (not php_is_file(p_archive_to_add.zipname)):
            #// ----- Nothing to merge, so merge is a success
            v_result = 1
            #// ----- Return
            return v_result
        # end if
        #// ----- Look if the archive exists
        if (not php_is_file(self.zipname)):
            #// ----- Do a duplicate
            v_result = self.privduplicate(p_archive_to_add.zipname)
            #// ----- Return
            return v_result
        # end if
        #// ----- Open the zip file
        v_result = self.privopenfd("rb")
        if v_result != 1:
            #// ----- Return
            return v_result
        # end if
        #// ----- Read the central directory information
        v_central_dir = Array()
        v_result = self.privreadendcentraldir(v_central_dir)
        if v_result != 1:
            self.privclosefd()
            return v_result
        # end if
        #// ----- Go to beginning of File
        php_no_error(lambda: rewind(self.zip_fd))
        #// ----- Open the archive_to_add file
        v_result = p_archive_to_add.privopenfd("rb")
        if v_result != 1:
            self.privclosefd()
            #// ----- Return
            return v_result
        # end if
        #// ----- Read the central directory information
        v_central_dir_to_add = Array()
        v_result = p_archive_to_add.privreadendcentraldir(v_central_dir_to_add)
        if v_result != 1:
            self.privclosefd()
            p_archive_to_add.privclosefd()
            return v_result
        # end if
        #// ----- Go to beginning of File
        php_no_error(lambda: rewind(p_archive_to_add.zip_fd))
        #// ----- Creates a temporary file
        v_zip_temp_name = PCLZIP_TEMPORARY_DIR + uniqid("pclzip-") + ".tmp"
        #// ----- Open the temporary file in write mode
        v_zip_temp_fd = php_no_error(lambda: fopen(v_zip_temp_name, "wb"))
        if v_zip_temp_fd == 0:
            self.privclosefd()
            p_archive_to_add.privclosefd()
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open temporary file '" + v_zip_temp_name + "' in binary write mode")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Copy the files from the archive to the temporary file
        #// TBC : Here I should better append the file and go back to erase the central dir
        v_size = v_central_dir["offset"]
        while True:
            
            if not (v_size != 0):
                break
            # end if
            v_read_size = v_size if v_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer = fread(self.zip_fd, v_read_size)
            php_no_error(lambda: fwrite(v_zip_temp_fd, v_buffer, v_read_size))
            v_size -= v_read_size
        # end while
        #// ----- Copy the files from the archive_to_add into the temporary file
        v_size = v_central_dir_to_add["offset"]
        while True:
            
            if not (v_size != 0):
                break
            # end if
            v_read_size = v_size if v_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer = fread(p_archive_to_add.zip_fd, v_read_size)
            php_no_error(lambda: fwrite(v_zip_temp_fd, v_buffer, v_read_size))
            v_size -= v_read_size
        # end while
        #// ----- Store the offset of the central dir
        v_offset = php_no_error(lambda: ftell(v_zip_temp_fd))
        #// ----- Copy the block of file headers from the old archive
        v_size = v_central_dir["size"]
        while True:
            
            if not (v_size != 0):
                break
            # end if
            v_read_size = v_size if v_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer = php_no_error(lambda: fread(self.zip_fd, v_read_size))
            php_no_error(lambda: fwrite(v_zip_temp_fd, v_buffer, v_read_size))
            v_size -= v_read_size
        # end while
        #// ----- Copy the block of file headers from the archive_to_add
        v_size = v_central_dir_to_add["size"]
        while True:
            
            if not (v_size != 0):
                break
            # end if
            v_read_size = v_size if v_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer = php_no_error(lambda: fread(p_archive_to_add.zip_fd, v_read_size))
            php_no_error(lambda: fwrite(v_zip_temp_fd, v_buffer, v_read_size))
            v_size -= v_read_size
        # end while
        #// ----- Merge the file comments
        v_comment = v_central_dir["comment"] + " " + v_central_dir_to_add["comment"]
        #// ----- Calculate the size of the (new) central header
        v_size = php_no_error(lambda: ftell(v_zip_temp_fd)) - v_offset
        #// ----- Swap the file descriptor
        #// Here is a trick : I swap the temporary fd with the zip fd, in order to use
        #// the following methods on the temporary fil and not the real archive fd
        v_swap = self.zip_fd
        self.zip_fd = v_zip_temp_fd
        v_zip_temp_fd = v_swap
        #// ----- Create the central dir footer
        v_result = self.privwritecentralheader(v_central_dir["entries"] + v_central_dir_to_add["entries"], v_size, v_offset, v_comment)
        if v_result != 1:
            self.privclosefd()
            p_archive_to_add.privclosefd()
            php_no_error(lambda: php_fclose(v_zip_temp_fd))
            self.zip_fd = None
            v_header_list = None
            #// ----- Return
            return v_result
        # end if
        #// ----- Swap back the file descriptor
        v_swap = self.zip_fd
        self.zip_fd = v_zip_temp_fd
        v_zip_temp_fd = v_swap
        #// ----- Close
        self.privclosefd()
        p_archive_to_add.privclosefd()
        #// ----- Close the temporary file
        php_no_error(lambda: php_fclose(v_zip_temp_fd))
        #// ----- Delete the zip file
        #// TBC : I should test the result ...
        php_no_error(lambda: unlink(self.zipname))
        #// ----- Rename the temporary file
        #// TBC : I should test the result ...
        #// @rename($v_zip_temp_name, $this->zipname);
        PclZipUtilRename(v_zip_temp_name, self.zipname)
        #// ----- Return
        return v_result
    # end def privmerge
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privDuplicate()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privduplicate(self, p_archive_filename=None):
        
        v_result = 1
        #// ----- Look if the $p_archive_filename exists
        if (not php_is_file(p_archive_filename)):
            #// ----- Nothing to duplicate, so duplicate is a success.
            v_result = 1
            #// ----- Return
            return v_result
        # end if
        #// ----- Open the zip file
        v_result = self.privopenfd("wb")
        if v_result != 1:
            #// ----- Return
            return v_result
        # end if
        #// ----- Open the temporary file in write mode
        v_zip_temp_fd = php_no_error(lambda: fopen(p_archive_filename, "rb"))
        if v_zip_temp_fd == 0:
            self.privclosefd()
            PclZip.priverrorlog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open archive file '" + p_archive_filename + "' in binary write mode")
            #// ----- Return
            return PclZip.errorcode()
        # end if
        #// ----- Copy the files from the archive to the temporary file
        #// TBC : Here I should better append the file and go back to erase the central dir
        v_size = filesize(p_archive_filename)
        while True:
            
            if not (v_size != 0):
                break
            # end if
            v_read_size = v_size if v_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer = fread(v_zip_temp_fd, v_read_size)
            php_no_error(lambda: fwrite(self.zip_fd, v_buffer, v_read_size))
            v_size -= v_read_size
        # end while
        #// ----- Close
        self.privclosefd()
        #// ----- Close the temporary file
        php_no_error(lambda: php_fclose(v_zip_temp_fd))
        #// ----- Return
        return v_result
    # end def privduplicate
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privErrorLog()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def priverrorlog(self, p_error_code=0, p_error_string=""):
        
        if PCLZIP_ERROR_EXTERNAL == 1:
            PclError(p_error_code, p_error_string)
        else:
            self.error_code = p_error_code
            self.error_string = p_error_string
        # end if
    # end def priverrorlog
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privErrorReset()
    #// Description :
    #// Parameters :
    #// --------------------------------------------------------------------------------
    def priverrorreset(self):
        
        if PCLZIP_ERROR_EXTERNAL == 1:
            PclErrorReset()
        else:
            self.error_code = 0
            self.error_string = ""
        # end if
    # end def priverrorreset
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privDisableMagicQuotes()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privdisablemagicquotes(self):
        
        v_result = 1
        #// EDIT for WordPress 5.3.0
        #// magic_quote functions are deprecated in PHP 7.4, now assuming it's always off.
        #// 
        #// ----- Look if function exists
        #// if (   (!function_exists("get_magic_quotes_runtime"))
        #// || (!function_exists("set_magic_quotes_runtime"))) {
        #// return $v_result;
        #// }
        #// ----- Look if already done
        #// if ($this->magic_quotes_status != -1) {
        #// return $v_result;
        #// }
        #// ----- Get and memorize the magic_quote value
        #// $this->magic_quotes_status = @get_magic_quotes_runtime();
        #// ----- Disable magic_quotes
        #// if ($this->magic_quotes_status == 1) {
        #// @set_magic_quotes_runtime(0);
        #// }
        #// 
        #// ----- Return
        return v_result
    # end def privdisablemagicquotes
    #// --------------------------------------------------------------------------------
    #// --------------------------------------------------------------------------------
    #// Function : privSwapBackMagicQuotes()
    #// Description :
    #// Parameters :
    #// Return Values :
    #// --------------------------------------------------------------------------------
    def privswapbackmagicquotes(self):
        
        v_result = 1
        #// EDIT for WordPress 5.3.0
        #// magic_quote functions are deprecated in PHP 7.4, now assuming it's always off.
        #// 
        #// ----- Look if function exists
        #// if (   (!function_exists("get_magic_quotes_runtime"))
        #// || (!function_exists("set_magic_quotes_runtime"))) {
        #// return $v_result;
        #// }
        #// ----- Look if something to do
        #// if ($this->magic_quotes_status != -1) {
        #// return $v_result;
        #// }
        #// ----- Swap back magic_quotes
        #// if ($this->magic_quotes_status == 1) {
        #// @set_magic_quotes_runtime($this->magic_quotes_status);
        #// }
        #// 
        #// ----- Return
        return v_result
    # end def privswapbackmagicquotes
    pass
# end class PclZip
#// End of class
#// --------------------------------------------------------------------------------
#// --------------------------------------------------------------------------------
#// Function : PclZipUtilPathReduction()
#// Description :
#// Parameters :
#// Return Values :
#// --------------------------------------------------------------------------------
def PclZipUtilPathReduction(p_dir=None, *args_):
    
    v_result = ""
    #// ----- Look for not empty path
    if p_dir != "":
        #// ----- Explode path by directory names
        v_list = php_explode("/", p_dir)
        #// ----- Study directories from last to first
        v_skip = 0
        i = sizeof(v_list) - 1
        while i >= 0:
            
            #// ----- Look for current path
            if v_list[i] == ".":
                pass
            else:
                if v_list[i] == "..":
                    v_skip += 1
                else:
                    if v_list[i] == "":
                        #// ----- First '/' i.e. root slash
                        if i == 0:
                            v_result = "/" + v_result
                            if v_skip > 0:
                                #// ----- It is an invalid path, so the path is not modified
                                #// TBC
                                v_result = p_dir
                                v_skip = 0
                            # end if
                        else:
                            if i == sizeof(v_list) - 1:
                                v_result = v_list[i]
                            else:
                                pass
                            # end if
                        # end if
                    else:
                        #// ----- Look for item to skip
                        if v_skip > 0:
                            v_skip -= 1
                        else:
                            v_result = v_list[i] + "/" + v_result if i != sizeof(v_list) - 1 else ""
                        # end if
                    # end if
                # end if
            # end if
            i -= 1
        # end while
        #// ----- Look for skip
        if v_skip > 0:
            while True:
                
                if not (v_skip > 0):
                    break
                # end if
                v_result = "../" + v_result
                v_skip -= 1
            # end while
        # end if
    # end if
    #// ----- Return
    return v_result
# end def PclZipUtilPathReduction
#// --------------------------------------------------------------------------------
#// --------------------------------------------------------------------------------
#// Function : PclZipUtilPathInclusion()
#// Description :
#// This function indicates if the path $p_path is under the $p_dir tree. Or,
#// said in an other way, if the file or sub-dir $p_path is inside the dir
#// $p_dir.
#// The function indicates also if the path is exactly the same as the dir.
#// This function supports path with duplicated '/' like '//', but does not
#// support '.' or '..' statements.
#// Parameters :
#// Return Values :
#// 0 if $p_path is not inside directory $p_dir
#// 1 if $p_path is inside directory $p_dir
#// 2 if $p_path is exactly the same as $p_dir
#// --------------------------------------------------------------------------------
def PclZipUtilPathInclusion(p_dir=None, p_path=None, *args_):
    
    v_result = 1
    #// ----- Look for path beginning by .
    if p_dir == "." or php_strlen(p_dir) >= 2 and php_substr(p_dir, 0, 2) == "./":
        p_dir = PclZipUtilTranslateWinPath(php_getcwd(), False) + "/" + php_substr(p_dir, 1)
    # end if
    if p_path == "." or php_strlen(p_path) >= 2 and php_substr(p_path, 0, 2) == "./":
        p_path = PclZipUtilTranslateWinPath(php_getcwd(), False) + "/" + php_substr(p_path, 1)
    # end if
    #// ----- Explode dir and path by directory separator
    v_list_dir = php_explode("/", p_dir)
    v_list_dir_size = sizeof(v_list_dir)
    v_list_path = php_explode("/", p_path)
    v_list_path_size = sizeof(v_list_path)
    #// ----- Study directories paths
    i = 0
    j = 0
    while True:
        
        if not (i < v_list_dir_size and j < v_list_path_size and v_result):
            break
        # end if
        #// ----- Look for empty dir (path reduction)
        if v_list_dir[i] == "":
            i += 1
            continue
        # end if
        if v_list_path[j] == "":
            j += 1
            continue
        # end if
        #// ----- Compare the items
        if v_list_dir[i] != v_list_path[j] and v_list_dir[i] != "" and v_list_path[j] != "":
            v_result = 0
        # end if
        #// ----- Next items
        i += 1
        j += 1
    # end while
    #// ----- Look if everything seems to be the same
    if v_result:
        #// ----- Skip all the empty items
        while True:
            
            if not (j < v_list_path_size and v_list_path[j] == ""):
                break
            # end if
            j += 1
        # end while
        while True:
            
            if not (i < v_list_dir_size and v_list_dir[i] == ""):
                break
            # end if
            i += 1
        # end while
        if i >= v_list_dir_size and j >= v_list_path_size:
            #// ----- There are exactly the same
            v_result = 2
        else:
            if i < v_list_dir_size:
                #// ----- The path is shorter than the dir
                v_result = 0
            # end if
        # end if
    # end if
    #// ----- Return
    return v_result
# end def PclZipUtilPathInclusion
#// --------------------------------------------------------------------------------
#// --------------------------------------------------------------------------------
#// Function : PclZipUtilCopyBlock()
#// Description :
#// Parameters :
#// $p_mode : read/write compression mode
#// 0 : src & dest normal
#// 1 : src gzip, dest normal
#// 2 : src normal, dest gzip
#// 3 : src & dest gzip
#// Return Values :
#// --------------------------------------------------------------------------------
def PclZipUtilCopyBlock(p_src=None, p_dest=None, p_size=None, p_mode=0, *args_):
    
    v_result = 1
    if p_mode == 0:
        while True:
            
            if not (p_size != 0):
                break
            # end if
            v_read_size = p_size if p_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
            v_buffer = php_no_error(lambda: fread(p_src, v_read_size))
            php_no_error(lambda: fwrite(p_dest, v_buffer, v_read_size))
            p_size -= v_read_size
        # end while
    else:
        if p_mode == 1:
            while True:
                
                if not (p_size != 0):
                    break
                # end if
                v_read_size = p_size if p_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
                v_buffer = php_no_error(lambda: gzread(p_src, v_read_size))
                php_no_error(lambda: fwrite(p_dest, v_buffer, v_read_size))
                p_size -= v_read_size
            # end while
        else:
            if p_mode == 2:
                while True:
                    
                    if not (p_size != 0):
                        break
                    # end if
                    v_read_size = p_size if p_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
                    v_buffer = php_no_error(lambda: fread(p_src, v_read_size))
                    php_no_error(lambda: gzwrite(p_dest, v_buffer, v_read_size))
                    p_size -= v_read_size
                # end while
            else:
                if p_mode == 3:
                    while True:
                        
                        if not (p_size != 0):
                            break
                        # end if
                        v_read_size = p_size if p_size < PCLZIP_READ_BLOCK_SIZE else PCLZIP_READ_BLOCK_SIZE
                        v_buffer = php_no_error(lambda: gzread(p_src, v_read_size))
                        php_no_error(lambda: gzwrite(p_dest, v_buffer, v_read_size))
                        p_size -= v_read_size
                    # end while
                # end if
            # end if
        # end if
    # end if
    #// ----- Return
    return v_result
# end def PclZipUtilCopyBlock
#// --------------------------------------------------------------------------------
#// --------------------------------------------------------------------------------
#// Function : PclZipUtilRename()
#// Description :
#// This function tries to do a simple rename() function. If it fails, it
#// tries to copy the $p_src file in a new $p_dest file and then unlink the
#// first one.
#// Parameters :
#// $p_src : Old filename
#// $p_dest : New filename
#// Return Values :
#// 1 on success, 0 on failure.
#// --------------------------------------------------------------------------------
def PclZipUtilRename(p_src=None, p_dest=None, *args_):
    
    v_result = 1
    #// ----- Try to rename the files
    if (not php_no_error(lambda: rename(p_src, p_dest))):
        #// ----- Try to copy & unlink the src
        if (not php_no_error(lambda: copy(p_src, p_dest))):
            v_result = 0
        else:
            if (not php_no_error(lambda: unlink(p_src))):
                v_result = 0
            # end if
        # end if
    # end if
    #// ----- Return
    return v_result
# end def PclZipUtilRename
#// --------------------------------------------------------------------------------
#// --------------------------------------------------------------------------------
#// Function : PclZipUtilOptionText()
#// Description :
#// Translate option value in text. Mainly for debug purpose.
#// Parameters :
#// $p_option : the option value.
#// Return Values :
#// The option text value.
#// --------------------------------------------------------------------------------
def PclZipUtilOptionText(p_option=None, *args_):
    
    v_list = get_defined_constants()
    reset(v_list)
    while v_key:
        v_key = key(v_list)
        v_prefix = php_substr(v_key, 0, 10)
        if v_prefix == "PCLZIP_OPT" or v_prefix == "PCLZIP_CB_" or v_prefix == "PCLZIP_ATT" and v_list[v_key] == p_option:
            return v_key
        # end if
        next(v_list)
    # end while
    v_result = "Unknown"
    return v_result
# end def PclZipUtilOptionText
#// --------------------------------------------------------------------------------
#// --------------------------------------------------------------------------------
#// Function : PclZipUtilTranslateWinPath()
#// Description :
#// Translate windows path by replacing '\' by '/' and optionally removing
#// drive letter.
#// Parameters :
#// $p_path : path to translate.
#// $p_remove_disk_letter : true | false
#// Return Values :
#// The path translated.
#// --------------------------------------------------------------------------------
def PclZipUtilTranslateWinPath(p_path=None, p_remove_disk_letter=True, *args_):
    
    if php_stristr(php_uname(), "windows"):
        #// ----- Look for potential disk letter
        v_position = php_strpos(p_path, ":")
        if p_remove_disk_letter and v_position != False:
            p_path = php_substr(p_path, v_position + 1)
        # end if
        #// ----- Change potential windows directory separator
        if php_strpos(p_path, "\\") > 0 or php_substr(p_path, 0, 1) == "\\":
            p_path = php_strtr(p_path, "\\", "/")
        # end if
    # end if
    return p_path
# end def PclZipUtilTranslateWinPath
pass
